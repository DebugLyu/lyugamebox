require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":2}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"AudioManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2d25csWywZJLob07SbW5PEr', 'AudioManager');
// Script/Manager/AudioManager.js

'use strict';

//AudioManager.js
var AMgr = cc.Class({
	properties: {
		_sound_size: 0.5,
		_current: 0,
		_curbgm: ""
	},
	statics: {
		init: function init() {
			var size = cc.sys.localStorage.getItem('soundSize');
			if (size == null) {
				size = 1;
				cc.sys.localStorage.setItem('soundSize', 1);
			}
			size = Number(size);
			this._sound_size = size;

			cc.game.on(cc.game.EVENT_HIDE, function () {
				console.log("cc.audioEngine.pauseAll");
				cc.audioEngine.pauseAll();
			});
			cc.game.on(cc.game.EVENT_SHOW, function () {
				console.log("cc.audioEngine.resumeAll");
				cc.audioEngine.resumeAll();
			});
		},
		getUrl: function getUrl(url) {
			return cc.url.raw("resources/sound/" + url + ".mp3");
		},

		playBGM: function playBGM(url) {
			this._curbgm = url;
			if (this._sound_size <= 0) {
				return;
			}
			var audioUrl = this.getUrl(url);
			console.log(audioUrl);
			if (this._current >= 0) {
				cc.audioEngine.stop(this._current);
			}
			this._current = cc.audioEngine.play(audioUrl, true, this._sound_size);
		},
		stopBGM: function stopBGM() {
			cc.audioEngine.stop(this._current);
		},
		pauseBGM: function pauseBGM() {
			cc.audioEngine.pause(this._current);
		},
		resumeBGM: function resumeBGM() {
			cc.audioEngine.resume(this._current);
		},

		setSize: function setSize(size) {
			if (size < 0 || size > 1) {
				return;
			}
			if (this._sound_size == size) {
				return;
			}

			this._sound_size = size;
			cc.sys.localStorage.setItem('soundSize', this._sound_size);
			if (size == 0) {
				cc.audioEngine.pause(this._current);
			} else {
				if (Number(this._current) == 0) {
					if (this._curbgm != "") {
						this.playBGM(this._curbgm);
					}
				} else {
					cc.audioEngine.resume(this._current);
				}
			}
		},
		getSize: function getSize() {
			return this._sound_size;
		},

		play: function play(url) {
			if (this._sound_size <= 0) {
				return;
			}
			var audioUrl = this.getUrl(url);
			cc.audioEngine.play(audioUrl, false, this._sound_size);
			// cc.audioEngine.playEffect(audioUrl, false, 1)
		},

		playNormalBtnClick: function playNormalBtnClick() {
			this.play("btnClick");
		}
	}
});

module.exports = AMgr;

cc._RFpop();
},{}],"GameLogic":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'cc30dCCje5J/6A644qC7MFM', 'GameLogic');
// Script/GameView/GameLogic.js

'use strict';

var packet = require('Lpackage');
var ErrorCode = require("errorcode");
var msgcode = require('Msgcode');
var TuiBingConfig = require("TuiBingConfig");

cc.Class({
    extends: cc.Component,

    properties: {
        perBankerList: cc.ScrollView,
        itemPreforb: cc.Prefab,
        goldPrefab: cc.Prefab,

        bankerNameLabel: cc.Label,
        bankerGoldLabel: cc.Label,
        bankerTimesLabel: cc.Label,

        noticeLabel: cc.Label,

        betPoolLabel: [cc.Label],

        maJiangList: [cc.Node],
        bgList: [cc.Node],

        btnBeBanker: cc.Button,
        btnUnBanker: cc.Button,
        btnKeepBanker: cc.Button,
        bankerLabel: cc.Label,

        dice: cc.Node,
        // game params
        _banker_id: 0,
        _banker_name: msgcode.TUIBING_NO_BANKER,
        _game_state: 0,
        _banker_times: 0,
        _banker_gold: 0,

        _south_pool: new Array(),
        _sky_pool: new Array(),
        _north_pool: new Array(),

        _select_gold: 0,
        _gold_list: [cc.Integer],
        _can_bet_gold: 0,
        _be_banker_list: [Object],

        _mj_move_key: 1,
        _mj_old_pos: [cc.Vec2],

        _timer: 0,
        MajiangSpriteList: cc.SpriteAtlas,

        _unBankerFlag: false,

        _gmLogic: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._select_gold = 10000;
        var obj = { playerid: 0, gold: 0 };
        this._south_pool.push(obj);
        this._gold_list = [10000, 100000, 1000000, 5000000, 10000000];
        // var btn = this.goldBtnLsit[0];
        // if( btn != null ){
        //     var button = btn.getComponent(cc.Button);
        //     var select_gold = parseInt(btn.node.name) * TuiBingConfig.LessGold;
        //     var max = cc.ll.pMgr.main_role.gold;
        //     if( select_gold <= max){
        //         button.interactable = false;
        //         this._select_gold = select_gold;
        //     }
        // }
        for (var i = 1; i <= 4; i++) {
            var node = cc.find("Canvas/GameBgLayer/MJList/group" + i);
            this._mj_old_pos[i - 1] = node.getPosition();
        }
        this.reSetGame();

        this.scheduleOnce(function () {
            var p = new packet("ReqTuiBingInfo");
            cc.ll.net.send(p.pack());
        }, 0.5);

        var node = cc.find("Canvas/GameBgLayer/TopBg/TimerBg/Timer");
        var timer_label = node.getComponent(cc.Label);

        this.schedule(function () {
            if (this._timer > 0) {
                var str = "";
                if (this._timer >= 10) {
                    str = this._timer.toString();
                } else {
                    str = "0" + this._timer.toString();
                }
                timer_label.string = "00:" + str;
                this._timer--;
            } else {
                timer_label.string = "00:00";
            }
        }, 1);

        var self = this;
        cc.game.on(cc.game.EVENT_HIDE, function () {});
        cc.game.on(cc.game.EVENT_SHOW, function () {
            console.log("game.reSetGame");
            var scenename = cc.director.getScene().name;
            if (scenename != "tuibingview") {
                return;
            }
            self.reSetGame();
        });

        var node = cc.find("Canvas/GameBgLayer/GMLayer");
        if (cc.ll.pMgr.main_role.gmlevel > 0) {
            node.active = true;
            this._gmLogic = node.getComponent("OnGmLayerLoad");
        } else {
            node.active = false;
        }
    },

    reSetGame: function reSetGame() {
        if (this.bgList == null) {
            return;
        }
        for (var i = 0; i < this.bgList.length; i++) {
            var bg = this.bgList[i];
            bg.removeAllChildren();
        }
        var obj = { majiang1: "bg", majiang2: "bg" };
        for (var i = 0; i < this.maJiangList.length; i++) {
            var majiangnode = this.maJiangList[i];
            this.OpenMajiang(majiangnode, obj);
            var pointbg = majiangnode.getChildByName("PointBg");
            pointbg.active = false;
        }
        for (var i = this.betPoolLabel.length - 1; i >= 0; i--) {
            var label = this.betPoolLabel[i];
            label.string = 0;
        }
        this.dice.active = false;
        for (var i = 0; i < this.maJiangList.length; i++) {
            var majiangnode = this.maJiangList[i];
            majiangnode.active = false;
        }
        for (var i = 1; i <= 4; i++) {
            var node = cc.find("Canvas/GameBgLayer/MJList/group" + i);
            node.setPosition(this._mj_old_pos[i - 1]);
            node.active = true;
            node.stopAllActions();
        }

        this.node.stopAllActions();
        this._mj_move_key = 1;
        if (this._gmLogic != null) {
            this._gmLogic.onResetAll();
        }
    },

    initBanker: function initBanker() {
        this._banker_id = 0;
        this._banker_name = 0;
        this.bankerNameLabel.string = msgcode.TUIBING_NO_BANKER;
        this.bankerGoldLabel.string = 0;
        this.bankerTimesLabel.string = "0/" + TuiBingConfig.BankerMaxTimes;

        this.btnBeBanker.node.active = true;
        this.btnUnBanker.node.active = false;
        this._unBankerFlag = false;
        this.bankerLabel.node.active = false;
        this.btnKeepBanker.node.active = false;

        for (var i = this.betPoolLabel.length - 1; i >= 0; i--) {
            var label = this.betPoolLabel[i];
            label.string = 0;
        }
    },

    onQueueChanged: function onQueueChanged(banker, list) {
        if (banker.bankerid != 0) {
            this._banker_id = banker.bankerid;
            this._banker_name = banker.bankername;
            this.bankerNameLabel.string = this._banker_name;
        }

        var node = cc.find("Canvas/GameBgLayer/BankerList/view/content");
        node.removeAllChildren();

        // console.log("id = " + id + ";name = "+ name);
        var find = false;
        for (var i = 0; i < list.length; i++) {
            var info = list[i];
            var item = cc.instantiate(this.itemPreforb);
            var sprite = item.getComponent("PreBankerItem");
            sprite.onChangeName(1, info.playerid, info.playername, info.type);
            item.x = 0;
            item.y = -i * 40;
            node.addChild(item);
            if (info.playerid == cc.ll.pMgr.main_role.id) {
                find = true;
            }
        }

        node.height = list.length * 40;

        var leavebtn = cc.find("Canvas/GameBgLayer/LeaveQueueBtn");
        leavebtn.active = find;
        this._be_banker_list = list;
    },

    onGameStateChange: function onGameStateChange(state) {
        this._game_state = state;

        switch (state) {
            case TuiBingConfig.State.Stop:
                {
                    this.reSetGame();
                    this.initBanker();
                    // cc.ll.msgbox.addMsg(msgcode.TUIBING_STATE_STOP);
                    this.noticeLabel.string = msgcode.TUIBING_STATE_STOP;
                    this._timer = 0;
                }break;
            case TuiBingConfig.State.Begin:
                {};
            case TuiBingConfig.State.Begin_Check_Begin:
                {
                    this.reSetGame();
                    this._timer = TuiBingConfig.Time.Begin;
                    this.noticeLabel.string = msgcode.TUIBING_STATE_BEGIN;
                }break;
            case TuiBingConfig.State.Begin_Check_Keep:
                {
                    // cc.ll.msgbox.addMsg(msgcode.TUIBING_STATE_BEGIN);
                    this.noticeLabel.string = msgcode.TUIBING_STATE_BEGIN;
                    this._timer = TuiBingConfig.Time.Begin_keep;
                }break;
            case TuiBingConfig.State.Ready:
                {
                    this.noticeLabel.string = msgcode.TUIBING_STATE_READY;
                    this._timer = TuiBingConfig.Time.Bet;
                    if (this._gmLogic != null) {
                        this._gmLogic.onEnableAll();
                    }
                }break;
            case TuiBingConfig.State.WaitOpen:
                {
                    // cc.ll.msgbox.addMsg(msgcode.TUIBING_STATE_WAITOPEN);
                    this.noticeLabel.string = msgcode.TUIBING_STATE_WAITOPEN;
                    this._timer = TuiBingConfig.Time.Wait;
                }break;
            case TuiBingConfig.State.Openning:
                {
                    // cc.ll.msgbox.addMsg(msgcode.TUIBING_STATE_OPENNING);
                    this.noticeLabel.string = msgcode.TUIBING_STATE_OPENNING;
                    this._timer = TuiBingConfig.Time.Open;
                    if (this._gmLogic != null) {
                        this._gmLogic.onUnableAll();
                    }
                }break;
            case TuiBingConfig.State.Reward:
                {
                    // cc.ll.msgbox.addMsg(msgcode.TUIBING_STATE_REWARD);
                    this.noticeLabel.string = msgcode.TUIBING_STATE_REWARD;
                    this._timer = TuiBingConfig.Time.Reward;
                }break;
        }
    },

    onPlayerBet: function onPlayerBet(id, pos, gold) {
        var bgstr = "";
        if (pos == 1) {
            bgstr = "Canvas/GameBgLayer/GameBg/SouthBg";
        } else if (pos == 2) {
            bgstr = "Canvas/GameBgLayer/GameBg/SkyBg";
        } else if (pos == 3) {
            bgstr = "Canvas/GameBgLayer/GameBg/NorthBg";
        }
        if (bgstr.length <= 5) {
            return;
        }
        var num = 0;
        if (gold < 100000) {
            num = 1;
        } else if (gold >= 100000 && gold < 1000000) {
            num = 2;
        } else if (gold >= 1000000) {
            num = 3;
        }
        var node = cc.find(bgstr);
        var beginpos = cc.Vec2.ZERO;
        if (id == cc.ll.pMgr.main_role.id) {
            var bnode = cc.find("Canvas/GameBgLayer/ButtumBg/goldflag");
            var world_pos = bnode.convertToWorldSpace(cc.Vec2.ZERO);
            var pos = node.convertToNodeSpace(world_pos);
            beginpos = pos;
        }

        for (var i = 0; i < num; i++) {
            var x = Math.round(Math.random() * node.width) - node.width / 2;
            x = x > 0 ? x - 30 : x + 30;
            var y = Math.round(Math.random() * node.height) - node.height / 2;
            y = y > 0 ? y - 30 : y + 30;
            var gold = cc.instantiate(this.goldPrefab);
            if (beginpos.x != 0) {
                gold.x = beginpos.x;
                gold.y = beginpos.y;
            } else {
                gold.x = x;
                gold.y = y;
            }
            node.addChild(gold);
            var action = cc.moveTo(0.5, cc.p(x, y));
            gold.runAction(action.easing(cc.easeOut(3.0)));
        }
        cc.ll.sAudioMgr.play("dropGold");
    },

    selectGoldBtn: function selectGoldBtn(key) {
        for (var i = 1; i <= 5; i++) {
            var node = cc.find("Canvas/GameBgLayer/ButtumBg/toggleGroup/toggle" + i);
            var toggle = node.getComponent(cc.Toggle);
            if (i == key) {
                toggle.isChecked = true;
            } else {
                toggle.isChecked = false;
            }
        }
    },

    onAutoSelectGold: function onAutoSelectGold() {
        var max = cc.ll.pMgr.main_role.gold;
        var num = 0;
        for (var i = this._gold_list.length - 1; i >= 0; i--) {
            var select_gold = this._gold_list[i];
            if (select_gold <= this._can_bet_gold) {
                if (select_gold <= max) {
                    num = i + 1;
                    break;
                }
            }
        }

        if (num == 0) {
            this.selectGoldBtn(1);
            this._select_gold = this._gold_list[0];
        } else {
            this.selectGoldBtn(num);
            this._select_gold = this._gold_list[num - 1];
        }
    },

    onBetGold: function onBetGold(event, pos) {
        if (this._game_state != TuiBingConfig.State.Ready) {
            return;
        }
        var maxgold = cc.ll.pMgr.main_role.gold;
        if (maxgold < TuiBingConfig.LessGold) {
            cc.ll.msgbox.addMsg(msgcode.GOLD_NOT_ENOUGH);
            return;
        }

        if (this._select_gold == 0) {
            cc.ll.msgbox.addMsg(msgcode.TUIBING_SELECT_GOLD);
            return;
        }

        if (this._select_gold > maxgold) {
            this.onAutoSelectGold();
            if (this._select_gold > maxgold) {
                cc.ll.msgbox.addMsg(msgcode.GOLD_NOT_ENOUGH);
                return;
            }
        }

        if (this._select_gold > this._can_bet_gold) {
            this.onAutoSelectGold();
            if (this._select_gold > this._can_bet_gold) {
                cc.ll.msgbox.addMsg(msgcode.TUIBING_MORETHAN_BANKER);
                return;
            }
        }

        var p = new packet("ReqTuiBingBet");
        p.lpack.pos = parseInt(pos);
        p.lpack.gold = this._select_gold;
        cc.ll.net.send(p.pack());
    },

    onSelectGoldClick: function onSelectGoldClick(event, gold) {
        var max = cc.ll.pMgr.main_role.gold;
        var select_gold = parseInt(gold);
        if (select_gold > max) {
            this.onAutoSelectGold();
            return;
        }

        // for (var i = 0; i < this.goldBtnLsit.length; i++) {
        //     var btn = this.goldBtnLsit[i];
        //     var button = btn.getComponent(cc.Button);
        //     button.interactable = btn.node.name != node.name;
        // }
        this._select_gold = select_gold;
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onBetGoldCount: function onBetGoldCount(goldlist) {
        var gold = 0;
        for (var i = 0; i < this.betPoolLabel.length; i++) {
            var label = this.betPoolLabel[i];
            var g = goldlist[i];
            label.string = g;
            gold += g;
        }

        this._can_bet_gold = this._banker_gold - gold;
    },
    DealMajiangPos: function DealMajiangPos(node, key) {
        var to_node_str = "";
        switch (key) {
            case 1:
                to_node_str = "Canvas/GameBgLayer/TopBg/DizhuMajiangBg";break;
            case 2:
                to_node_str = "Canvas/GameBgLayer/GameBg/SouthMajiangBg";break;
            case 3:
                to_node_str = "Canvas/GameBgLayer/GameBg/SkyMajiangBg";break;
            case 4:
                to_node_str = "Canvas/GameBgLayer/GameBg/NorthMajiangBg";break;
        };
        var to_node = cc.find(to_node_str);
        var world_topos = to_node.convertToWorldSpace(cc.Vec2.ZERO);
        var node_topos = node.parent.convertToNodeSpace(world_topos);
        this._mj_move_key++;
        return node_topos;
    },
    OpenMajiang: function OpenMajiang(node, obj) {
        var self = this;
        var changesprite = function changesprite(sprite_node, sprite_name) {
            var sprite = sprite_node.getComponent(cc.Sprite);
            var frame = self.MajiangSpriteList.getSpriteFrame(sprite_name);
            sprite.spriteFrame = frame;
        };
        var majiang1 = node.getChildByName("Majiang1");
        var majiang2 = node.getChildByName("Majiang2");
        var pointbg = node.getChildByName("PointBg");

        var namespr = "img_majiang_" + obj.majiang1;
        changesprite(majiang1, namespr);
        namespr = "img_majiang_" + obj.majiang2;
        changesprite(majiang2, namespr);
        if (obj.majiang1 == "bg") {
            return;
        }
        var numspr = pointbg.getChildByName("NumSpr");

        if (obj.majiang1 == obj.majiang2) {
            namespr = "img_double_num";
        } else {
            var num = (obj.majiang1 + obj.majiang2) % 10;
            namespr = "img_" + num + "point_num";
        }
        changesprite(numspr, namespr);
        function shownum() {
            pointbg.active = true;
        }
        node.runAction(cc.sequence(cc.delayTime(0.5), cc.callFunc(shownum)));
    },

    // majiangs 0 banker 1 south 2 sky 3 north {majiang1 majiang2}
    onOpenMajiang: function onOpenMajiang(majiangs, dicenum1, dicenum2) {
        // 先撒骰子
        var random_1 = dicenum1; //Math.ceil(Math.random()*5 + 1);
        var random_2 = dicenum2; //Math.ceil(Math.random()*5 + 1);

        this.dice.active = true;
        var action = this.dice.getComponent(cc.Animation);
        var majianglist = this.maJiangList;
        var self = this;
        var dice1 = cc.find("/Canvas/GameBgLayer/Dice1");
        var dice2 = cc.find("/Canvas/GameBgLayer/Dice2");
        var key = (random_1 + random_2 - 1) % 4 + 1; // 1~4
        var list = [];
        for (var i = 0; i <= 3; i++) {
            list[i] = key + i > 4 ? key + i - 4 : key + i;
        }
        var diceact = function diceact() {
            action.play();
            cc.ll.sAudioMgr.play("touzi");
        };

        var stopact = function stopact() {
            action.stop();
            self.dice.active = false;
            var showdice = function showdice(sprite_node, sprite_name) {
                var sprite = sprite_node.getComponent(cc.Sprite);
                var frame = self.MajiangSpriteList.getSpriteFrame(sprite_name);
                sprite.spriteFrame = frame;
                sprite_node.active = true;
            };
            showdice(dice1, "img_dice_" + random_1);
            showdice(dice2, "img_dice_" + random_2);
        };
        var hidedice = function hidedice() {
            dice1.active = false;
            dice2.active = false;
        };
        var move = function move() {
            var id = 0;
            var nodemoveto = function nodemoveto() {
                if (id > 3 || id < 0) {
                    return;
                }
                var mj_key = list[id];
                var node = cc.find("Canvas/GameBgLayer/MJList/group" + self._mj_move_key);
                if (node == null) {
                    return;
                }
                var pos = self.DealMajiangPos(node, mj_key);
                function showmj() {
                    var majiangnode = self.maJiangList[mj_key - 1];
                    majiangnode.active = true;
                }
                function hidegroup() {
                    node.active = false;
                }
                node.runAction(cc.sequence(cc.moveTo(0.5, pos), cc.callFunc(hidegroup), cc.callFunc(showmj)));
                id++;
            };
            var queue = [];
            queue.push(cc.callFunc(nodemoveto), cc.delayTime(0.5), cc.callFunc(nodemoveto), cc.delayTime(0.5), cc.callFunc(nodemoveto), cc.delayTime(0.5), cc.callFunc(nodemoveto), cc.delayTime(0.5));
            self.node.runAction(cc.sequence(queue));
        };
        var open = function open(id) {
            var node = majianglist[id];
            var nums = majiangs[id];
            self.OpenMajiang(node, nums);
        };
        var open1 = function open1() {
            open(0);
        };
        var open2 = function open2() {
            open(1);
        };
        var open3 = function open3() {
            open(2);
        };
        var open4 = function open4() {
            open(3);
        };

        var queue = [];
        queue.push(cc.callFunc(diceact), //1 dice action begin 
        cc.delayTime(1.5), cc.callFunc(stopact), //2 dice action stop, show finaly number
        cc.delayTime(1), cc.callFunc(hidedice), //3 hide dice
        cc.delayTime(0.5), cc.callFunc(move), //move majiang
        cc.delayTime(2.5), cc.callFunc(open1), // open majiang one by one
        cc.delayTime(1), cc.callFunc(open2), cc.delayTime(1), cc.callFunc(open3), cc.delayTime(1), cc.callFunc(open4));
        var act = cc.sequence(queue);
        this.node.runAction(act);
    },

    onBankerInfo: function onBankerInfo(obj) {
        if (obj.id == 0) {
            this.initBanker();
            return;
        }
        this._banker_id = obj.id;
        this._banker_name = obj.name;
        this._banker_times = obj.times;
        this._banker_gold = obj.gold;
        this.bankerNameLabel.string = obj.name;
        this.bankerGoldLabel.string = obj.gold;
        this.bankerTimesLabel.string = obj.times + "/" + TuiBingConfig.BankerMaxTimes;

        if (cc.ll.pMgr.main_role.id == this._banker_id) {
            if (this._unBankerFlag) {
                this.bankerLabel.node.active = true;
                this.btnBeBanker.node.active = false;
                this.btnUnBanker.node.active = false;
                this.btnKeepBanker.node.active = false;
            } else {
                this.bankerLabel.node.active = false;
                this.btnBeBanker.node.active = false;
                this.btnUnBanker.node.active = true;
                this.btnKeepBanker.node.active = true;
            }
        } else {
            this.btnBeBanker.node.active = true;
            this.btnUnBanker.node.active = false;
            this.btnKeepBanker.node.active = false;
            this._unBankerFlag = false;
            this.bankerLabel.node.active = false;
        }
        this._can_bet_gold = this._banker_gold;
    },
    testAddGold: function testAddGold() {
        var self = this;
        function addgold(str) {
            var node = cc.find(str);
            var num = Math.ceil(Math.round(Math.random() * 10) + 1);
            for (var i = 0; i < num; i++) {
                var x = Math.round(Math.random() * node.width) - node.width / 2;
                x = x > 0 ? x - 30 : x + 30;
                var y = Math.round(Math.random() * node.height) - node.height / 2;
                y = y > 0 ? y - 30 : y + 30;
                var gold = cc.instantiate(self.goldPrefab);
                gold.x = x;
                gold.y = y;
                node.addChild(gold);
            }
        }
        var list = ["Canvas/GameBgLayer/GameBg/SouthBg", "Canvas/GameBgLayer/GameBg/SkyBg", "Canvas/GameBgLayer/GameBg/NorthBg"];
        for (var i = 0; i < list.length; i++) {
            addgold(list[i]);
        }
    },
    testSendReward: function testSendReward() {
        var list = [0, 1, 0];
        var gold = 10;
        this.onSendReward(list, gold);
    },
    onSendReward: function onSendReward(list, goldlist) {
        var bankernode = cc.find("Canvas/GameBgLayer/TopBg/DizhuGold");
        var bankerpos = bankernode.convertToWorldSpace(cc.Vec2.ZERO);
        var playernode = cc.find("Canvas/GameBgLayer/ButtumBg/goldflag");
        var playerpos = playernode.convertToWorldSpace(cc.Vec2.ZERO);
        var dazhongnode = cc.find("Canvas/GameBgLayer/AllPlayerBtn");
        var dazhongpos = dazhongnode.convertToWorldSpace(cc.Vec2.ZERO);
        // topos 0 banker 1 souch 2 sky 3 north 4 player
        function movegold(node, topos, delay) {
            var endpos = cc.p(0, 0);
            if (topos == 4) {
                endpos = node.parent.convertToNodeSpace(playerpos);
            } else if (topos == 5) {
                endpos = node.parent.convertToNodeSpace(dazhongpos);
            } else {
                endpos = node.parent.convertToNodeSpace(bankerpos);
            }
            var d = delay || 0;
            var action = cc.moveTo(0.5, endpos);
            function removenode() {
                node.removeFromParent();
            }
            node.runAction(cc.sequence(cc.delayTime(d), action.easing(cc.easeOut(3.0)), cc.callFunc(removenode)));
            cc.ll.sAudioMgr.play("dropCoin");
        }
        // first banker win
        var self = this;
        var bankerwin = function bankerwin() {
            for (var i = 0; i < list.length; i++) {
                var iswin = list[i];
                var bg = self.bgList[i];
                var children = bg.children;
                if (iswin == 0) {
                    //banker win
                    for (var k = children.length - 1; k >= 0; k--) {
                        movegold(children[k], 0);
                    }
                }
            }
        };
        var banekerlose = function banekerlose() {
            for (var i = 0; i < list.length; i++) {
                var iswin = list[i];
                var bg = self.bgList[i];
                var children = bg.children;
                if (iswin != 0) {
                    //banker win
                    var beginpos = bg.convertToNodeSpace(bankerpos);
                    var num = children.length;
                    for (var k = 0; k < num; ++k) {
                        var x = Math.round(Math.random() * bg.width) - bg.width / 2;
                        x = x > 0 ? x - 30 : x + 30;
                        var y = Math.round(Math.random() * bg.height) - bg.height / 2;
                        y = y > 0 ? y - 30 : y + 30;
                        var gold = cc.instantiate(self.goldPrefab);
                        gold.x = beginpos.x;
                        gold.y = beginpos.y;
                        bg.addChild(gold);
                        var action = cc.moveTo(0.5, cc.p(x, y));
                        gold.runAction(action.easing(cc.easeOut(3.0)));
                    }
                    if (num > 0) {
                        cc.ll.sAudioMgr.play("dropCoin");
                    }
                }
            }
        };
        var playerwin = function playerwin() {
            for (var i = 0; i < list.length; i++) {
                var iswin = list[i];
                var bg = self.bgList[i];
                var children = bg.children;
                var num = Math.ceil(children.length / 2);
                if (iswin != 0) {
                    //player win
                    if (goldlist[i] <= 0) {
                        num = -1;
                    }
                    for (var k = 0; k < children.length; ++k) {
                        if (k <= num) {
                            movegold(children[k], 4);
                        } else {
                            movegold(children[k], 5, 0.5);
                        }
                    }
                }
            }
        };
        this.node.runAction(cc.sequence(cc.callFunc(bankerwin), cc.delayTime(0.8), cc.callFunc(banekerlose), cc.delayTime(0.8), cc.callFunc(playerwin)));
    },

    canBeBanker: function canBeBanker() {
        if (cc.ll.pMgr.main_role.id == this._banker_id) {
            return ErrorCode.UR_BANKER;
        }
        for (var i = 0; i < this._be_banker_list.length; i++) {
            var info = this._be_banker_list[i];
            if (cc.ll.pMgr.main_role.id == info.playerid) {
                return ErrorCode.HAS_IN_QUEUE;
            }
        }
        return 0;
    },

    onShowAllPlayer: function onShowAllPlayer(list) {
        var node = cc.find("Canvas/GameBgLayer/AllPlayerList/pview/pcontent");
        node.removeAllChildren();
        for (var i = 0; i < list.length; i++) {
            var info = list[i];
            var item = cc.instantiate(this.itemPreforb);
            var sprite = item.getComponent("PreBankerItem");
            sprite.onChangeName(2, info.id, info.name, 1);
            item.x = 0;
            item.y = -i * 40;
            node.addChild(item);
        }
        node.height = list.length * 40;
        var node = cc.find("Canvas/GameBgLayer/AllPlayerList/detail");
        node.active = false;
    },

    onShowPlayerDetail: function onShowPlayerDetail(from, id, name) {
        if (from == 2) {
            var detail = cc.find("Canvas/GameBgLayer/AllPlayerList/detail");
            if (detail.active == false) {
                detail.active = true;
            }
            var idnode = detail.getChildByName("ID");
            var idlabel = idnode.getComponent(cc.Label);
            if (idlabel.string == id) {
                idlabel.string = 0;
                detail.active = false;
                return;
            }
            idlabel.string = id;

            var namenode = detail.getChildByName("Name");
            var namelabel = namenode.getComponent(cc.Label);
            namelabel.string = name;
        }
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","Msgcode":"Msgcode","TuiBingConfig":"TuiBingConfig","errorcode":"errorcode"}],"HelloWorld":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1bb9etXHwpK3I4msK6MLL5h', 'HelloWorld');
// Script/HelloWorld.js

'use strict';

cc.Class({
    extends: cc.Component,

    properties: {
        label: {
            default: null,
            type: cc.Label
        },
        // defaults, set visually when attaching this script to the Canvas
        text: 'Hello, World!'
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.label.string = this.text;
    },

    // called every frame
    update: function update(dt) {}
});

cc._RFpop();
},{}],"LLEvent":[function(require,module,exports){
"use strict";
cc._RFpush(module, '56f09ROygxJqLxgz+SE3ZC8', 'LLEvent');
// Script/Common/LLEvent.js

"use strict";

var LLEvent = cc.Class({
    // extends: cc.Component,
    properties: {},
    statics: {
        Index: 1000,
        RegIndex: 1000,
        EventQueue: new Object(),
        RegQueue: new Object(),

        addEvent: function addEvent(func) {
            if (func == null || typeof func != "function") {
                return 0;
            }
            this.Index++;
            this.EventQueue[this.Index] = func;
            return this.Index;
        },

        delEvent: function delEvent(id) {
            this.EventQueue[id] = null;
        },

        dispatchEvent: function dispatchEvent(id, obj) {
            var func = this.EventQueue[id];
            if (typeof func == "function") {
                func(obj);
            }
        },

        register: function register(key, node, func) {
            if (func == null || typeof func != "function") {
                return;
            }
            if (this.RegQueue[key] == null) {
                this.RegQueue[key] = {};
            }
            this.RegQueue[key][this.RegIndex] = func;
            return this.RegIndex;
        },
        unregister: function unregister(key, node) {
            this.RegQueue[key][node] = null;
        },

        dispatchRegister: function dispatchRegister(key) {}
    }
});

module.exports = LLEvent;

cc._RFpop();
},{}],"LoadingDialog":[function(require,module,exports){
"use strict";
cc._RFpush(module, '6c7dbQ5qD1ORosXmSvTlWRc', 'LoadingDialog');
// Script/Common/LoadingDialog.js

"use strict";

var LOADING_DIALOG_TAG = 909876;

var Loading = cc.Class({
	statics: {
		pfab: null,
		isInit: false,
		init: function init() {
			var self = this;
			cc.loader.loadRes("profab/LoadingLayer", function (err, prefab) {
				self.pfab = prefab;
				self.isInit = true;
			});
		},

		addLoading: function addLoading(t) {
			if (this.isInit) {
				var node = cc.instantiate(this.pfab);
				var act = node.getComponent(cc.Animation);
				act.play();
				cc.director.getScene().addChild(node, 999, LOADING_DIALOG_TAG);
				if (t == null) {
					t = 10;
				}
				var self = this;
				setTimeout(function () {
					self.removeLoading();
				}, t * 1000);
			}
		},
		removeLoading: function removeLoading() {
			var node = cc.director.getScene().getChildByTag(LOADING_DIALOG_TAG);
			if (node != null) {
				cc.director.getScene().removeChildByTag(LOADING_DIALOG_TAG);
			}
		}
	}
});

module.exports = Loading;

cc._RFpop();
},{}],"Lpackage":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5d2612VeZxAIqShRzv/9VJH', 'Lpackage');
// Script/NetWork/Lpackage.js

"use strict";

//Lpackage.js
var ByteBuffer = require("bytebuffer");
var Lpackage = cc.Class({
	// extends: cc.Component,
	name: "Lpackage",
	properties: {
		_head: "",
		_thead: "",
		_builder: null
	},
	statics: {
		lpack: null,
		msg: null
	},
	ctor: function ctor() {
		var head = arguments[0];
		this._head = head;
		this._thead = "tutorial." + head;
		this._builder = cc.ll.pb.build(this._thead);
		this.lpack = new this._builder();
	},

	pack: function pack() {
		var ret = new ByteBuffer();
		ret.writeShort(this._head.length);
		ret.writeString(this._head);
		ret.append(this.lpack.encode());
		ret.flip();
		return ret.toBuffer();
	},

	unpack: function unpack(buffer) {
		if (buffer !== null) {
			this.msg = this._builder.decode(buffer);
		}
		return this.msg;
	}
});
module.exports = Lpackage;

cc._RFpop();
},{"bytebuffer":"bytebuffer"}],"Lscrollview":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e1e93HxdetNXby4xKPdJnW/', 'Lscrollview');
// Script/Lcomponent/Lscrollview.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RFpop();
},{}],"Lwebsocket":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'cb6ab9nArdCUaWG5MY8yUje', 'Lwebsocket');
// Script/NetWork/Lwebsocket.js

"use strict";

var ByteBuffer = require("bytebuffer");

var SocketState = {
    UnInit: 0,
    Linking: 1,
    Linked: 2,
    Close: 3
};

var lwebsocket = cc.Class({
    // extends: cc.Component,
    name: "lwebsocket",
    statics: {
        ip: "",
        port: 0,
        reader: null,
        socket: null,
        state: SocketState.UnInit,
        msgdispatch: null,
        queue: null,
        working: false,

        init: function init() {
            var self = this;
            this.reader = new FileReader();
            this.reader.addEventListener("loadend", function () {
                var data = this.result;
                var buffer = new ByteBuffer();
                buffer.append(data);
                buffer.flip();
                var len = buffer.readShort();
                var head = buffer.readString(len);
                console.log("response text msg: " + head);
                self.msgdispatch.dispatch(head, buffer.toBuffer());
                // self.working = false;
                self.domessage();
            });
            this.reader.addEventListener("onerror", function () {
                // self.working = false;
                self.domessage();
            });

            this.queue = new Array();
            this.msgdispatch = require("msgdispatch");
        },
        domessage: function domessage() {
            if (this.reader.readyState != 1) {
                if (this.queue.length > 0) {
                    var data = this.queue.shift();
                    this.reader.readAsArrayBuffer(data);
                }
            }
        },
        connect: function connect(ip, port, fnConnect, fnError) {
            var self = this;
            this.ip = ip;
            this.port = port;
            var ws = new WebSocket('ws://' + this.ip + ':' + this.port + '/ws');
            ws.onopen = function (event) {
                console.log("Send Text WS was opened.");
                self.state = SocketState.Linked;
                if (fnConnect) {
                    fnConnect();
                }
            };
            ws.onmessage = function (event) {
                // console.log("response text msg: " + event.data);
                self.queue.push(event.data);
                if (self.queue.length > 0) {
                    self.domessage();
                }
            };
            ws.onerror = function (event) {
                console.log("Send Text fired an error");
                self.state = SocketState.Close;
            };
            ws.onclose = function (event) {
                console.log("WebSocket instance closed.");
                self.state = SocketState.Close;
                if (fnError) {
                    fnError();
                }
            };
            this.socket = ws;
        },
        send: function send(buffer) {
            this.socket.send(buffer);
        }
    }
});

module.exports = lwebsocket;

cc._RFpop();
},{"bytebuffer":"bytebuffer","msgdispatch":"msgdispatch"}],"Msgbox":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f668aqN0XFNcoRV0CXXtwjr', 'Msgbox');
// Script/Common/Msgbox.js

"use strict";

var msgcode = require('Msgcode');

var Msgbox = cc.Class({
    // extends: cc.Component,
    properties: {},
    statics: {
        bg: null,
        addMsg: function addMsg(msg) {
            if (this.bg === null) {
                this.bg = cc.find("MsgBoxLayer");
                cc.game.addPersistRootNode(this.bg);
                if (this.bg === null) {
                    return;
                }
            }
            if (typeof msg == "number") {
                msg = msgcode[msg];
            }
            var msgnode = new cc.Node();
            msgnode.color = cc.color(0, 255, 68, 255);
            var msglabel = msgnode.addComponent(cc.Label);
            msglabel.string = msg;
            msglabel.fontSize = 20;
            msgnode.setPosition(0, -50);
            msgnode.parent = this.bg;
            var dellabel = function dellabel() {
                msgnode.destroy();
            };
            var act1 = cc.moveBy(1, cc.p(0, 100));
            var act21 = cc.delayTime(0.5);
            var act22 = cc.fadeOut(0.5);
            var act23 = cc.callFunc(dellabel);
            var act2 = cc.sequence(act21, act22, act23);

            msgnode.runAction(act1);
            msgnode.runAction(act2);
        }
    }
});
module.exports = Msgbox;

cc._RFpop();
},{"Msgcode":"Msgcode"}],"Msgcode":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ff910ybdZ1EV42X+d8fOsRU', 'Msgcode');
// Script/Etc/Msgcode.js

"use strict";

var ErrorCode = require("errorcode");

var msgcode = {};
msgcode[ErrorCode.ACCOUNT_REPEAT] = "账号重复", msgcode[ErrorCode.DBSERVICE_ERROR] = "数据错误", msgcode[ErrorCode.NO_ACCOUNT] = "账号不存在", msgcode[ErrorCode.PASSWORD_ERROR] = "密码错误", msgcode[ErrorCode.HAS_ONLINE] = "已经在线，请稍后重试", msgcode[ErrorCode.ACCOUNT_SEAL] = "账号被禁用，解禁日期为<br/><color=#FF0000><size = 25>", msgcode[ErrorCode.ROOM_NOT_FOUND] = "未找到该房间", msgcode[ErrorCode.ROOM_FULL] = "房间已满", msgcode[ErrorCode.GOLD_NOT_ENOUGH] = "金币不足", msgcode[ErrorCode.BANKER_NO_BET] = "庄家不能下注", msgcode[ErrorCode.NOT_IN_QUEUE] = "不在上庄队列中", msgcode[ErrorCode.NOT_BANKER] = "你不是庄家", msgcode[ErrorCode.UR_BANKER] = "你已经是庄家", msgcode[ErrorCode.HAS_IN_QUEUE] = "你已经在队列", msgcode[ErrorCode.TUIBING_ROOMCLOSE] = "房间已关闭", msgcode[ErrorCode.PERMISSION_DENIED] = "权限不足", msgcode[ErrorCode.LOGTYPE_ERROR] = "日志类型错误", msgcode[ErrorCode.NO_USER_ID] = "用户ID不存在", msgcode[ErrorCode.NOT_ONLINE] = "用户不在线，无法操作",

// 账号状态
msgcode.ACCOUNT_TOO_LONG = "账号或密码长度错误，请输入6~12位字符", msgcode.PASSWORD_NOT_SAME = "两次输入的密码不相同", msgcode.ACCOUNT_PHONE_ERROR = "请输入正确的手机号", msgcode.NETWORK_RELINK = "网络已断开，点击重连", msgcode.NETWORK_RELOGIN = "网络已断开，请重新登录", msgcode.NETWORK_UNCONNECT = "无法连接到服务器", msgcode.NETWORK_OTHER_LOGIN = "账号在其他地方登陆", msgcode.GOLD_NOT_ENOUGH = "金币不足",
//推饼 状态
msgcode.TUIBING_NO_BANKER = "暂无庄家";
msgcode.TUIBING_STATE_STOP = "暂无庄家，等待玩家上庄", msgcode.TUIBING_STATE_BEGIN = "休息一下，游戏马上开始", msgcode.TUIBING_STATE_READY = "可以下注了，快投注吧", msgcode.TUIBING_STATE_WAITOPEN = "下注结束 等待开牌", msgcode.TUIBING_STATE_OPENNING = "正在开牌", msgcode.TUIBING_STATE_REWARD = "发送奖励",

//推饼提示
msgcode.TUIBING_SELECT_GOLD = "请先选择金币", msgcode.TUIBING_MORETHAN_BANKER = "已超过押注上限", msgcode.TUIBING_GOLD_NOT_ENOUGH = "金币不足以快速上庄", msgcode.TUIBING_GOLD_BANKER_LESS = "金币低于最低上庄需求", msgcode.TUIBING_GOLD_BANKER_NOT_ENOUGH = "金币不足", msgcode.TUIBING_KEEP_BANKER = "是否继续坐庄？", msgcode.TUIBING_BANKER_BEGIN = "要开始游戏么？", msgcode.TUIBING_BANKER_TYPE = "<color=#FFFFFF>要快速上庄么？</c><br/><color=#FFAD00><size = 20>（快速上庄需要20万金币）</color></size>", msgcode.TUIBING_ASK_UNBANKER = "确认下庄么？<br/><color=#FF0000><size = 25>下庄后需要重新排队上庄</color></size>", msgcode.GM_CALL_GM = "请联系GM", msgcode.GM_PAYMENT_OK = "充值成功", msgcode.COMMON_ERROR_ID = "请输入正确的玩家id", msgcode.COMMON_ERROR_GOLD = "请输入正确的金币数", msgcode.COMMON_ERROR_USER = "无法查询到该玩家", msgcode.TRANSTFER_SUBMIT_1 = "收款人:<color=#FF0000>", msgcode.TRANSTFER_SUBMIT_2 = "</color><br/>收款金额:<color=#FF0000>", msgcode.TRANSTFER_SUBMIT_3 = "</color><size = 29><br/><br/><color=#FFFFFF>确认转账么？</size></color>", msgcode.TRANSTFER_NOTICE_1 = "收到来自<color=#00FF00>", msgcode.TRANSTFER_NOTICE_2 = "</color>的<color=#FF0000>", msgcode.TRANSTFER_NOTICE_3 = "金币</color>", msgcode.TRANSTFER_COMPLETE = "交易完成", msgcode.TRANSTFER_ERROR_GOLD = "转账至少要500000金币", msgcode.END_COLOR = "</color>", msgcode.END_SIZE = "</size>", module.exports = msgcode;

cc._RFpop();
},{"errorcode":"errorcode"}],"Notice":[function(require,module,exports){
"use strict";
cc._RFpush(module, '331a22gVARKWYGscLvHwvE5', 'Notice');
// Script/Common/Notice.js

"use strict";

var msgcode = require('Msgcode');

var NoticeBox = cc.Class({
    // extends: cc.Component,
    properties: {},
    statics: {
        pfab: null,
        init: function init() {
            var self = this;
            cc.loader.loadRes("profab/Notice", function (err, prefab) {
                self.pfab = prefab;
            });
        },
        addMsg: function addMsg(type, msg, okfunc, cancelfunc, tag) {
            var node = cc.instantiate(this.pfab);

            var msgnode = node.getChildByName("NoticeBg").getChildByName("NoticeLabel");
            var msglabel = msgnode.getComponent(cc.RichText);

            if (typeof msg == "number") {
                msg = msgcode[msg];
            }

            msglabel.string = msg;

            var onDestroy = function onDestroy() {
                node.destroy();
            };

            var okbtn = node.getChildByName("NoticeBg").getChildByName("OkBtn");
            var okcallback = function okcallback() {
                if (okfunc != null) {
                    okfunc();
                }
                cc.ll.sAudioMgr.playNormalBtnClick();
                onDestroy();
            };
            okbtn.on('click', okcallback);

            var cancelbtn = node.getChildByName("NoticeBg").getChildByName("CancelBtn");
            var cancelcallback = function cancelcallback() {
                if (cancelfunc != null) {
                    cancelfunc();
                }
                cc.ll.sAudioMgr.playNormalBtnClick();
                onDestroy();
            };
            cancelbtn.on('click', cancelcallback);

            if (type == 2) {
                cancelbtn.active = false;
                okbtn.x = 0;
            }
            cc.director.getScene().addChild(node, 99, tag);

            node.setTimeOut = function (t) {
                node.runAction(cc.sequence(cc.delayTime(t), cc.callFunc(onDestroy)));
            };
            return node;
        },

        removeMsg: function removeMsg(tag) {
            cc.director.getScene().removeChildByTag(tag);
        }
    }
});
module.exports = NoticeBox;

cc._RFpop();
},{"Msgcode":"Msgcode"}],"OnBankerLayerLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a1815J9d4lN/49lIsm/PHBp', 'OnBankerLayerLoad');
// Script/GameView/OnBankerLayerLoad.js

"use strict";

var TuiBingConfig = require("TuiBingConfig");
var packet = require('Lpackage');

cc.Class({
    extends: cc.Component,

    properties: {
        bar: cc.ProgressBar,
        input: cc.EditBox,
        checkbox: cc.Toggle,
        fasttips: cc.Label,

        _is_keep: false
    },

    // use this for initialization
    onLoad: function onLoad() {},

    initKeep: function initKeep() {
        this.checkbox.interactable = false;
        this.fasttips.node.color = new cc.Color(140, 140, 140);
        this._is_keep = true;
        var self = this;
        var closefunc = function closefunc() {
            self.onDistroy();
        };
        this.node.runAction(cc.sequence(cc.delayTime(TuiBingConfig.Time.Begin_keep), cc.callFunc(closefunc)));
    },

    onSlideChanged: function onSlideChanged(slider, customEventData) {
        var size = slider.progress;
        this.bar.progress = size;

        var maxgold = cc.ll.pMgr.main_role.gold;
        var need = TuiBingConfig.BankerLessGold;
        if (this.checkbox.isChecked) {
            need = TuiBingConfig.BankerLessGold + TuiBingConfig.FastBankerGold;
        }
        var sgold = maxgold - need;

        this.input.string = TuiBingConfig.BankerLessGold + Math.ceil(sgold * size);
    },

    onCheckBoxClicked: function onCheckBoxClicked(toggle, customEventData) {
        if (toggle.isChecked) {
            var maxgold = cc.ll.pMgr.main_role.gold;
            if (maxgold < TuiBingConfig.BankerLessGold + TuiBingConfig.FastBankerGold) {
                toggle.isChecked = false;
                cc.ll.msgbox.addMsg(msgcode.TUIBING_GOLD_NOT_ENOUGH);
            } else {
                var gold = Number(this.input.string);
                var max = maxgold - (TuiBingConfig.BankerLessGold + TuiBingConfig.FastBankerGold);
                if (gold > max) {
                    this.input.string = TuiBingConfig.BankerLessGold + max;
                }
            }
        }
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onOkClicked: function onOkClicked() {
        var bankertype = 1;
        if (this.checkbox.isChecked) {
            bankertype = 2;
        }

        var gold = Number(this.input.string);
        if (gold < TuiBingConfig.BankerLessGold) {
            cc.ll.msgbox.addMsg(msgcode.TUIBING_GOLD_NOT_ENOUGH);
            return;
        }
        var need = gold;
        if (this.checkbox.isChecked) {
            need = TuiBingConfig.BankerLessGold + TuiBingConfig.FastBankerGold;
        }
        var maxgold = cc.ll.pMgr.main_role.gold;
        if (maxgold < need) {
            cc.ll.msgbox.addMsg(msgcode.TUIBING_GOLD_BANKER_NOT_ENOUGH);
            return;
        }

        if (this._is_keep) {
            var p = new packet("ReqKeepBanker");
            p.lpack.iskeep = 0;
            p.lpack.gold = gold;
            cc.ll.net.send(p.pack());
        } else {
            var p = new packet("ReqBeBanker");
            p.lpack.type = bankertype;
            p.lpack.gold = Number(this.input.string);
            cc.ll.net.send(p.pack());
        }

        cc.ll.sAudioMgr.playNormalBtnClick();
        this.onDistroy();
    },
    onCancelClicked: function onCancelClicked() {
        if (this._is_keep) {
            var p = new packet("ReqKeepBanker");
            p.lpack.iskeep = 1;
            p.lpack.gold = 0;
            cc.ll.net.send(p.pack());
        }
        cc.ll.sAudioMgr.playNormalBtnClick();
        this.onDistroy();
    },

    onDistroy: function onDistroy() {
        this.node.destroy();
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","TuiBingConfig":"TuiBingConfig"}],"OnGameViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '251e3MOI7VLeYFwg+vfW3Jz', 'OnGameViewLoad');
// Script/GameView/OnGameViewLoad.js

'use strict';

var packet = require('Lpackage');
var msgcode = require('Msgcode');
var TuiBingConfig = require("TuiBingConfig");

cc.Class({
    extends: cc.Component,

    properties: {
        NameLabel: {
            default: null,
            type: cc.Label
        },
        GoldLabel: {
            default: null,
            type: cc.Label
        },

        BankerBtns: [cc.Button],
        bankerLabel: cc.Label,
        bankerDialog: cc.Prefab,

        _logic: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = cc.find("Canvas").getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }

        if (cc.ll.pMgr.main_role !== null) {
            this.NameLabel.string = cc.ll.pMgr.main_role.name + " [" + cc.ll.pMgr.main_role.id + "]";
            this.GoldLabel.string = cc.ll.pMgr.main_role.gold;
        }

        var node = this.GoldLabel.node;

        cc.ll.pMgr.main_role.register("GoldChange", node, function (event) {
            var gold = event.getUserData();
            var label = node.getComponent(cc.Label);
            label.string = gold;
        });
        var event = require("LLEvent");
        event;

        this._logic = this.node.getComponent("GameLogic");
        cc.ll.sAudioMgr.playBGM("bgBet");
        cc.ll.loading.removeLoading();
    },
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    onBackClicked: function onBackClicked() {
        var p = new packet("ReqLeaveRoom");
        cc.ll.net.send(p.pack());

        cc.ll.sSceneMgr.onChangeScene("mainview");
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onBeBankerClicked: function onBeBankerClicked() {
        var res = this._logic.canBeBanker();
        if (res != 0) {
            cc.ll.msgbox.addMsg(res);
            return;
        }
        if (cc.ll.pMgr.main_role.gold < TuiBingConfig.BankerLessGold) {
            cc.ll.msgbox.addMsg(msgcode.GOLD_NOT_ENOUGH);
            return;
        }
        var dialog = cc.instantiate(this.bankerDialog);
        var bg = cc.find("Canvas");
        dialog.parent = bg;

        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onShowKeepBanker: function onShowKeepBanker() {
        if (cc.ll.pMgr.main_role.gold < TuiBingConfig.BankerLessGold) {
            var p = new packet("ReqKeepBanker");
            p.lpack.iskeep = 1;
            p.lpack.gold = 0;
            cc.ll.net.send(p.pack());
            cc.ll.msgbox.addMsg(msgcode.GOLD_NOT_ENOUGH);
            return;
        }

        var bg = cc.find("Canvas");
        var tmp = bg.getChildByName("BeBankerDialog");
        if (tmp == null) {
            var dialog = cc.instantiate(this.bankerDialog);
            var logic = dialog.getComponent("OnBankerLayerLoad");
            logic.initKeep();
            dialog.parent = bg;
        }
    },

    unShowKeepBanker: function unShowKeepBanker() {
        var bg = cc.find("Canvas");
        var tmp = bg.getChildByName("BeBankerDialog");
        if (tmp != null) {
            tmp.destroy();
        }
    },

    onFastBeBankerClicked: function onFastBeBankerClicked() {
        var p = new packet("ReqBeBanker");
        p.lpack.type = 2;
        cc.ll.net.send(p.pack());
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onAddGoldBtnClicked: function onAddGoldBtnClicked() {
        // var p = new packet( "ReqAddGold" );
        // p.lpack.id = cc.ll.pMgr.main_role.id;
        // p.lpack.gold = 100000;
        // p.lpack.logtype = 901;
        // cc.ll.net.send( p.pack() ); 
        cc.ll.msgbox.addMsg(msgcode.GM_CALL_GM);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onUnBankerBtnClick: function onUnBankerBtnClick() {
        var okcallback = function okcallback() {
            var p = new packet("ReqTuiBingUnbanker");
            cc.ll.net.send(p.pack());
        };
        var cancelcallback = function cancelcallback() {
            //do nothing
        };
        cc.ll.sAudioMgr.playNormalBtnClick();
        cc.ll.notice.addMsg(1, msgcode.TUIBING_ASK_UNBANKER, okcallback, cancelcallback, 998);
    },

    onLeaveQueueBtnClick: function onLeaveQueueBtnClick() {
        var p = new packet("ReqTuibingLeaveQueue");
        cc.ll.net.send(p.pack());
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onAllPlayerClick: function onAllPlayerClick() {
        var node = cc.find("Canvas/GameBgLayer/AllPlayerList");
        node.active = !node.active;
        if (node.active == true) {
            var child = cc.find("pview/pcontent", node);
            child.removeAllChildren();
            var p = new packet("ReqTuiBingAllPlayer");
            cc.ll.net.send(p.pack());
        }

        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onKeepBankerBtnClick: function onKeepBankerBtnClick() {
        if (cc.ll.pMgr.main_role.gold < TuiBingConfig.BankerLessGold) {
            cc.ll.msgbox.addMsg(msgcode.GOLD_NOT_ENOUGH);
            return;
        }

        var bg = cc.find("Canvas");
        var tmp = bg.getChildByName("BeBankerDialog");
        if (tmp == null) {
            var dialog = cc.instantiate(this.bankerDialog);
            var logic = dialog.getComponent("OnBankerLayerLoad");
            logic.initKeep();
            dialog.parent = bg;
        }
    },

    showUnBankerTips: function showUnBankerTips() {
        this.bankerLabel.node.active = true;
        for (var i = this.BankerBtns.length - 1; i >= 0; i--) {
            var btn = this.BankerBtns[i];
            btn.node.active = false;
        }
        this._logic._unBankerFlag = true;
    }
});

cc._RFpop();
},{"LLEvent":"LLEvent","Lpackage":"Lpackage","Msgcode":"Msgcode","TuiBingConfig":"TuiBingConfig"}],"OnGmAddGoldLayerLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '655a1eTTb9FLZps4tj1cgQa', 'OnGmAddGoldLayerLoad');
// Script/GMLayer/OnGmAddGoldLayerLoad.js

"use strict";

var packet = require("Lpackage");
var msgcode = require('Msgcode');
cc.Class({
    extends: cc.Component,

    properties: {
        NameLabel: cc.EditBox,
        GoldLabel: cc.EditBox,
        LogBtnList: [cc.Button],
        _logType: 0
    },

    // use this for initialization
    onLoad: function onLoad() {
        for (var i = this.LogBtnList.length - 1; i >= 0; i--) {
            var btn = this.LogBtnList[i];
            if (i == 0) {
                btn.interactable = false;
                this._logType = 1;
            } else {
                btn.interactable = true;
            }
        }
    },

    onGoldBtnClicked: function onGoldBtnClicked(event, data) {
        var cur = Number(this.GoldLabel.string) || 0;
        var add = Number(data) || 0;
        this.GoldLabel.string = cur + add;
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onLogBtnClicked: function onLogBtnClicked(event, data) {
        for (var i = 0; i < this.LogBtnList.length; i++) {
            var btn = this.LogBtnList[i];
            if (i + 1 == data) {
                btn.interactable = false;
                this._logType = Number(data) || 1;
            } else {
                btn.interactable = true;
            }
        }
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onCleanBtnClicked: function onCleanBtnClicked() {
        this.GoldLabel.string = 0;
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onOkBtnClicked: function onOkBtnClicked(event) {
        var name = Number(this.NameLabel.string);
        if (name <= 0) {
            cc.ll.msgbox.addMsg(msgcode.COMMON_ERROR_ID);
            return;
        }
        var gold = Number(this.GoldLabel.string);
        if (gold <= 0) {
            cc.ll.msgbox.addMsg(msgcode.COMMON_ERROR_GOLD);
            return;
        }

        var p = new packet("ReqAddGold");
        p.lpack.id = name;
        p.lpack.gold = gold;
        p.lpack.logtype = this._logType;
        cc.ll.net.send(p.pack());
        cc.ll.sAudioMgr.playNormalBtnClick();
        cc.ll.loading.addLoading(3);
        this.onLayerDestroy();
    },

    onLayerDestroy: function onLayerDestroy() {
        this.node.destroy();
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","Msgcode":"Msgcode"}],"OnGmLayerLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'baacdg3BChL9LKw2jO19n1S', 'OnGmLayerLoad');
// Script/GMLayer/OnGmLayerLoad.js

"use strict";

var packet = require('Lpackage');
var TuiBingConfig = require("TuiBingConfig");
cc.Class({
    extends: cc.Component,

    properties: {
        ToggleList: [cc.Toggle],
        _logic: null,
        _gmPrefab: cc.Prefab
    },

    // use this for initialization
    onLoad: function onLoad() {
        var bglayer = cc.find("Canvas/GameBgLayer");
        this._logic = bglayer.getComponent("GameLogic");
        var self = this;
        cc.loader.loadRes("profab/GMAddGoldLayer", function (err, prefab) {
            self._gmPrefab = prefab;
        });

        var node = cc.find("AddGold", this.node);
        if (cc.ll.pMgr.main_role.gmlevel >= 1) {
            node.active = true;
        } else {
            node.active = false;
        }
        node = cc.find("ControlLayer", this.node);
        if (cc.ll.pMgr.main_role.gmlevel >= 2) {
            node.active = true;
        } else {
            node.active = false;
        }
    },

    onUnableAll: function onUnableAll() {
        for (var i = this.ToggleList.length - 1; i >= 0; i--) {
            var toggle = this.ToggleList[i];
            toggle.interactable = false;
        }
    },

    onEnableAll: function onEnableAll() {
        for (var i = this.ToggleList.length - 1; i >= 0; i--) {
            var toggle = this.ToggleList[i];
            toggle.interactable = true;
        }
    },

    onResetAll: function onResetAll() {
        for (var i = this.ToggleList.length - 1; i >= 0; i--) {
            var toggle = this.ToggleList[i];
            toggle.isChecked = false;
        }
    },

    onSendG: function onSendG(event, data) {
        var num = Number(data);
        var pos = Math.ceil(num / 2);
        var win = (num + 1) % 2 + 1;
        var toggle = event;
        if (toggle.isChecked) {} else {
            win = 0;
        }

        if (this._logic._game_state == TuiBingConfig.State.Ready || this._logic._game_state == TuiBingConfig.State.WaitOpen) {
            var p = new packet("ReqSendWin");
            p.lpack.pos = pos;
            p.lpack.win = win;
            cc.ll.net.send(p.pack());
        }
    },
    onGmAddGoldClicked: function onGmAddGoldClicked(event, data) {
        if (this._gmPrefab == null) {
            return;
        }
        var node = cc.instantiate(this._gmPrefab);
        var bg = cc.find("Canvas");
        node.parent = bg;
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","TuiBingConfig":"TuiBingConfig"}],"OnLoadingViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'fdd17YsFF5EL4YvfHLMFJrh', 'OnLoadingViewLoad');
// Script/LoadView/OnLoadingViewLoad.js

"use strict";

var ProtoBuf = require("protobuf");
var etc = require("etc");
cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        loadingBar: cc.ProgressBar,
        tips: cc.Label,

        _isLoading: false,
        _stateStr: "",
        _loadkey: 0,
        _loadingList: [cc.String],
        _nameList: [""]
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        cc.game.config['myversion'] = etc.version;
        cc.game.config['noCache'] = true;
        // this.loadingBar.totalLength = this.loadingBar.node.width;

        cc.ll = {};
        this.tips.string = "正在初始化...";
        // 初始化网络
        cc.ll.net = require("Lwebsocket");
        cc.ll.net.init();
        // 初始化协议
        cc.loader.loadRes("gamebox", function (err, arr) {
            cc.ll.pb = ProtoBuf.protoFromString(arr);
        });
        //初始化通用界面
        cc.ll.msgbox = require("Msgbox");
        cc.ll.notice = require("Notice");
        cc.ll.notice.init();
        //初始化loading界面
        cc.ll.loading = require("LoadingDialog");
        cc.ll.loading.init();
        //初始化 玩家管理器
        cc.ll.pMgr = require("PlayerManager");
        cc.ll.pMgr.init();
        //初始化 场景管理器
        cc.ll.sSceneMgr = require("SceneManager");
        //初始化 音效管理器
        cc.ll.sAudioMgr = require("AudioManager");
        cc.ll.sAudioMgr.init();

        // 加载资源
        this._loadingList = ["erguotou", "login", "main", "profab", "res_common", "sound"];
        this._nameList = ["必要", "重要", "游戏", "界面", "UI", "通用", "其他"];
        this.onLoadNext();
    },

    onLoadComplete: function onLoadComplete() {
        this._isLoading = false;
        this._stateStr = "准备登陆";
        cc.director.loadScene("loginview");
        cc.loader.onComplete = null;
    },

    onLoadNext: function onLoadNext() {
        if (this._loadkey >= this._loadingList.length) {
            this.onLoadComplete();
        } else {
            var name = this._nameList[this._loadkey];
            var dir = this._loadingList[this._loadkey];
            this.startPreloading(name, dir);
        }
        this._loadkey = this._loadkey + 1;
    },

    startPreloading: function startPreloading(name, dir) {
        this._stateStr = "正在加载" + name + "资源，请稍候";
        this._isLoading = true;
        var self = this;

        cc.loader.onProgress = function (completedCount, totalCount, item) {
            // console.log("completedCount:" + completedCount + ",totalCount:" + totalCount );
            if (self._isLoading) {
                self._progress = completedCount / totalCount;
                self.loadingBar.progress = self._progress;
            }
        };

        cc.loader.loadResDir(dir, function (err, assets) {
            self.onLoadNext();
        });
    },
    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._stateStr.length == 0) {
            return;
        }
        this.tips.string = this._stateStr + ' ';
        if (this._isLoading) {
            this.tips.string += Math.floor(this._progress * 100) + "%";
        } else {
            var t = Math.floor(Date.now() / 1000) % 4;
            for (var i = 0; i < t; ++i) {
                this.tips.string += '.';
            }
        }
    }
});

cc._RFpop();
},{"AudioManager":"AudioManager","LoadingDialog":"LoadingDialog","Lwebsocket":"Lwebsocket","Msgbox":"Msgbox","Notice":"Notice","PlayerManager":"PlayerManager","SceneManager":"SceneManager","etc":"etc","protobuf":"protobuf"}],"OnLoginLayerLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '80619/JX+JAAKITqTIH+p1v', 'OnLoginLayerLoad');
// Script/LoginView/OnLoginLayerLoad.js

'use strict';

// OnLoginLayerLoad.js
var msgcode = require('Msgcode');
var packet = require('Lpackage');

cc.Class({
    extends: cc.Component,

    properties: {
        prefabNormalRegister: {
            default: null,
            type: cc.Prefab
        },

        prefabPhoneRegister: cc.Prefab,

        accountBox: {
            default: null,
            type: cc.EditBox
        },

        passwordBox: {
            default: null,
            type: cc.EditBox
        },

        rememberCheckBox: cc.Toggle,

        _login_type: 0
    },
    onLoad: function onLoad() {
        var account = cc.sys.localStorage.getItem('account');
        var password = cc.sys.localStorage.getItem('password');
        if (account != null && account != "") {
            this.accountBox.string = account;
            this.passwordBox.string = password;
        }
    },
    onNormalRegisterClick: function onNormalRegisterClick() {
        var instance = this.prefabNormalRegister;
        if (this._login_type == 2) {
            // 手机登陆注册
            instance = this.prefabPhoneRegister;
        }
        var bg = cc.find("Canvas/BgLayer");
        var registerlayer = cc.instantiate(instance);
        registerlayer.parent = bg;
        registerlayer.setPosition(0, 0);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onDistroy: function onDistroy() {
        this.node.destroy();
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onLoginClick: function onLoginClick() {
        var account = this.accountBox.string;
        var password = this.passwordBox.string;
        if (account.length > 12 || account.length < 6) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_TOO_LONG);
            return;
        }
        if (this.rememberCheckBox.isChecked) {
            cc.sys.localStorage.setItem('account', account);
            cc.sys.localStorage.setItem('password', password);
        }
        var p = new packet("Reqlogin");
        p.lpack.account = account;
        p.lpack.password = password;
        cc.ll.net.send(p.pack());

        cc.ll.loading.addLoading(5);
        cc.ll.sAudioMgr.playNormalBtnClick();
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","Msgcode":"Msgcode"}],"OnLoginViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '20d40/lQ89HzpfSw4YPwSJO', 'OnLoginViewLoad');
// Script/LoginView/OnLoginViewLoad.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = cc.find("Canvas").getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
    },

    ontest: function ontest() {
        var callback = function callback() {
            console.log("aaaaaaaaaaaaaaaaaaa");
        };
        cc.ll.notice.addMsg(2, "继续11游戏么？", callback);
    }
});

cc._RFpop();
},{}],"OnLogin":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3e9e48vwI9I5Lb4muYwHkpr', 'OnLogin');
// Script/LoginView/OnLogin.js

"use strict";

var etc = require("etc");
var msgcode = require('Msgcode');

cc.Class({
    extends: cc.Component,

    properties: {
        prefabNormalLogin: {
            default: null,
            type: cc.Prefab
        }
    },

    onLoad: function onLoad() {
        // common.connect();
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = cc.find("Canvas").getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }

        var okfunc = function okfunc() {};
        var errorfunc = function errorfunc() {
            var callback = function callback() {
                var scenename = cc.director.getScene().name;
                if (scenename == "loadingview" || scenename == "loginview") {
                    return;
                }
                cc.ll.sSceneMgr.onChangeScene("loginview");
            };
            cc.ll.notice.addMsg(2, msgcode.NETWORK_UNCONNECT, callback);
        };
        cc.ll.net.connect(etc.ip, etc.port, okfunc, errorfunc);

        var size = cc.ll.sAudioMgr.getSize();
        var node = cc.find("Canvas/BgLayer/SettingBtn");
        var closeimg = node.getChildByName("Close");
        closeimg.active = size == 0;
        cc.ll.sAudioMgr.playBGM("bgm");
    },

    onNormalLoginClick: function onNormalLoginClick(event, data) {
        var self = this;
        var showLogin = function showLogin() {
            var bg = cc.find("Canvas/BgLayer");
            var creatlayer = cc.instantiate(self.prefabNormalLogin);
            var logic = creatlayer.getComponent("OnLoginLayerLoad");
            logic._login_type = Number(data) || 0;
            creatlayer.parent = bg;
            creatlayer.setPosition(0, 0);
        };
        if (cc.ll.net.state == 2) {
            showLogin();
        } else {
            var callback = function callback() {
                var okfunc = function okfunc() {
                    showLogin();
                };
                var errorfunc = function errorfunc() {
                    cc.ll.notice.addMsg(2, msgcode.NETWORK_UNCONNECT, null);
                };
                cc.ll.net.connect(etc.ip, etc.port, okfunc, errorfunc);
            };
            cc.ll.notice.addMsg(2, msgcode.NETWORK_UNCONNECT, callback);
        }
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onSettingClick: function onSettingClick(event) {
        var node = event.target;
        var closeimg = node.getChildByName("Close");
        closeimg.active = !closeimg.active;
        cc.ll.sAudioMgr.setSize(closeimg.active ? 0 : 1);
        cc.ll.sAudioMgr.playNormalBtnClick();
    }
});

cc._RFpop();
},{"Msgcode":"Msgcode","etc":"etc"}],"OnMainViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7a683HsuR9EMrC4+Ny/tTlP', 'OnMainViewLoad');
// Script/MainView/OnMainViewLoad.js

"use strict";

var packet = require('Lpackage');

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...

        NameLabel: {
            default: null,
            type: cc.Label
        },
        GoldLabel: {
            default: null,
            type: cc.Label
        },

        TradePrefab: cc.Prefab
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = cc.find("Canvas").getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        if (cc.ll.pMgr.main_role !== null) {
            this.NameLabel.string = cc.ll.pMgr.main_role.name + " [" + cc.ll.pMgr.main_role.id + "]";
            this.GoldLabel.string = cc.ll.pMgr.main_role.gold;
            var self = this;
            cc.ll.pMgr.main_role.register("GoldChange", this.GoldLabel.node, function (event) {
                var gold = event.getUserData();
                var label = node.getComponent(cc.Label);
                self.GoldLabel.string = gold;
            });
        }

        var size = cc.ll.sAudioMgr.getSize();
        var node = cc.find("Canvas/MainBgLayer/MainBg/SettingBtn");
        var closeimg = node.getChildByName("Close");
        closeimg.active = size == 0;
        cc.ll.sAudioMgr.playBGM("bgRace");
    },

    onGameBtnClick: function onGameBtnClick() {
        var p = new packet("ReqEnterRoom");
        p.lpack.roomid = 99;
        cc.ll.net.send(p.pack());
        cc.ll.loading.addLoading(20);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },
    onSettingClick: function onSettingClick(event) {
        var node = event.target;
        var closeimg = node.getChildByName("Close");
        closeimg.active = !closeimg.active;
        cc.ll.sAudioMgr.setSize(closeimg.active ? 0 : 1);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onTradeBtnClick: function onTradeBtnClick(event) {
        var tradelayer = cc.instantiate(this.TradePrefab);
        var bg = cc.find("/Canvas/MainBgLayer");
        tradelayer.parent = bg;
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage"}],"OnPhoneRegisterLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ae57auowHJJ+qu7Qr/gEX+F', 'OnPhoneRegisterLoad');
// Script/LoginView/OnPhoneRegisterLoad.js

'use strict';

var packet = require('Lpackage');
var msgcode = require('Msgcode');

cc.Class({
    extends: cc.Component,

    properties: {
        accountBox: {
            default: null,
            type: cc.EditBox
        },

        CheckBox: {
            default: null,
            type: cc.EditBox
        },

        passwordBox: {
            default: null,
            type: cc.EditBox
        },

        CheckBtn: cc.Button,
        CheckLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.ll.phone_check_time == 0 || cc.ll.phone_check_time == null) {
            return;
        }
        var timestamp = new Date().getTime();
        var lefttime = Math.ceil(timestamp / 1000) - cc.ll.phone_check_time;
        if (lefttime < 30) {
            this.showTimer(lefttime);
        }
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
    isNumber: function isNumber(value) {
        var patrn = /^(-)?\d+(\.\d+)?$/;
        if (patrn.exec(value) == null || value == "") {
            return false;
        } else {
            return true;
        }
    },
    onRegisterClick: function onRegisterClick() {
        var account = this.accountBox.string;
        var checknum = this.CheckBox.string;
        var password = this.passwordBox.string;

        if (account.length != 11) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_PHONE_ERROR);
            return;
        }
        if (!this.isNumber(account)) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_PHONE_ERROR);
            return;
        }
        if (checknum.length != 6) {
            cc.ll.msgbox.addMsg(msgcode.PASSWORD_NOT_SAME);
            return;
        }
        var p = new packet("ReqRegisterPhone");
        p.lpack.phonenum = account;
        p.lpack.password = password;
        p.lpack.checknum = checknum;
        cc.ll.net.send(p.pack());

        cc.sys.localStorage.setItem('account', account);
        cc.sys.localStorage.setItem('password', password);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },
    showTimer: function showTimer(time) {
        var time = time || 30;
        this.CheckBtn.node.active = false;
        this.CheckLabel.node.active = true;
        this.schedule(function () {
            this.CheckLabel.string = time + " s";
            time--;
            if (time == 0) {
                this.CheckBtn.node.active = true;
                this.CheckLabel.node.active = false;
            }
        }, 1, time, 0);
    },
    onCheckBtnClicked: function onCheckBtnClicked() {
        var account = this.accountBox.string;
        if (account.length != 11) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_PHONE_ERROR);
            return;
        }

        if (!this.isNumber(account)) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_PHONE_ERROR);
            return;
        }
        var p = new packet("ReqSendCheck");
        p.lpack.phonenum = account;
        cc.ll.net.send(p.pack());
        this.showTimer();
        var timestamp = new Date().getTime();
        cc.ll.phone_check_time = Math.ceil(timestamp / 1000);
    },

    onDistroy: function onDistroy() {
        this.node.destroy();
        cc.ll.sAudioMgr.playNormalBtnClick();
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","Msgcode":"Msgcode"}],"OnRegisterLayerLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f293dkbuB9B6Lh7bQzzLpf2', 'OnRegisterLayerLoad');
// Script/LoginView/OnRegisterLayerLoad.js

'use strict';

var packet = require('Lpackage');
var msgcode = require('Msgcode');

cc.Class({
    extends: cc.Component,

    properties: {
        accountBox: {
            default: null,
            type: cc.EditBox
        },

        passwordBox: {
            default: null,
            type: cc.EditBox
        },

        passwordBox2: {
            default: null,
            type: cc.EditBox
        }
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
    onRegisterClick: function onRegisterClick() {
        var account = this.accountBox.string;
        var password = this.passwordBox.string;
        var password2 = this.passwordBox2.string;

        if (account.length > 12 || account.length < 6 || password.length > 12 || password.length < 6) {
            cc.ll.msgbox.addMsg(msgcode.ACCOUNT_TOO_LONG);
            return;
        }
        if (password != password2) {
            cc.ll.msgbox.addMsg(msgcode.PASSWORD_NOT_SAME);
            return;
        }
        var p = new packet("ReqRegister");
        p.lpack.account = account;
        p.lpack.password = password;
        cc.ll.net.send(p.pack());
        cc.sys.localStorage.setItem('account', account);
        cc.sys.localStorage.setItem('password', password);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onDistroy: function onDistroy() {
        this.node.destroy();
        cc.ll.sAudioMgr.playNormalBtnClick();
    }
});

cc._RFpop();
},{"Lpackage":"Lpackage","Msgcode":"Msgcode"}],"OnTransferViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd170bUfqKZHibPCPsJzM9cR', 'OnTransferViewLoad');
// Script/MainView/OnTransferViewLoad.js

'use strict';

var packet = require('Lpackage');
var msgcode = require('Msgcode');

cc.Class({
    extends: cc.Component,

    properties: {
        IDLabel: cc.EditBox,
        GoldLabel: cc.EditBox,
        NameLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onGoldBtnClicked: function onGoldBtnClicked(event, data) {
        var cur = Number(this.GoldLabel.string) || 0;
        var add = Number(data) || 0;
        this.GoldLabel.string = cur + add;
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onCleanBtnClicked: function onCleanBtnClicked() {
        this.GoldLabel.string = 0;
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onNameEditEnd: function onNameEditEnd(event, data) {
        var id = Number(this.IDLabel.string);
        if (id > 0) {
            var event = require("LLEvent");
            var self = this;
            var namecallback = function namecallback(obj) {
                if (Number(self.IDLabel.string) == obj.id) {
                    self.NameLabel.string = obj.name;
                }
            };
            var index = event.addEvent(namecallback);
            var p = new packet("ReqCheckName");
            p.lpack.index = index;
            p.lpack.id = id;
            cc.ll.net.send(p.pack());
        }
    },

    onOkBtnClicked: function onOkBtnClicked(event) {
        var id = Number(this.IDLabel.string);

        if (id <= 0) {
            cc.ll.msgbox.addMsg(msgcode.COMMON_ERROR_ID);
            return;
        }
        var gold = Number(this.GoldLabel.string);
        if (gold < 500000) {
            cc.ll.msgbox.addMsg(msgcode.TRANSTFER_ERROR_GOLD);
            return;
        }

        var name = this.NameLabel.string;
        if (name.length <= 0) {
            cc.ll.msgbox.addMsg(msgcode.msgcode.COMMON_ERROR_USER);
            return;
        }
        var okcallback = function okcallback() {
            var p = new packet("ReqTradeGold");
            p.lpack.toid = id;
            p.lpack.gold = gold;
            cc.ll.net.send(p.pack());
        };
        var str = msgcode.TRANSTFER_SUBMIT_1 + name + msgcode.TRANSTFER_SUBMIT_2 + gold + msgcode.TRANSTFER_SUBMIT_3;
        var node = cc.ll.notice.addMsg(1, str, okcallback, null);
        cc.ll.sAudioMgr.playNormalBtnClick();
    },

    onLayerDestroy: function onLayerDestroy() {
        this.node.destroy();
        cc.ll.sAudioMgr.playNormalBtnClick();
    }
});

cc._RFpop();
},{"LLEvent":"LLEvent","Lpackage":"Lpackage","Msgcode":"Msgcode"}],"PlayerManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '10e76LNYb9OAKlTV2ZQcUaP', 'PlayerManager');
// Script/Role/PlayerManager.js

"use strict";

// PlayerManager.js

var pMgr = cc.Class({
    properties: {
        _role_list: null
    },
    statics: {
        main_role: null,
        init: function init() {
            this._role_list = new Array();
        },
        addPlayer: function addPlayer(role) {
            this._role_list[role.id] = role;
        }
    }
});

module.exports = pMgr;

cc._RFpop();
},{}],"Player":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ba648jm+EJMFaSoxuDjkYbm', 'Player');
// Script/Role/Player.js

"use strict";

var p = cc.Class({
	properties: {
		name: "",
		id: 0,
		state: 0, // 0未登陆， >0 已登录  1 在大厅 2 在房间 3 在游戏中
		room: 0,
		gold: 0,
		gmlevel: 0,
		_list: null,
		_firstChoose: null
	},

	ctor: function ctor() {
		this._firstChoose = new cc.Event.EventCustom("GoldChange", false);
		this._list = {};
	},

	login: function login(obj) {
		this.name = obj.name;
		this.id = obj.id;
		this.gold = obj.gold;
		this.state = 1;
		this.room = 0;
		this.gmlevel = obj.gm;

		cc.ll.pMgr.main_role = this;
		cc.ll.sSceneMgr.onChangeScene("mainview");
	},

	register: function register(event, node, func) {
		if (this._list[event] == null) {
			this._list[event] = [];
		}
		this._list[event][this._list[event].length] = node;
		node.on(event, func);
	},

	onGoldChanged: function onGoldChanged(gold) {
		this.gold = gold;
		this._firstChoose.setUserData(this.gold);
		if (this._list["GoldChange"] != null && this._list["GoldChange"].length > 0) {
			var nodelist = this._list["GoldChange"];
			for (var i = 0; i < nodelist.length; i++) {
				var node = nodelist[i];
				if (node) {
					node.dispatchEvent(this._firstChoose);
				}
			}
		}
	}
});

module.exports = p;

cc._RFpop();
},{}],"PreBankerItem":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3bb1ffd/HlFeJGvd/Zg3eQ+', 'PreBankerItem');
// Script/GameView/PreBankerItem.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _PlayerName: null,
        _ID: 0,
        _Type: 0,
        _From: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    onChangeName: function onChangeName(from, id, name, type) {
        this._ID = id;
        this._PlayerName = name;
        this._Type = type;
        this._From = from;
        var label = this.getComponent(cc.Label);
        label.string = name;
        if (type == 1) {
            this.node.color = new cc.Color(255, 255, 255);
        } else if (type == 2) {
            this.node.color = new cc.Color(255, 165, 0);
        }
    },

    onNameClicked: function onNameClicked() {
        var bg = cc.find("Canvas/GameBgLayer");
        var logic = bg.getComponent("GameLogic");
        logic.onShowPlayerDetail(this._From, this._ID, this._PlayerName);
    }
});

cc._RFpop();
},{}],"SceneManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '772d923O5dJ6YdHDBRsjrRW', 'SceneManager');
// Script/Manager/SceneManager.js

"use strict";

// SceneManager.js
var SceneMgr = cc.Class({
	statics: {
		onChangeScene: function onChangeScene(scene) {
			// cc.director.loadScene(scene);
			cc.director.preloadScene(scene, function () {
				// cc.log('Next scene preloaded');
				cc.director.loadScene(scene);
			});
		}
	}
});

module.exports = SceneMgr;

cc._RFpop();
},{}],"SettingViewLoad":[function(require,module,exports){
"use strict";
cc._RFpush(module, '75a66M88k5O5Yod/8gIlHwY', 'SettingViewLoad');
// Script/Common/SettingViewLoad.js

"use strict";

//SettingViewLoad.js
cc.Class({
    extends: cc.Component,

    properties: {
        _clicked: false,
        bar: cc.ProgressBar,
        btnSound: cc.Button,
        SpriteList: cc.SpriteAtlas
    },

    onLoad: function onLoad() {
        var size = cc.sys.localStorage.getItem('soundSize');
        if (size > 0) {
            this._clicked = false;
        } else {
            this._clicked = true;
        }
        this.onAudioClick(null, this._clicked);
    },

    onAudioSetting: function onAudioSetting(slider, customEventData) {
        var size = slider.progress;
        this.bar.progress = size;
        cc.ll.sAudioMgr.setSize(size);
    },

    onAudioClick: function onAudioClick(e, force) {
        if (force != null) {
            this._clicked = force;
        } else {
            this._clicked = !this._clicked;
        }

        if (this._clicked) {
            this.btnSound.normalSprite = this.SpriteList.getSpriteFrame("btn_sound_2");
            cc.ll.sAudioMgr.setSize(0);
        } else {
            this.btnSound.normalSprite = this.SpriteList.getSpriteFrame("btn_sound_1");
            cc.ll.sAudioMgr.setSize(1);
        }
    },

    onDistroy: function onDistroy() {
        this.node.destroy();
    }
});

cc._RFpop();
},{}],"SettingView":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5cd6cP4HlpO5oj1u/lI7eXG', 'SettingView');
// Script/Common/SettingView.js

"use strict";

//SettingView.js
var setting = cc.Class({
	properties: {
		pfab: null
	},
	statics: {
		showSetting: function showSetting() {
			var node = cc.instantiate(this.pfab);
			cc.director.getScene().addChild(node);
		},
		init: function init() {
			var self = this;
			cc.loader.loadRes("profab/SettingLayer", function (err, prefab) {
				self.pfab = prefab;
			});
		}
	}
});

module.exports = setting;

cc._RFpop();
},{}],"TuiBingConfig":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'dcf35QQhiVHt5F/a++TwNQw', 'TuiBingConfig');
// Script/Etc/TuiBingConfig.js

"use strict";

var TuiBingConfig = {
	State: {
		Stop: 0, // 未初始化
		Begin: 1, // 新游戏开始
		Begin_Check_Begin: 2, // 询问是否开始游戏
		Begin_Check_Keep: 3, // 询问是否续庄
		Ready: 4, // 准备好可以押注
		WaitOpen: 5, // 等待开牌
		Openning: 6, // 开牌阶段
		Reward: 7 },
	Time: {
		// WAIT_BEGIN = 5, -- 等待开始游戏时间
		// WAIT_KEEP = 15, -- 等待续庄时间
		// WAIT_BET = 10, -- 等待押注时间
		// WAIT_OPEN = 10, -- 开牌展示时间
		// WAIT_REWARD = 2, -- 奖励发送时间
		Begin: 5,
		Begin_keep: 30,
		Bet: 15,
		Wait: 3,
		Open: 10,
		Reward: 8
	},

	BankerMaxTimes: 25, // 最高上庄次数
	LessGold: 10000, //最低金币
	BankerLessGold: 200000, // 上庄最低金币
	FastBankerGold: 200000 };

module.exports = TuiBingConfig;

cc._RFpop();
},{}],"bytebuffer":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'b4d0di4i+BKwbusWf4CAQgW', 'bytebuffer');
// Script/Extend/bytebuffer.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define(["long"], factory);
    /* CommonJS */else if (typeof require === 'function' && (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && module["exports"]) module['exports'] = function () {
            var Long;try {
                Long = require("long");
            } catch (e) {}
            return factory(Long);
        }();
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);
})(undefined, function (Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */

    var ByteBuffer = function ByteBuffer(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined') capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined') littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined') noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0) throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i = 0;return function () {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [],
            ps = [];return function () {
            if (arguments.length === 0) return ps.join('') + stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024) ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function () {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function (capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function (buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i = 0, k = buffers.length, length; i < k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i])) buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0) return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i = 0;while (i < k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function (bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function () {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function (buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined') encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: " + encoding);
            }
        }
        if (buffer === null || (typeof buffer === "undefined" ? "undefined" : _typeof(buffer)) !== 'object') throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) {
            // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) {
                // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) {
            // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") {
            // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i = 0; i < buffer.length; ++i) {
                bb.view[i] = buffer[i];
            }
        } else throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (!(value instanceof Array)) throw TypeError("Illegal BitSet: Not an array");
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }

        var start = offset,
            bits = value.length,
            bytes = bits >> 3,
            bit = 0,
            k;

        offset += this.writeVarint32(bits, offset);

        while (bytes--) {
            k = !!value[bit++] & 1 | (!!value[bit++] & 1) << 1 | (!!value[bit++] & 1) << 2 | (!!value[bit++] & 1) << 3 | (!!value[bit++] & 1) << 4 | (!!value[bit++] & 1) << 5 | (!!value[bit++] & 1) << 6 | (!!value[bit++] & 1) << 7;
            this.writeByte(k, offset++);
        }

        if (bit < bits) {
            var m = 0;k = 0;
            while (bit < bits) {
                k = k | (!!value[bit++] & 1) << m++;
            }this.writeByte(k, offset++);
        }

        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;

        var ret = this.readVarint32(offset),
            bits = ret.value,
            bytes = bits >> 3,
            bit = 0,
            value = [],
            k;

        offset += ret.length;

        while (bytes--) {
            k = this.readByte(offset++);
            value[bit++] = !!(k & 0x01);
            value[bit++] = !!(k & 0x02);
            value[bit++] = !!(k & 0x04);
            value[bit++] = !!(k & 0x08);
            value[bit++] = !!(k & 0x10);
            value[bit++] = !!(k & 0x20);
            value[bit++] = !!(k & 0x40);
            value[bit++] = !!(k & 0x80);
        }

        if (bit < bits) {
            var m = 0;
            k = this.readByte(offset++);
            while (bit < bits) {
                value[bit++] = !!(k >> m++ & 1);
            }
        }

        if (relative) {
            this.offset = offset;
        }
        return value;
    };
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function (length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0) this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1) this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2) this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset + 1] = (value & 0xFF00) >>> 8;
            this.view[offset] = value & 0x00FF;
        } else {
            this.view[offset] = (value & 0xFF00) >>> 8;
            this.view[offset + 1] = value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value = this.view[offset];
            value |= this.view[offset + 1] << 8;
        } else {
            value = this.view[offset] << 8;
            value |= this.view[offset + 1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3) this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset + 1] = (value & 0xFF00) >>> 8;
            this.view[offset] = value & 0x00FF;
        } else {
            this.view[offset] = (value & 0xFF00) >>> 8;
            this.view[offset + 1] = value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value = this.view[offset];
            value |= this.view[offset + 1] << 8;
        } else {
            value = this.view[offset] << 8;
            value |= this.view[offset + 1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4) this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset + 3] = value >>> 24 & 0xFF;
            this.view[offset + 2] = value >>> 16 & 0xFF;
            this.view[offset + 1] = value >>> 8 & 0xFF;
            this.view[offset] = value & 0xFF;
        } else {
            this.view[offset] = value >>> 24 & 0xFF;
            this.view[offset + 1] = value >>> 16 & 0xFF;
            this.view[offset + 2] = value >>> 8 & 0xFF;
            this.view[offset + 3] = value & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value = this.view[offset + 2] << 16;
            value |= this.view[offset + 1] << 8;
            value |= this.view[offset];
            value += this.view[offset + 3] << 24 >>> 0;
        } else {
            value = this.view[offset + 1] << 16;
            value |= this.view[offset + 2] << 8;
            value |= this.view[offset + 3];
            value += this.view[offset] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5) this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset + 3] = value >>> 24 & 0xFF;
            this.view[offset + 2] = value >>> 16 & 0xFF;
            this.view[offset + 1] = value >>> 8 & 0xFF;
            this.view[offset] = value & 0xFF;
        } else {
            this.view[offset] = value >>> 24 & 0xFF;
            this.view[offset + 1] = value >>> 16 & 0xFF;
            this.view[offset + 2] = value >>> 8 & 0xFF;
            this.view[offset + 3] = value & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value = this.view[offset + 2] << 16;
            value |= this.view[offset + 1] << 8;
            value |= this.view[offset];
            value += this.view[offset + 3] << 24 >>> 0;
        } else {
            value = this.view[offset + 1] << 16;
            value |= this.view[offset + 2] << 8;
            value |= this.view[offset + 3];
            value += this.view[offset] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function (value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
            }
            if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6) this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset + 3] = lo >>> 24 & 0xFF;
                this.view[offset + 2] = lo >>> 16 & 0xFF;
                this.view[offset + 1] = lo >>> 8 & 0xFF;
                this.view[offset] = lo & 0xFF;
                offset += 4;
                this.view[offset + 3] = hi >>> 24 & 0xFF;
                this.view[offset + 2] = hi >>> 16 & 0xFF;
                this.view[offset + 1] = hi >>> 8 & 0xFF;
                this.view[offset] = hi & 0xFF;
            } else {
                this.view[offset] = hi >>> 24 & 0xFF;
                this.view[offset + 1] = hi >>> 16 & 0xFF;
                this.view[offset + 2] = hi >>> 8 & 0xFF;
                this.view[offset + 3] = hi & 0xFF;
                offset += 4;
                this.view[offset] = lo >>> 24 & 0xFF;
                this.view[offset + 1] = lo >>> 16 & 0xFF;
                this.view[offset + 2] = lo >>> 8 & 0xFF;
                this.view[offset + 3] = lo & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function (offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo = this.view[offset + 2] << 16;
                lo |= this.view[offset + 1] << 8;
                lo |= this.view[offset];
                lo += this.view[offset + 3] << 24 >>> 0;
                offset += 4;
                hi = this.view[offset + 2] << 16;
                hi |= this.view[offset + 1] << 8;
                hi |= this.view[offset];
                hi += this.view[offset + 3] << 24 >>> 0;
            } else {
                hi = this.view[offset + 1] << 16;
                hi |= this.view[offset + 2] << 8;
                hi |= this.view[offset + 3];
                hi += this.view[offset] << 24 >>> 0;
                offset += 4;
                lo = this.view[offset + 1] << 16;
                lo |= this.view[offset + 2] << 8;
                lo |= this.view[offset + 3];
                lo += this.view[offset] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function (value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
            }
            if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7) this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset + 3] = lo >>> 24 & 0xFF;
                this.view[offset + 2] = lo >>> 16 & 0xFF;
                this.view[offset + 1] = lo >>> 8 & 0xFF;
                this.view[offset] = lo & 0xFF;
                offset += 4;
                this.view[offset + 3] = hi >>> 24 & 0xFF;
                this.view[offset + 2] = hi >>> 16 & 0xFF;
                this.view[offset + 1] = hi >>> 8 & 0xFF;
                this.view[offset] = hi & 0xFF;
            } else {
                this.view[offset] = hi >>> 24 & 0xFF;
                this.view[offset + 1] = hi >>> 16 & 0xFF;
                this.view[offset + 2] = hi >>> 8 & 0xFF;
                this.view[offset + 3] = hi & 0xFF;
                offset += 4;
                this.view[offset] = lo >>> 24 & 0xFF;
                this.view[offset + 1] = lo >>> 16 & 0xFF;
                this.view[offset + 2] = lo >>> 8 & 0xFF;
                this.view[offset + 3] = lo & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function (offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo = this.view[offset + 2] << 16;
                lo |= this.view[offset + 1] << 8;
                lo |= this.view[offset];
                lo += this.view[offset + 3] << 24 >>> 0;
                offset += 4;
                hi = this.view[offset + 2] << 16;
                hi |= this.view[offset + 1] << 8;
                hi |= this.view[offset];
                hi += this.view[offset + 3] << 24 >>> 0;
            } else {
                hi = this.view[offset + 1] << 16;
                hi |= this.view[offset + 2] << 8;
                hi |= this.view[offset + 3];
                hi += this.view[offset] << 24 >>> 0;
                offset += 4;
                lo = this.view[offset + 1] << 16;
                lo |= this.view[offset + 2] << 8;
                lo |= this.view[offset + 3];
                lo += this.view[offset] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;
    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754
       The MIT License (MIT)
       Copyright (c) Feross Aboukhadijeh
       Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:
       The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e,
            m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? nBytes - 1 : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e,
            m,
            c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            i = isLE ? 0 : nBytes - 1,
            d = isLE ? 1 : -1,
            s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number') throw TypeError("Illegal value: " + value + " (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8) this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number') throw TypeError("Illegal value: " + value + " (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9) this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;

    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function (value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
        if (value < 1 << 7) return 1;else if (value < 1 << 14) return 2;else if (value < 1 << 21) return 3;else if (value < 1 << 28) return 4;else return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function (n) {
        return ((n |= 0) << 1 ^ n >> 31) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function (n) {
        return n >>> 1 ^ -(n & 1) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function (value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10) this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = value & 0x7f | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function (value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5) value |= (b & 0x7f) << 7 * c;
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function (offset) {
        var val = this.readVarint32(offset);
        if ((typeof val === "undefined" ? "undefined" : _typeof(val)) === 'object') val["value"] = ByteBuffer.zigZagDecode32(val["value"]);else val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function (value) {
            if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14) return part0 < 1 << 7 ? 1 : 2;else return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14) return part1 < 1 << 7 ? 5 : 6;else return part1 < 1 << 21 ? 7 : 8;
                }
            } else return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function (value) {
            if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function (value) {
            if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function (value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
            }
            if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11) this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10:
                    this.view[offset + 9] = part2 >>> 7 & 0x01;
                case 9:
                    this.view[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
                case 8:
                    this.view[offset + 7] = size !== 8 ? part1 >>> 21 | 0x80 : part1 >>> 21 & 0x7F;
                case 7:
                    this.view[offset + 6] = size !== 7 ? part1 >>> 14 | 0x80 : part1 >>> 14 & 0x7F;
                case 6:
                    this.view[offset + 5] = size !== 6 ? part1 >>> 7 | 0x80 : part1 >>> 7 & 0x7F;
                case 5:
                    this.view[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
                case 4:
                    this.view[offset + 3] = size !== 4 ? part0 >>> 21 | 0x80 : part0 >>> 21 & 0x7F;
                case 3:
                    this.view[offset + 2] = size !== 3 ? part0 >>> 14 | 0x80 : part0 >>> 14 & 0x7F;
                case 2:
                    this.view[offset + 1] = size !== 2 ? part0 >>> 7 | 0x80 : part0 >>> 7 & 0x7F;
                case 1:
                    this.view[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function (value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function (offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b = 0;
            b = this.view[offset++];part0 = b & 0x7F;if (b & 0x80) {
                b = this.view[offset++];part0 |= (b & 0x7F) << 7;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                    b = this.view[offset++];part0 |= (b & 0x7F) << 14;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                        b = this.view[offset++];part0 |= (b & 0x7F) << 21;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                            b = this.view[offset++];part1 = b & 0x7F;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                b = this.view[offset++];part1 |= (b & 0x7F) << 7;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                    b = this.view[offset++];part1 |= (b & 0x7F) << 14;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                        b = this.view[offset++];part1 |= (b & 0x7F) << 21;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                            b = this.view[offset++];part2 = b & 0x7F;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                                b = this.view[offset++];part2 |= (b & 0x7F) << 7;if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                                                    throw Error("Buffer overrun");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            var value = Long.fromBits(part0 | part1 << 28, part1 >>> 4 | part2 << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset - start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function (offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long) val["value"] = ByteBuffer.zigZagDecode64(val["value"]);else val = ByteBuffer.zigZagDecode64(val);
            return val;
        };
    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function (str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
            for (i = 0; i < k; ++i) {
                if (str.charCodeAt(i) === 0) throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k + 1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12) this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k + 1;
        utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd,
            b = -1;
        utfx.decodeUTF8toUTF16(function () {
            if (b === 0) return null;
            if (offset >= this.limit) throw RangeError("Illegal range: Truncated data, " + offset + " < " + this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function (str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4 + k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13) this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4 + k;
        if (this.littleEndian) {
            this.view[offset + 3] = k >>> 24 & 0xFF;
            this.view[offset + 2] = k >>> 16 & 0xFF;
            this.view[offset + 1] = k >>> 8 & 0xFF;
            this.view[offset] = k & 0xFF;
        } else {
            this.view[offset] = k >>> 24 & 0xFF;
            this.view[offset + 1] = k >>> 16 & 0xFF;
            this.view[offset + 2] = k >>> 8 & 0xFF;
            this.view[offset + 3] = k & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k) throw RangeError("Illegal range: Truncated data, " + offset + " == " + (offset + 4 + k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function (str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14) this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function (str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function (str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function (length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) {
            // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function () {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function (cp) {
                ++i;utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length) throw RangeError("Illegal range: Truncated data, " + i + " == " + length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function () {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k) throw RangeError("Illegal range: Truncated data, " + offset + " == " + k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else throw TypeError("Unsupported metrics: " + metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function (str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        var start = offset,
            k,
            l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l + k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15) this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l + k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + k + l) throw RangeError("Illegal range: Truncated data, " + offset + " == " + (offset + k + l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function (offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function (source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16) this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function (target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function (assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function () {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function () {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function (copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength) return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        if (begin === end) return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function (target, targetOffset, sourceOffset, sourceLimit) {
        var relative, targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target)) throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength) throw RangeError("Illegal target range: 0 <= " + targetOffset + " <= " + target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= " + sourceOffset + " <= " + this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0) return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function (capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity) return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function (value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0) value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        if (begin >= end) return this; // Nothing to fill
        while (begin < end) {
            this.view[begin++] = value;
        }if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function () {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function (offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function (littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean') throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function (littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function (bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function (source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) {
            // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative) this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function (target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function (out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(this.toString() + "\n" + "-------------------------------------------------------------------\n" + this.toDebug( /* columns */true));
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function () {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function () {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function (capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0) throw TypeError("Illegal capacity: " + capacity + " (not an integer)");
            capacity |= 0;
            if (capacity < 0) throw RangeError("Illegal capacity: 0 <= " + capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        if (begin === end) return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function (length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + length + " <= " + this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function (forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0) throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + offset + " <= " + limit + " <= " + this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength) return this.buffer;
        if (offset === limit) return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function (encoding, begin, end) {
        if (typeof encoding === 'undefined') return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
        if (typeof encoding === 'number') encoding = "utf8", begin = encoding, end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: " + encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function () {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */

        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i = 0, k = aout.length; i < k; ++i) {
            ain[aout[i]] = i;
        } /**
           * Encodes bytes to base64 char codes.
           * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
           *  there are no more bytes left.
           * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
           *  code.
           */
        lxiv.encode = function (src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[b >> 2 & 0x3f]);
                t = (b & 0x3) << 4;
                if ((b = src()) !== null) {
                    t |= b >> 4 & 0xf;
                    dst(aout[(t | b >> 4 & 0xf) & 0x3f]);
                    t = (b & 0xf) << 2;
                    if ((b = src()) !== null) dst(aout[(t | b >> 6 & 0x3) & 0x3f]), dst(aout[b & 0x3f]);else dst(aout[t & 0x3f]), dst(61);
                } else dst(aout[t & 0x3f]), dst(61), dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function (src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: " + c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst(t1 << 2 >>> 0 | (t2 & 0x30) >> 4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined') if (c === 61) break;else fail(c);
                        dst((t2 & 0xf) << 4 >>> 0 | (t1 & 0x3c) >> 2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined') if (c === 61) break;else fail(c);
                            dst((t1 & 0x3) << 6 >>> 0 | t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function (str) {
            return (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str)
            );
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        begin = begin | 0;end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end) throw RangeError("begin, end");
        var sd;lxiv.encode(function () {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function (str, littleEndian) {
        if (typeof str !== 'string') throw TypeError("str");
        var bb = new ByteBuffer(str.length / 4 * 3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function (b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function (str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function (b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        begin |= 0;end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end) throw RangeError("begin, end");
        if (begin === end) return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024) parts.push(String.fromCharCode.apply(String, chars)), chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function (str, littleEndian) {
        if (typeof str !== 'string') throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i < k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff) throw RangeError("illegal char code: " + charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function (columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i < k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0" + b.toString(16).toUpperCase();else hex += b.toString(16).toUpperCase();
                if (columns) asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3 * 16 + 3) {
                        hex += " ";
                    }out += hex + asc + "\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit) hex += i === this.markedOffset ? "!" : "|";else if (i === this.offset) hex += i === this.markedOffset ? "[" : "<";else if (i === this.limit) hex += i === this.markedOffset ? "]" : ">";else hex += i === this.markedOffset ? "'" : columns || i !== 0 && i !== k ? " " : "";
        }
        if (columns && hex !== " ") {
            while (hex.length < 3 * 16 + 3) {
                hex += " ";
            }out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function (str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer((k + 1) / 3 | 0, littleEndian, noAssert);
        var i = 0,
            j = 0,
            ch,
            b,
            rs = false,
            // Require symbol next
        ho = false,
            hm = false,
            hl = false,
            // Already has offset (ho), markedOffset (hm), limit (hl)?
        fail = false;
        while (i < k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch + str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255) throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail) throw TypeError("Illegal str: Invalid symbol at " + i);
        }
        if (!noAssert) {
            if (!ho || !hl) throw TypeError("Illegal str: Missing offset or limit");
            if (j < bb.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + j + " < " + k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function (begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10) out.push("0", b.toString(16));else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function (str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0) throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer(k / 2 | 0, littleEndian),
            b;
        for (var i = 0, j = 0; i < k; i += 2) {
            b = parseInt(str.substring(i, i + 2), 16);
            if (!noAssert) if (!isFinite(b) || b < 0 || b > 255) throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function () {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */

        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function (src, dst) {
            var cp = null;
            if (typeof src === 'number') cp = src, src = function src() {
                return null;
            };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80) dst(cp & 0x7F);else if (cp < 0x800) dst(cp >> 6 & 0x1F | 0xC0), dst(cp & 0x3F | 0x80);else if (cp < 0x10000) dst(cp >> 12 & 0x0F | 0xE0), dst(cp >> 6 & 0x3F | 0x80), dst(cp & 0x3F | 0x80);else dst(cp >> 18 & 0x07 | 0xF0), dst(cp >> 12 & 0x3F | 0x80), dst(cp >> 6 & 0x3F | 0x80), dst(cp & 0x3F | 0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function (src, dst) {
            var a,
                b,
                c,
                d,
                fail = function fail(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a & 0x80) === 0) dst(a);else if ((a & 0xE0) === 0xC0) (b = src()) === null && fail([a, b]), dst((a & 0x1F) << 6 | b & 0x3F);else if ((a & 0xF0) === 0xE0) ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F);else if ((a & 0xF8) === 0xF0) ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F);else throw RangeError("Illegal starting byte: " + a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function (src, dst) {
            var c1,
                c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null) break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000);
                            c2 = null;continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function (src, dst) {
            var cp = null;
            if (typeof src === 'number') cp = src, src = function src() {
                return null;
            };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF) dst(cp);else cp -= 0x10000, dst((cp >> 10) + 0xD800), dst(cp % 0x400 + 0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function (src, dst) {
            utfx.UTF16toUTF8(src, function (cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function (src, dst) {
            utfx.decodeUTF8(src, function (cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function (cp) {
            return cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function (src) {
            var cp,
                l = 0;
            while ((cp = src()) !== null) {
                l += cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
            }return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function (src) {
            var n = 0,
                l = 0;
            utfx.UTF16toUTF8(src, function (cp) {
                ++n;l += cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
            });
            return [n, l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function (begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
        }
        var sd;try {
            utfx.decodeUTF8toUTF16(function () {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end) throw RangeError("Illegal range: Truncated data, " + begin + " != " + end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function (str, littleEndian, noAssert) {
        if (!noAssert) if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});

cc._RFpop();
},{"long":"long"}],"errorcode":[function(require,module,exports){
"use strict";
cc._RFpush(module, '98efcEQmj1OoZp82LmQy01m', 'errorcode');
// Script/Etc/errorcode.js

"use strict";

// ErrorCode.js
var ErrorCode = {};

ErrorCode.ACCOUNT_REPEAT = 1;
ErrorCode.DBSERVICE_ERROR = 99;
ErrorCode.NO_ACCOUNT = 101;
ErrorCode.PASSWORD_ERROR = 102;
ErrorCode.HAS_ONLINE = 103;
ErrorCode.NO_USER_ID = 105;
ErrorCode.NOT_ONLINE = 106;
ErrorCode.ACCOUNT_SEAL = 107;

ErrorCode.ROOM_NOT_FOUND = 201;
ErrorCode.ROOM_FULL = 202;

ErrorCode.GOLD_NOT_ENOUGH = 301;
ErrorCode.BANKER_NO_BET = 401;
ErrorCode.NOT_BANKER = 402;
ErrorCode.NOT_IN_QUEUE = 403;
ErrorCode.UR_BANKER = 404;
ErrorCode.HAS_IN_QUEUE = 405;
ErrorCode.TUIBING_ROOMCLOSE = 406;

// mahjong
ErrorCode.MAHJONG_ROOM_FULL = 501;
ErrorCode.MAHJONG_PLAYER_NOT_FOUND = 502;
ErrorCode.MAHJONG_MJ_NOT_FOUND = 503;
ErrorCode.MAHJONG_ERROR_COMMAND = 504;

// DB
ErrorCode.DB_PLAYER_NOT_FOUND = 701;
// GM
ErrorCode.PERMISSION_DENIED = 901;
ErrorCode.LOGTYPE_ERROR = 902;

module.exports = ErrorCode;

cc._RFpop();
},{}],"etc":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd4b55wvXnFJubQj56RQTAHs', 'etc');
// Script/Etc/etc.js

"use strict";

cc.Class({
	extends: cc.Component,
	statics: {
		ip: "194.168.0.225",
		// ip : "119.29.179.126",
		port: 8001,
		version: "1.0.0.1"
	}

});

cc._RFpop();
},{}],"long":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e2f8e7clBRJlLm8c2IAj48Z', 'long');
// Script/Extend/long.js

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define([], factory);
    /* CommonJS */else if (typeof require === 'function' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory();
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
})(undefined, function () {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */

    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned, unsigned = false;
        } else {
            unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long) return val;
        if (typeof val === 'number') return fromNumber(val);
        if (typeof val === 'string') return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');
        if (this.isZero()) return '0';
        if (this.isNegative()) {
            // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) {
            if ((val & 1 << bit) != 0) break;
        }return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq( /* validates */other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp( /* validates */other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp( /* validates */other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp( /* validates */other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp( /* validates */other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        // At this point the sign bits are the same
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return ZERO;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (multiplier.isZero()) return ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error('division by zero');
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE)) return ONE;else {
                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                        var halfThis = this.shr(1);
                        approx = halfThis.div(divisor).shl(1);
                        if (approx.eq(ZERO)) {
                            return divisor.isNegative() ? ONE : NEG_ONE;
                        } else {
                            rem = this.sub(divisor.mul(approx));
                            res = approx.add(rem.div(divisor));
                            return res;
                        }
                    }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),


            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0) return this;else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
    };

    return Long;
});

cc._RFpop();
},{}],"msgdispatch":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2c309XMbRpDmYfPVNvC5FRk', 'msgdispatch');
// Script/NetWork/msgdispatch.js

"use strict";

var packet = require("Lpackage");
var msgcode = require('Msgcode');
var ErrorCode = require("errorcode");
var TuiBingConfig = require("TuiBingConfig");

var onLogin = function onLogin(pack) {
    var result = pack.result;
    if (result == 0) {
        var obj = { id: pack.id, name: pack.name, gold: pack.gold, gm: pack.gmlevel };
        var player = require('Player');
        var pPlayer = new player();
        pPlayer.login(obj);
    } else if (result == ErrorCode.ACCOUNT_SEAL) {
        var timestamp3 = pack.id;
        var newDate = new Date();
        newDate.setTime(timestamp3 * 1000);
        var msg = msgcode[result] + " " + newDate.toLocaleString() + msgcode.END_COLOR + msgcode.END_SIZE;
        cc.ll.notice.addMsg(2, msg, null);
    } else {
        cc.ll.msgbox.addMsg(result);
    }
    cc.ll.loading.removeLoading();
};

var onRegister = function onRegister(pack) {
    var result = pack.result;
    if (result != 0) {
        cc.ll.msgbox.addMsg(result);
    }
};

var onEnterRoom = function onEnterRoom(pack) {
    var result = pack.result;
    if (result == 0) {
        cc.ll.sSceneMgr.onChangeScene("tuibingview");
    } else {
        cc.ll.msgbox.addMsg(result);
    }
};

var onBeBanker = function onBeBanker(pack) {
    var result = pack.result;
    if (result != 0) {
        cc.ll.msgbox.addMsg(result);
    }
};

var onTuibingUnbanker = function onTuibingUnbanker(pack) {
    var result = pack.result;
    if (result != 0) {
        cc.ll.msgbox.addMsg(result);
    } else {
        var node = cc.find("Canvas/GameBgLayer");
        if (node) {
            var viewlogic = node.getComponent("OnGameViewLoad");
            viewlogic.showUnBankerTips();
        }
    }
};

var onTuibingLeaveQueue = function onTuibingLeaveQueue(pack) {
    var result = pack.result;
    if (result != 0) {
        cc.ll.msgbox.addMsg(result);
    }
};

var onTuiBingQueueChange = function onTuiBingQueueChange(pack) {
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        var banker = {
            bankerid: pack.bankerid,
            bankername: pack.bankername
        };
        gamelogic.onQueueChanged(banker, pack.queue);
    }
};

var onTuiBingGameState = function onTuiBingGameState(pack) {
    var state = pack.state;
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        gamelogic.onGameStateChange(state);
    }
    if (state == TuiBingConfig.State.Ready) {
        cc.ll.notice.removeMsg(998);
    }
};

var onGoldChange = function onGoldChange(pack) {
    var gold = pack.gold;
    cc.ll.pMgr.main_role.onGoldChanged(gold);
};

var onTuiBingBet = function onTuiBingBet(pack) {
    var result = pack.result;
    var id = pack.id;
    var pos = pack.pos;
    var gold = pack.gold;
    if (result == 0) {
        var node = cc.find("Canvas/GameBgLayer");
        if (node) {
            var gamelogic = node.getComponent("GameLogic");
            gamelogic.onPlayerBet(id, pos, gold);
        }
    } else {
        cc.ll.msgbox.addMsg(result);
    }
};

var onKeepBanker = function onKeepBanker(pack) {
    // let begincallback = function() {
    //     var p = new packet( "ReqKeepBanker" );
    //     p.lpack.iskeep = 0;
    //     p.lpack.gold = 200000;
    //     cc.ll.net.send( p.pack() );
    // }
    // let endcallback = function() {
    //     //下庄
    //     var p = new packet( "ReqKeepBanker" );
    //     p.lpack.iskeep = 1;
    //     p.lpack.gold = 0;
    //     cc.ll.net.send( p.pack() );
    // }
    // cc.ll.notice.addMsg(1,msgcode.TUIBING_KEEP_BANKER, begincallback, endcallback, 998);
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gameviewload = node.getComponent("OnGameViewLoad");
        gameviewload.onShowKeepBanker();
    }
};

var onBankerBegin = function onBankerBegin(pack) {
    var begincallback = function begincallback() {
        var p = new packet("ReqTuiBingBegin");
        cc.ll.net.send(p.pack());
    };
    var endcallback = function endcallback() {
        //下庄
        var p = new packet("ReqKeepBanker");
        p.lpack.iskeep = 1;
        p.lpack.gold = 0;
        cc.ll.net.send(p.pack());
    };
    var time = TuiBingConfig.Time.Begin;
    var str = msgcode.TUIBING_BANKER_BEGIN + "<br/><color=#FF0000><size = 25>00:0" + time + "</color></size>";
    var node = cc.ll.notice.addMsg(1, str, begincallback, endcallback, 998);
    var msgnode = node.getChildByName("NoticeBg").getChildByName("NoticeLabel");
    var msglabel = msgnode.getComponent(cc.RichText);

    var intervalID = setInterval(function () {
        time--;
        if (cc.isValid(node)) {
            var str = msgcode.TUIBING_BANKER_BEGIN + "<br/><color=#FF0000><size = 25>00:0" + time + "</color></size>";
            msglabel.string = str;
        }
    }, 1000);
    setTimeout(function () {
        clearInterval(intervalID);
    }, time * 1000);
};

var onTuiBingBetGold = function onTuiBingBetGold(pack) {
    var goldlist = pack.gold;
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        // gamelogic.onGoldAction( gold )
        gamelogic.onBetGoldCount(goldlist);
    }
};

var onDealMajiang = function onDealMajiang(pack) {
    var majiangs = pack.majiangs;
    var dice1 = pack.dice1;
    var dice2 = pack.dice2;
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        // gamelogic.onGoldAction( gold )
        gamelogic.onOpenMajiang(majiangs, dice1, dice2);
    }
};

var onCloseClient = function onCloseClient(pack) {
    var type = pack.type;
    var msg = "unknow error";
    if (type == 1) {
        msg = msgcode.NETWORK_OTHER_LOGIN;
    } else if (type == 2) {
        msg = msgcode.NETWORK_RELOGIN;
    }
    var okcallback = function okcallback(argument) {
        cc.ll.sSceneMgr.onChangeScene("loginview");
    };
    cc.ll.notice.addMsg(2, msg, okcallback);
};

var onTuibingBankerInfo = function onTuibingBankerInfo(pack) {
    var obj = {
        name: pack.name,
        id: pack.id,
        gold: pack.gold,
        times: pack.times
    };
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        gamelogic.onBankerInfo(obj);
    }
};

var onResKeepBanker = function onResKeepBanker(pack) {
    var result = pack.result;
    if (result != 0) {
        cc.ll.msgbox.addMsg(result);
    }
};

var onToTuiBingResult = function onToTuiBingResult(pack) {
    var winlist = pack.iswiner;
    var goldlist = pack.posgold;
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        gamelogic.onSendReward(winlist, goldlist);
    }
};

var onTuibingAllPlayer = function onTuibingAllPlayer(pack) {
    var list = pack.list;
    var node = cc.find("Canvas/GameBgLayer");
    if (node) {
        var gamelogic = node.getComponent("GameLogic");
        gamelogic.onShowAllPlayer(list);
    }
};

var onAddGold = function onAddGold(pack) {
    var result = pack.result;
    if (result == 0) {
        cc.ll.notice.addMsg(2, msgcode.GM_PAYMENT_OK, function () {});
    } else {
        cc.ll.notice.addMsg(2, result);
    }
    // cc.ll.loading.removeLoading();
};

var onCheckName = function onCheckName(pack) {
    var result = pack.result;
    if (result == 0) {
        var index = pack.index;
        var id = pack.id;
        var name = pack.name;
        var event = require("LLEvent");
        var obj = { id: id, name: name };
        event.dispatchEvent(index, obj);
    } else {
        // cc.ll.msgbox.addMsg(result);
        var node = cc.ll.notice.addMsg(2, result, null);
        node.setTimeOut(3);
    }
};

var onToTradeGold = function onToTradeGold(pack) {
    var id = pack.fromid;
    var name = pack.fromname;
    var gold = pack.gold;

    var str = msgcode.TRANSTFER_NOTICE_1 + name + msgcode.TRANSTFER_NOTICE_2 + gold + msgcode.TRANSTFER_NOTICE_3;
    cc.ll.notice.addMsg(2, str, null);
};

var onTradeGold = function onTradeGold(pack) {
    var result = pack.result;
    if (result == 0) {
        var node = cc.ll.notice.addMsg(2, msgcode.TRANSTFER_COMPLETE, null);
    } else {
        var node = cc.ll.notice.addMsg(2, result, null);
    }
};

var FuncMap = {
    "Reslogin": onLogin,
    "ResRegister": onRegister,
    "ResEnterRoom": onEnterRoom,
    "ResBeBanker": onBeBanker,
    "ResTuiBingQueueChange": onTuiBingQueueChange,
    "ToTuiBingGameState": onTuiBingGameState,
    "ToGoldChange": onGoldChange,
    "ResTuiBingBet": onTuiBingBet,
    "ToKeepBanker": onKeepBanker,
    "ResKeepBanker": onResKeepBanker,
    "ToBankerBegin": onBankerBegin,
    "ToTuiBingBetGold": onTuiBingBetGold,
    "ToDealMajiang": onDealMajiang,
    "ToCloseClient": onCloseClient,
    "ToTuibingBankerInfo": onTuibingBankerInfo,
    "ResTuiBingUnbanker": onTuibingUnbanker,
    "ResTuibingLeaveQueue": onTuibingLeaveQueue,
    "ToTuiBingResult": onToTuiBingResult,
    "ResTuiBingAllPlayer": onTuibingAllPlayer,
    "ResAddGold": onAddGold,
    "ResCheckName": onCheckName,
    "ToTreadeGold": onToTradeGold,
    "ResTradeGold": onTradeGold
};

var msgdispatch = cc.Class({
    // extends: cc.Component,
    name: "MsgDispatch",
    statics: {
        dispatch: function dispatch(head, buffer) {
            var func = FuncMap[head];
            if (func !== null) {
                var p = new packet(head);
                p.unpack(buffer);
                func(p.msg);
            }
        }
    }
});
module.exports = msgdispatch;

cc._RFpop();
},{"LLEvent":"LLEvent","Lpackage":"Lpackage","Msgcode":"Msgcode","Player":"Player","TuiBingConfig":"TuiBingConfig","errorcode":"errorcode"}],"protobuf":[function(require,module,exports){
(function (process){
"use strict";
cc._RFpush(module, '139f0gl+8ZBrIpK/BI0/F0d', 'protobuf');
// Script/Extend/protobuf.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/protobuf.js for details
 */
(function (global, factory) {

    /* AMD */if (typeof define === 'function' && define["amd"]) define(["bytebuffer"], factory);
    /* CommonJS */else if (typeof require === "function" && (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && module["exports"]) module["exports"] = factory(require("bytebuffer"), true);
        /* Global */else (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
})(undefined, function (ByteBuffer, isCommonJS) {
    "use strict";

    /**
     * The ProtoBuf namespace.
     * @exports ProtoBuf
     * @namespace
     * @expose
     */

    var ProtoBuf = {};

    /**
     * @type {!function(new: ByteBuffer, ...[*])}
     * @expose
     */
    ProtoBuf.ByteBuffer = ByteBuffer;

    /**
     * @type {?function(new: Long, ...[*])}
     * @expose
     */
    ProtoBuf.Long = ByteBuffer.Long || null;

    /**
     * ProtoBuf.js version.
     * @type {string}
     * @const
     * @expose
     */
    ProtoBuf.VERSION = "5.0.1";

    /**
     * Wire types.
     * @type {Object.<string,number>}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES = {};

    /**
     * Varint wire type.
     * @type {number}
     * @expose
     */
    ProtoBuf.WIRE_TYPES.VARINT = 0;

    /**
     * Fixed 64 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS64 = 1;

    /**
     * Length delimited wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.LDELIM = 2;

    /**
     * Start group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

    /**
     * End group wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

    /**
     * Fixed 32 bits wire type.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.WIRE_TYPES.BITS32 = 5;

    /**
     * Packable wire types.
     * @type {!Array.<number>}
     * @const
     * @expose
     */
    ProtoBuf.PACKABLE_WIRE_TYPES = [ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32];

    /**
     * Types.
     * @dict
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
     * @const
     * @expose
     */
    ProtoBuf.TYPES = {
        // According to the protobuf spec.
        "int32": {
            name: "int32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "uint32": {
            name: "uint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "sint32": {
            name: "sint32",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "int64": {
            name: "int64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "uint64": {
            name: "uint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sint64": {
            name: "sint64",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "bool": {
            name: "bool",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: false
        },
        "double": {
            name: "double",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: 0
        },
        "string": {
            name: "string",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: ""
        },
        "bytes": {
            name: "bytes",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null // overridden in the code, must be a unique instance
        },
        "fixed32": {
            name: "fixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "sfixed32": {
            name: "sfixed32",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "fixed64": {
            name: "fixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
        },
        "sfixed64": {
            name: "sfixed64",
            wireType: ProtoBuf.WIRE_TYPES.BITS64,
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
        },
        "float": {
            name: "float",
            wireType: ProtoBuf.WIRE_TYPES.BITS32,
            defaultValue: 0
        },
        "enum": {
            name: "enum",
            wireType: ProtoBuf.WIRE_TYPES.VARINT,
            defaultValue: 0
        },
        "message": {
            name: "message",
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,
            defaultValue: null
        },
        "group": {
            name: "group",
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
            defaultValue: null
        }
    };

    /**
     * Valid map key types.
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
     * @const
     * @expose
     */
    ProtoBuf.MAP_KEY_TYPES = [ProtoBuf.TYPES["int32"], ProtoBuf.TYPES["sint32"], ProtoBuf.TYPES["sfixed32"], ProtoBuf.TYPES["uint32"], ProtoBuf.TYPES["fixed32"], ProtoBuf.TYPES["int64"], ProtoBuf.TYPES["sint64"], ProtoBuf.TYPES["sfixed64"], ProtoBuf.TYPES["uint64"], ProtoBuf.TYPES["fixed64"], ProtoBuf.TYPES["bool"], ProtoBuf.TYPES["string"], ProtoBuf.TYPES["bytes"]];

    /**
     * Minimum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MIN = 1;

    /**
     * Maximum field id.
     * @type {number}
     * @const
     * @expose
     */
    ProtoBuf.ID_MAX = 0x1FFFFFFF;

    /**
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
     *  Must be set prior to parsing.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.convertFieldsToCamelCase = false;

    /**
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
     *  setting this to `false` prior to building messages.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateAccessors = true;

    /**
     * By default, messages are populated with default values if a field is not present on the wire. To disable
     *  this behavior, set this setting to `false`.
     * @type {boolean}
     * @expose
     */
    ProtoBuf.populateDefaults = true;

    /**
     * @alias ProtoBuf.Util
     * @expose
     */
    ProtoBuf.Util = function () {
        "use strict";

        /**
         * ProtoBuf utilities.
         * @exports ProtoBuf.Util
         * @namespace
         */

        var Util = {};

        /**
         * Flag if running in node or not.
         * @type {boolean}
         * @const
         * @expose
         */
        Util.IS_NODE = !!((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process + '' === '[object process]' && !process['browser']);

        /**
         * Constructs a XMLHttpRequest object.
         * @return {XMLHttpRequest}
         * @throws {Error} If XMLHttpRequest is not supported
         * @expose
         */
        Util.XHR = function () {
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
            var XMLHttpFactories = [function () {
                return new XMLHttpRequest();
            }, function () {
                return new ActiveXObject("Msxml2.XMLHTTP");
            }, function () {
                return new ActiveXObject("Msxml3.XMLHTTP");
            }, function () {
                return new ActiveXObject("Microsoft.XMLHTTP");
            }];
            /** @type {?XMLHttpRequest} */
            var xhr = null;
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xhr = XMLHttpFactories[i]();
                } catch (e) {
                    continue;
                }
                break;
            }
            if (!xhr) throw Error("XMLHttpRequest is not supported");
            return xhr;
        };

        /**
         * Fetches a resource.
         * @param {string} path Resource path
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose
         */
        Util.fetch = function (path, callback) {
            if (callback && typeof callback != 'function') callback = null;
            if (Util.IS_NODE) {
                var fs = require("fs");
                if (callback) {
                    fs.readFile(path, function (err, data) {
                        if (err) callback(null);else callback("" + data);
                    });
                } else try {
                    return fs.readFileSync(path);
                } catch (e) {
                    return null;
                }
            } else {
                var xhr = Util.XHR();
                xhr.open('GET', path, callback ? true : false);
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                xhr.setRequestHeader('Accept', 'text/plain');
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                if (callback) {
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState != 4) return;
                        if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') callback(xhr.responseText);else callback(null);
                    };
                    if (xhr.readyState == 4) return;
                    xhr.send(null);
                } else {
                    xhr.send(null);
                    if ( /* remote */xhr.status == 200 || /* local */xhr.status == 0 && typeof xhr.responseText === 'string') return xhr.responseText;
                    return null;
                }
            }
        };

        /**
         * Converts a string to camel case.
         * @param {string} str
         * @returns {string}
         * @expose
         */
        Util.toCamelCase = function (str) {
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                return $1.toUpperCase();
            });
        };

        return Util;
    }();

    /**
     * Language expressions.
     * @type {!Object.<string,!RegExp>}
     * @expose
     */
    ProtoBuf.Lang = {

        // Characters always ending a statement
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,

        // Field rules
        RULE: /^(?:required|optional|repeated|map)$/,

        // Field types
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,

        // Names
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,

        // Type definitions
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,

        // Type references
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,

        // Fully qualified type references
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,

        // All numbers
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,

        // Decimal numbers
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,

        // Hexadecimal numbers
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,

        // Octal numbers
        NUMBER_OCT: /^0[0-7]+$/,

        // Floating point numbers
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,

        // Booleans
        BOOL: /^(?:true|false)$/i,

        // Id numbers
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Negative id numbers (enum values)
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,

        // Whitespaces
        WHITESPACE: /\s/,

        // All strings
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,

        // Double quoted strings
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,

        // Single quoted strings
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
    };

    /**
     * @alias ProtoBuf.DotProto
     * @expose
     */
    ProtoBuf.DotProto = function (ProtoBuf, Lang) {
        "use strict";

        /**
         * Utilities to parse .proto files.
         * @exports ProtoBuf.DotProto
         * @namespace
         */

        var DotProto = {};

        /**
         * Constructs a new Tokenizer.
         * @exports ProtoBuf.DotProto.Tokenizer
         * @class prototype tokenizer
         * @param {string} proto Proto to tokenize
         * @constructor
         */
        var Tokenizer = function Tokenizer(proto) {

            /**
             * Source to parse.
             * @type {string}
             * @expose
             */
            this.source = proto + "";

            /**
             * Current index.
             * @type {number}
             * @expose
             */
            this.index = 0;

            /**
             * Current line.
             * @type {number}
             * @expose
             */
            this.line = 1;

            /**
             * Token stack.
             * @type {!Array.<string>}
             * @expose
             */
            this.stack = [];

            /**
             * Opening character of the current string read, if any.
             * @type {?string}
             * @private
             */
            this._stringOpen = null;
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer.prototype
         * @inner
         */
        var TokenizerPrototype = Tokenizer.prototype;

        /**
         * Reads a string beginning at the current index.
         * @return {string}
         * @private
         */
        TokenizerPrototype._readString = function () {
            var re = this._stringOpen === '"' ? Lang.STRING_DQ : Lang.STRING_SQ;
            re.lastIndex = this.index - 1; // Include the open quote
            var match = re.exec(this.source);
            if (!match) throw Error("unterminated string");
            this.index = re.lastIndex;
            this.stack.push(this._stringOpen);
            this._stringOpen = null;
            return match[1];
        };

        /**
         * Gets the next token and advances by one.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.next = function () {
            if (this.stack.length > 0) return this.stack.shift();
            if (this.index >= this.source.length) return null;
            if (this._stringOpen !== null) return this._readString();

            var repeat, prev, next;
            do {
                repeat = false;

                // Strip white spaces
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
                    if (next === '\n') ++this.line;
                    if (++this.index === this.source.length) return null;
                }

                // Strip comments
                if (this.source.charAt(this.index) === '/') {
                    ++this.index;
                    if (this.source.charAt(this.index) === '/') {
                        // Line
                        while (this.source.charAt(++this.index) !== '\n') {
                            if (this.index == this.source.length) return null;
                        }++this.index;
                        ++this.line;
                        repeat = true;
                    } else if ((next = this.source.charAt(this.index)) === '*') {
                        /* Block */
                        do {
                            if (next === '\n') ++this.line;
                            if (++this.index === this.source.length) return null;
                            prev = next;
                            next = this.source.charAt(this.index);
                        } while (prev !== '*' || next !== '/');
                        ++this.index;
                        repeat = true;
                    } else return '/';
                }
            } while (repeat);

            if (this.index === this.source.length) return null;

            // Read the next token
            var end = this.index;
            Lang.DELIM.lastIndex = 0;
            var delim = Lang.DELIM.test(this.source.charAt(end++));
            if (!delim) while (end < this.source.length && !Lang.DELIM.test(this.source.charAt(end))) {
                ++end;
            }var token = this.source.substring(this.index, this.index = end);
            if (token === '"' || token === "'") this._stringOpen = token;
            return token;
        };

        /**
         * Peeks for the next token.
         * @return {?string} Token or `null` on EOF
         * @expose
         */
        TokenizerPrototype.peek = function () {
            if (this.stack.length === 0) {
                var token = this.next();
                if (token === null) return null;
                this.stack.push(token);
            }
            return this.stack[0];
        };

        /**
         * Skips a specific token and throws if it differs.
         * @param {string} expected Expected token
         * @throws {Error} If the actual token differs
         */
        TokenizerPrototype.skip = function (expected) {
            var actual = this.next();
            if (actual !== expected) throw Error("illegal '" + actual + "', '" + expected + "' expected");
        };

        /**
         * Omits an optional token.
         * @param {string} expected Expected optional token
         * @returns {boolean} `true` if the token exists
         */
        TokenizerPrototype.omit = function (expected) {
            if (this.peek() === expected) {
                this.next();
                return true;
            }
            return false;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Tokenizer(index/length)"
         * @expose
         */
        TokenizerPrototype.toString = function () {
            return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")";
        };

        /**
         * @alias ProtoBuf.DotProto.Tokenizer
         * @expose
         */
        DotProto.Tokenizer = Tokenizer;

        /**
         * Constructs a new Parser.
         * @exports ProtoBuf.DotProto.Parser
         * @class prototype parser
         * @param {string} source Source
         * @constructor
         */
        var Parser = function Parser(source) {

            /**
             * Tokenizer.
             * @type {!ProtoBuf.DotProto.Tokenizer}
             * @expose
             */
            this.tn = new Tokenizer(source);

            /**
             * Whether parsing proto3 or not.
             * @type {boolean}
             */
            this.proto3 = false;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser.prototype
         * @inner
         */
        var ParserPrototype = Parser.prototype;

        /**
         * Parses the source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        ParserPrototype.parse = function () {
            var topLevel = {
                "name": "[ROOT]", // temporary
                "package": null,
                "messages": [],
                "enums": [],
                "imports": [],
                "options": {},
                "services": []
                // "syntax": undefined
            };
            var token,
                head = true,
                weak;
            try {
                while (token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!head || topLevel["package"] !== null) throw Error("unexpected 'package'");
                            token = this.tn.next();
                            if (!Lang.TYPEREF.test(token)) throw Error("illegal package name: " + token);
                            this.tn.skip(";");
                            topLevel["package"] = token;
                            break;
                        case 'import':
                            if (!head) throw Error("unexpected 'import'");
                            token = this.tn.peek();
                            if (token === "public" || (weak = token === "weak")) // token ignored
                                this.tn.next();
                            token = this._readString();
                            this.tn.skip(";");
                            if (!weak) // import ignored
                                topLevel["imports"].push(token);
                            break;
                        case 'syntax':
                            if (!head) throw Error("unexpected 'syntax'");
                            this.tn.skip("=");
                            if ((topLevel["syntax"] = this._readString()) === "proto3") this.proto3 = true;
                            this.tn.skip(";");
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null);
                            head = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel);
                            head = false;
                            break;
                        case 'option':
                            this._parseOption(topLevel);
                            break;
                        case 'service':
                            this._parseService(topLevel);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel);
                            break;
                        default:
                            throw Error("unexpected '" + token + "'");
                    }
                }
            } catch (e) {
                e.message = "Parse error at line " + this.tn.line + ": " + e.message;
                throw e;
            }
            delete topLevel["name"];
            return topLevel;
        };

        /**
         * Parses the specified source.
         * @returns {!Object}
         * @throws {Error} If the source cannot be parsed
         * @expose
         */
        Parser.parse = function (source) {
            return new Parser(source).parse();
        };

        // ----- Conversion ------

        /**
         * Converts a numerical string to an id.
         * @param {string} value
         * @param {boolean=} mayBeNegative
         * @returns {number}
         * @inner
         */
        function mkId(value, mayBeNegative) {
            var id = -1,
                sign = 1;
            if (value.charAt(0) == '-') {
                sign = -1;
                value = value.substring(1);
            }
            if (Lang.NUMBER_DEC.test(value)) id = parseInt(value);else if (Lang.NUMBER_HEX.test(value)) id = parseInt(value.substring(2), 16);else if (Lang.NUMBER_OCT.test(value)) id = parseInt(value.substring(1), 8);else throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            id = sign * id | 0; // Force to 32bit
            if (!mayBeNegative && id < 0) throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
            return id;
        }

        /**
         * Converts a numerical string to a number.
         * @param {string} val
         * @returns {number}
         * @inner
         */
        function mkNumber(val) {
            var sign = 1;
            if (val.charAt(0) == '-') {
                sign = -1;
                val = val.substring(1);
            }
            if (Lang.NUMBER_DEC.test(val)) return sign * parseInt(val, 10);else if (Lang.NUMBER_HEX.test(val)) return sign * parseInt(val.substring(2), 16);else if (Lang.NUMBER_OCT.test(val)) return sign * parseInt(val.substring(1), 8);else if (val === 'inf') return sign * Infinity;else if (val === 'nan') return NaN;else if (Lang.NUMBER_FLT.test(val)) return sign * parseFloat(val);
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
        }

        // ----- Reading ------

        /**
         * Reads a string.
         * @returns {string}
         * @private
         */
        ParserPrototype._readString = function () {
            var value = "",
                token,
                delim;
            do {
                delim = this.tn.next();
                if (delim !== "'" && delim !== '"') throw Error("illegal string delimiter: " + delim);
                value += this.tn.next();
                this.tn.skip(delim);
                token = this.tn.peek();
            } while (token === '"' || token === '"'); // multi line?
            return value;
        };

        /**
         * Reads a value.
         * @param {boolean=} mayBeTypeRef
         * @returns {number|boolean|string}
         * @private
         */
        ParserPrototype._readValue = function (mayBeTypeRef) {
            var token = this.tn.peek(),
                value;
            if (token === '"' || token === "'") return this._readString();
            this.tn.next();
            if (Lang.NUMBER.test(token)) return mkNumber(token);
            if (Lang.BOOL.test(token)) return token.toLowerCase() === 'true';
            if (mayBeTypeRef && Lang.TYPEREF.test(token)) return token;
            throw Error("illegal value: " + token);
        };

        // ----- Parsing constructs -----

        /**
         * Parses a namespace option.
         * @param {!Object} parent Parent definition
         * @param {boolean=} isList
         * @private
         */
        ParserPrototype._parseOption = function (parent, isList) {
            var token = this.tn.next(),
                custom = false;
            if (token === '(') {
                custom = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token))
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
                throw Error("illegal option name: " + token);
            var name = token;
            if (custom) {
                // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                this.tn.skip(')');
                name = '(' + name + ')';
                token = this.tn.peek();
                if (Lang.FQTYPEREF.test(token)) {
                    name += token;
                    this.tn.next();
                }
            }
            this.tn.skip('=');
            this._parseOptionValue(parent, name);
            if (!isList) this.tn.skip(";");
        };

        /**
         * Sets an option on the specified options object.
         * @param {!Object.<string,*>} options
         * @param {string} name
         * @param {string|number|boolean} value
         * @inner
         */
        function setOption(options, name, value) {
            if (typeof options[name] === 'undefined') options[name] = value;else {
                if (!Array.isArray(options[name])) options[name] = [options[name]];
                options[name].push(value);
            }
        }

        /**
         * Parses an option value.
         * @param {!Object} parent
         * @param {string} name
         * @private
         */
        ParserPrototype._parseOptionValue = function (parent, name) {
            var token = this.tn.peek();
            if (token !== '{') {
                // Plain value
                setOption(parent["options"], name, this._readValue(true));
            } else {
                // Aggregate options
                this.tn.skip("{");
                while ((token = this.tn.next()) !== '}') {
                    if (!Lang.NAME.test(token)) throw Error("illegal option name: " + name + "." + token);
                    if (this.tn.omit(":")) setOption(parent["options"], name + "." + token, this._readValue(true));else this._parseOptionValue(parent, name + "." + token);
                }
            }
        };

        /**
         * Parses a service definition.
         * @param {!Object} parent Parent definition
         * @private
         */
        ParserPrototype._parseService = function (parent) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal service name at line " + this.tn.line + ": " + token);
            var name = token;
            var svc = {
                "name": name,
                "rpc": {},
                "options": {}
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(svc);else if (token === 'rpc') this._parseServiceRPC(svc);else throw Error("illegal service token: " + token);
            }
            this.tn.omit(";");
            parent["services"].push(svc);
        };

        /**
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
         * @param {!Object} svc Service definition
         * @private
         */
        ParserPrototype._parseServiceRPC = function (svc) {
            var type = "rpc",
                token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal rpc service method name: " + token);
            var name = token;
            var method = {
                "request": null,
                "response": null,
                "request_stream": false,
                "response_stream": false,
                "options": {}
            };
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["request_stream"] = true;
                token = this.tn.next();
            }
            if (!Lang.TYPEREF.test(token)) throw Error("illegal rpc service request type: " + token);
            method["request"] = token;
            this.tn.skip(")");
            token = this.tn.next();
            if (token.toLowerCase() !== "returns") throw Error("illegal rpc service request type delimiter: " + token);
            this.tn.skip("(");
            token = this.tn.next();
            if (token.toLowerCase() === "stream") {
                method["response_stream"] = true;
                token = this.tn.next();
            }
            method["response"] = token;
            this.tn.skip(")");
            token = this.tn.peek();
            if (token === '{') {
                this.tn.next();
                while ((token = this.tn.next()) !== '}') {
                    if (token === 'option') this._parseOption(method);else throw Error("illegal rpc service token: " + token);
                }
                this.tn.omit(";");
            } else this.tn.skip(";");
            if (typeof svc[type] === 'undefined') svc[type] = {};
            svc[type][name] = method;
        };

        /**
         * Parses a message definition.
         * @param {!Object} parent Parent definition
         * @param {!Object=} fld Field definition if this is a group
         * @returns {!Object}
         * @private
         */
        ParserPrototype._parseMessage = function (parent, fld) {
            var isGroup = !!fld,
                token = this.tn.next();
            var msg = {
                "name": "",
                "fields": [],
                "enums": [],
                "messages": [],
                "options": {},
                "services": [],
                "oneofs": {}
                // "extensions": undefined
            };
            if (!Lang.NAME.test(token)) throw Error("illegal " + (isGroup ? "group" : "message") + " name: " + token);
            msg["name"] = token;
            if (isGroup) {
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                msg["isGroup"] = true;
            }
            token = this.tn.peek();
            if (token === '[' && fld) this._parseFieldOptions(fld);
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(msg, token);else if (token === "oneof") this._parseMessageOneOf(msg);else if (token === "enum") this._parseEnum(msg);else if (token === "message") this._parseMessage(msg);else if (token === "option") this._parseOption(msg);else if (token === "service") this._parseService(msg);else if (token === "extensions") {
                    if (msg.hasOwnProperty("extensions")) {
                        msg["extensions"] = msg["extensions"].concat(this._parseExtensionRanges());
                    } else {
                        msg["extensions"] = this._parseExtensionRanges();
                    }
                } else if (token === "reserved") this._parseIgnored(); // TODO
                else if (token === "extend") this._parseExtend(msg);else if (Lang.TYPEREF.test(token)) {
                        if (!this.proto3) throw Error("illegal field rule: " + token);
                        this._parseMessageField(msg, "optional", token);
                    } else throw Error("illegal message token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(msg);
            return msg;
        };

        /**
         * Parses an ignored statement.
         * @private
         */
        ParserPrototype._parseIgnored = function () {
            while (this.tn.peek() !== ';') {
                this.tn.next();
            }this.tn.skip(";");
        };

        /**
         * Parses a message field.
         * @param {!Object} msg Message definition
         * @param {string} rule Field rule
         * @param {string=} type Field type if already known (never known for maps)
         * @returns {!Object} Field descriptor
         * @private
         */
        ParserPrototype._parseMessageField = function (msg, rule, type) {
            if (!Lang.RULE.test(rule)) throw Error("illegal message field rule: " + rule);
            var fld = {
                "rule": rule,
                "type": "",
                "name": "",
                "options": {},
                "id": 0
            };
            var token;
            if (rule === "map") {

                if (type) throw Error("illegal type: " + type);
                this.tn.skip('<');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field type: " + token);
                fld["keytype"] = token;
                this.tn.skip(',');
                token = this.tn.next();
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field: " + token);
                fld["type"] = token;
                this.tn.skip('>');
                token = this.tn.next();
                if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                fld["name"] = token;
                this.tn.skip("=");
                fld["id"] = mkId(this.tn.next());
                token = this.tn.peek();
                if (token === '[') this._parseFieldOptions(fld);
                this.tn.skip(";");
            } else {

                type = typeof type !== 'undefined' ? type : this.tn.next();

                if (type === "group") {

                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    var grp = this._parseMessage(msg, fld);
                    if (!/^[A-Z]/.test(grp["name"])) throw Error('illegal group name: ' + grp["name"]);
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    this.tn.omit(";");
                } else {

                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type)) throw Error("illegal message field type: " + type);
                    fld["type"] = type;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
                    fld["name"] = token;
                    this.tn.skip("=");
                    fld["id"] = mkId(this.tn.next());
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions(fld);
                    this.tn.skip(";");
                }
            }
            msg["fields"].push(fld);
            return fld;
        };

        /**
         * Parses a message oneof.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseMessageOneOf = function (msg) {
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal oneof name: " + token);
            var name = token,
                fld;
            var fields = [];
            this.tn.skip("{");
            while ((token = this.tn.next()) !== "}") {
                fld = this._parseMessageField(msg, "optional", token);
                fld["oneof"] = name;
                fields.push(fld["id"]);
            }
            this.tn.omit(";");
            msg["oneofs"][name] = fields;
        };

        /**
         * Parses a set of field option definitions.
         * @param {!Object} fld Field definition
         * @private
         */
        ParserPrototype._parseFieldOptions = function (fld) {
            this.tn.skip("[");
            var token,
                first = true;
            while ((token = this.tn.peek()) !== ']') {
                if (!first) this.tn.skip(",");
                this._parseOption(fld, true);
                first = false;
            }
            this.tn.next();
        };

        /**
         * Parses an enum.
         * @param {!Object} msg Message definition
         * @private
         */
        ParserPrototype._parseEnum = function (msg) {
            var enm = {
                "name": "",
                "values": [],
                "options": {}
            };
            var token = this.tn.next();
            if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
            enm["name"] = token;
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (token === "option") this._parseOption(enm);else {
                    if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
                    this.tn.skip("=");
                    var val = {
                        "name": token,
                        "id": mkId(this.tn.next(), true)
                    };
                    token = this.tn.peek();
                    if (token === "[") this._parseFieldOptions({ "options": {} });
                    this.tn.skip(";");
                    enm["values"].push(val);
                }
            }
            this.tn.omit(";");
            msg["enums"].push(enm);
        };

        /**
         * Parses extension / reserved ranges.
         * @returns {!Array.<!Array.<number>>}
         * @private
         */
        ParserPrototype._parseExtensionRanges = function () {
            var ranges = [];
            var token, range, value;
            do {
                range = [];
                while (true) {
                    token = this.tn.next();
                    switch (token) {
                        case "min":
                            value = ProtoBuf.ID_MIN;
                            break;
                        case "max":
                            value = ProtoBuf.ID_MAX;
                            break;
                        default:
                            value = mkNumber(token);
                            break;
                    }
                    range.push(value);
                    if (range.length === 2) break;
                    if (this.tn.peek() !== "to") {
                        range.push(value);
                        break;
                    }
                    this.tn.next();
                }
                ranges.push(range);
            } while (this.tn.omit(","));
            this.tn.skip(";");
            return ranges;
        };

        /**
         * Parses an extend block.
         * @param {!Object} parent Parent object
         * @private
         */
        ParserPrototype._parseExtend = function (parent) {
            var token = this.tn.next();
            if (!Lang.TYPEREF.test(token)) throw Error("illegal extend reference: " + token);
            var ext = {
                "ref": token,
                "fields": []
            };
            this.tn.skip("{");
            while ((token = this.tn.next()) !== '}') {
                if (Lang.RULE.test(token)) this._parseMessageField(ext, token);else if (Lang.TYPEREF.test(token)) {
                    if (!this.proto3) throw Error("illegal field rule: " + token);
                    this._parseMessageField(ext, "optional", token);
                } else throw Error("illegal extend token: " + token);
            }
            this.tn.omit(";");
            parent["messages"].push(ext);
            return ext;
        };

        // ----- General -----

        /**
         * Returns a string representation of this parser.
         * @returns {string}
         */
        ParserPrototype.toString = function () {
            return "Parser at line " + this.tn.line;
        };

        /**
         * @alias ProtoBuf.DotProto.Parser
         * @expose
         */
        DotProto.Parser = Parser;

        return DotProto;
    }(ProtoBuf, ProtoBuf.Lang);

    /**
     * @alias ProtoBuf.Reflect
     * @expose
     */
    ProtoBuf.Reflect = function (ProtoBuf) {
        "use strict";

        /**
         * Reflection types.
         * @exports ProtoBuf.Reflect
         * @namespace
         */

        var Reflect = {};

        /**
         * Constructs a Reflect base class.
         * @exports ProtoBuf.Reflect.T
         * @constructor
         * @abstract
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         */
        var T = function T(builder, parent, name) {

            /**
             * Builder reference.
             * @type {!ProtoBuf.Builder}
             * @expose
             */
            this.builder = builder;

            /**
             * Parent object.
             * @type {?ProtoBuf.Reflect.T}
             * @expose
             */
            this.parent = parent;

            /**
             * Object name in namespace.
             * @type {string}
             * @expose
             */
            this.name = name;

            /**
             * Fully qualified class name
             * @type {string}
             * @expose
             */
            this.className;
        };

        /**
         * @alias ProtoBuf.Reflect.T.prototype
         * @inner
         */
        var TPrototype = T.prototype;

        /**
         * Returns the fully qualified name of this object.
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
         * @expose
         */
        TPrototype.fqn = function () {
            var name = this.name,
                ptr = this;
            do {
                ptr = ptr.parent;
                if (ptr == null) break;
                name = ptr.name + "." + name;
            } while (true);
            return name;
        };

        /**
         * Returns a string representation of this Reflect object (its fully qualified name).
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
         * @return String representation
         * @expose
         */
        TPrototype.toString = function (includeClass) {
            return (includeClass ? this.className + " " : "") + this.fqn();
        };

        /**
         * Builds this type.
         * @throws {Error} If this type cannot be built directly
         * @expose
         */
        TPrototype.build = function () {
            throw Error(this.toString(true) + " cannot be built directly");
        };

        /**
         * @alias ProtoBuf.Reflect.T
         * @expose
         */
        Reflect.T = T;

        /**
         * Constructs a new Namespace.
         * @exports ProtoBuf.Reflect.Namespace
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
         * @param {string} name Namespace name
         * @param {Object.<string,*>=} options Namespace options
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Namespace = function Namespace(builder, parent, name, options, syntax) {
            T.call(this, builder, parent, name);

            /**
             * @override
             */
            this.className = "Namespace";

            /**
             * Children inside the namespace.
             * @type {!Array.<ProtoBuf.Reflect.T>}
             */
            this.children = [];

            /**
             * Options.
             * @type {!Object.<string, *>}
             */
            this.options = options || {};

            /**
             * Syntax level (e.g., proto2 or proto3).
             * @type {!string}
             */
            this.syntax = syntax || "proto2";
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace.prototype
         * @inner
         */
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);

        /**
         * Returns an array of the namespace's children.
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}
         * @expose
         */
        NamespacePrototype.getChildren = function (type) {
            type = type || null;
            if (type == null) return this.children.slice();
            var children = [];
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i] instanceof type) children.push(this.children[i]);
            }return children;
        };

        /**
         * Adds a child to the namespace.
         * @param {ProtoBuf.Reflect.T} child Child
         * @throws {Error} If the child cannot be added (duplicate)
         * @expose
         */
        NamespacePrototype.addChild = function (child) {
            var other;
            if (other = this.getChild(child.name)) {
                // Try to revert camelcase transformation on collision
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null) other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null) child.name = child.originalName;else throw Error("Duplicate name in namespace " + this.toString(true) + ": " + child.name);
            }
            this.children.push(child);
        };

        /**
         * Gets a child by its name or id.
         * @param {string|number} nameOrId Child name or id
         * @return {?ProtoBuf.Reflect.T} The child or null if not found
         * @expose
         */
        NamespacePrototype.getChild = function (nameOrId) {
            var key = typeof nameOrId === 'number' ? 'id' : 'name';
            for (var i = 0, k = this.children.length; i < k; ++i) {
                if (this.children[i][key] === nameOrId) return this.children[i];
            }return null;
        };

        /**
         * Resolves a reflect object inside of this namespace.
         * @param {string|!Array.<string>} qn Qualified name to resolve
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
         * @expose
         */
        NamespacePrototype.resolve = function (qn, excludeNonNamespace) {
            var part = typeof qn === 'string' ? qn.split(".") : qn,
                ptr = this,
                i = 0;
            if (part[i] === "") {
                // Fully qualified name, e.g. ".My.Message'
                while (ptr.parent !== null) {
                    ptr = ptr.parent;
                }i++;
            }
            var child;
            do {
                do {
                    if (!(ptr instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    child = ptr.getChild(part[i]);
                    if (!child || !(child instanceof Reflect.T) || excludeNonNamespace && !(child instanceof Reflect.Namespace)) {
                        ptr = null;
                        break;
                    }
                    ptr = child;i++;
                } while (i < part.length);
                if (ptr != null) break; // Found
                // Else search the parent
                if (this.parent !== null) return this.parent.resolve(qn, excludeNonNamespace);
            } while (ptr != null);
            return ptr;
        };

        /**
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
         * @param {!ProtoBuf.Reflect.T} t Reflection type
         * @returns {string} The shortest qualified name or, if there is none, the fqn
         * @expose
         */
        NamespacePrototype.qn = function (t) {
            var part = [],
                ptr = t;
            do {
                part.unshift(ptr.name);
                ptr = ptr.parent;
            } while (ptr !== null);
            for (var len = 1; len <= part.length; len++) {
                var qn = part.slice(part.length - len);
                if (t === this.resolve(qn, t instanceof Reflect.Namespace)) return qn.join(".");
            }
            return t.fqn();
        };

        /**
         * Builds the namespace and returns the runtime counterpart.
         * @return {Object.<string,Function|Object>} Runtime namespace
         * @expose
         */
        NamespacePrototype.build = function () {
            /** @dict */
            var ns = {};
            var children = this.children;
            for (var i = 0, k = children.length, child; i < k; ++i) {
                child = children[i];
                if (child instanceof Namespace) ns[child.name] = child.build();
            }
            if (Object.defineProperty) Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
            return ns;
        };

        /**
         * Builds the namespace's '$options' property.
         * @return {Object.<string,*>}
         */
        NamespacePrototype.buildOpt = function () {
            var opt = {},
                keys = Object.keys(this.options);
            for (var i = 0, k = keys.length; i < k; ++i) {
                var key = keys[i],
                    val = this.options[keys[i]];
                // TODO: Options are not resolved, yet.
                // if (val instanceof Namespace) {
                //     opt[key] = val.build();
                // } else {
                opt[key] = val;
                // }
            }
            return opt;
        };

        /**
         * Gets the value assigned to the option with the specified name.
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
         */
        NamespacePrototype.getOption = function (name) {
            if (typeof name === 'undefined') return this.options;
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
        };

        /**
         * @alias ProtoBuf.Reflect.Namespace
         * @expose
         */
        Reflect.Namespace = Namespace;

        /**
         * Constructs a new Element implementation that checks and converts values for a
         * particular field type, as appropriate.
         *
         * An Element represents a single value: either the value of a singular field,
         * or a value contained in one entry of a repeated field or map field. This
         * class does not implement these higher-level concepts; it only encapsulates
         * the low-level typechecking and conversion.
         *
         * @exports ProtoBuf.Reflect.Element
         * @param {{name: string, wireType: number}} type Resolved data type
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
         * (e.g. submessage field).
         * @param {boolean} isMapKey Is this element a Map key? The value will be
         * converted to string form if so.
         * @param {string} syntax Syntax level of defining message type, e.g.,
         * proto2 or proto3.
         * @param {string} name Name of the field containing this element (for error
         * messages)
         * @constructor
         */
        var Element = function Element(type, resolvedType, isMapKey, syntax, name) {

            /**
             * Element type, as a string (e.g., int32).
             * @type {{name: string, wireType: number}}
             */
            this.type = type;

            /**
             * Element type reference to submessage or enum definition, if needed.
             * @type {ProtoBuf.Reflect.T|null}
             */
            this.resolvedType = resolvedType;

            /**
             * Element is a map key.
             * @type {boolean}
             */
            this.isMapKey = isMapKey;

            /**
             * Syntax level of defining message type, e.g., proto2 or proto3.
             * @type {string}
             */
            this.syntax = syntax;

            /**
             * Name of the field containing this element (for error messages)
             * @type {string}
             */
            this.name = name;

            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0) throw Error("Invalid map key type: " + type.name);
        };

        var ElementPrototype = Element.prototype;

        /**
         * Obtains a (new) default value for the specified type.
         * @param type {string|{name: string, wireType: number}} Field type
         * @returns {*} Default value
         * @inner
         */
        function mkDefault(type) {
            if (typeof type === 'string') type = ProtoBuf.TYPES[type];
            if (typeof type.defaultValue === 'undefined') throw Error("default value for type " + type.name + " is not supported");
            if (type == ProtoBuf.TYPES["bytes"]) return new ByteBuffer(0);
            return type.defaultValue;
        }

        /**
         * Returns the default value for this field in proto3.
         * @function
         * @param type {string|{name: string, wireType: number}} the field type
         * @returns {*} Default value
         */
        Element.defaultFieldValue = mkDefault;

        /**
         * Makes a Long from a value.
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers
         * @returns {!Long}
         * @throws {Error} If the value cannot be converted to a Long
         * @inner
         */
        function mkLong(value, unsigned) {
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean' && value.low === value.low && value.high === value.high) return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string') return ProtoBuf.Long.fromString(value, unsigned || false, 10);
            if (typeof value === 'number') return ProtoBuf.Long.fromNumber(value, unsigned || false);
            throw Error("not convertible to Long");
        }

        ElementPrototype.toString = function () {
            return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';
        };

        /**
         * Checks if the given value can be set for an element of this type (singular
         * field or one element of a repeated field or map).
         * @param {*} value Value to check
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be verified for this element slot
         * @expose
         */
        ElementPrototype.verifyValue = function (value) {
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            switch (this.type) {
                // Signed 32bit
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                    // Account for !NaN: value === value
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value > 4294967295 ? value | 0 : value;

                // Unsigned 32bit
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                    return value < 0 ? value >>> 0 : value;

                // Signed 64bit
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, false);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Unsigned 64bit
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    {
                        if (ProtoBuf.Long) try {
                            return mkLong(value, true);
                        } catch (e) {
                            fail(typeof value === "undefined" ? "undefined" : _typeof(value), e.message);
                        } else fail(typeof value === "undefined" ? "undefined" : _typeof(value), "requires Long.js");
                    }

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value !== 'boolean') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a boolean");
                    return value;

                // Float
                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    if (typeof value !== 'number') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a number");
                    return value;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    if (typeof value !== 'string' && !(value && value instanceof String)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not a string");
                    return "" + value; // Convert String object to string

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (ByteBuffer.isByteBuffer(value)) return value;
                    return ByteBuffer.wrap(value, "base64");

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    {
                        var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
                        for (i = 0; i < values.length; i++) {
                            if (values[i].name == value) return values[i].id;else if (values[i].id == value) return values[i].id;
                        }if (this.syntax === 'proto3') {
                            // proto3: just make sure it's an integer.
                            if (typeof value !== 'number' || value === value && value % 1 !== 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not an integer");
                            if (value > 4294967295 || value < 0) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "not in range for uint32");
                            return value;
                        } else {
                            // proto2 requires enum values to be valid.
                            fail(value, "not a valid enum value");
                        }
                    }
                // Embedded message
                case ProtoBuf.TYPES["group"]:
                case ProtoBuf.TYPES["message"]:
                    {
                        if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== 'object') fail(typeof value === "undefined" ? "undefined" : _typeof(value), "object expected");
                        if (value instanceof this.resolvedType.clazz) return value;
                        if (value instanceof ProtoBuf.Builder.Message) {
                            // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                            var obj = {};
                            for (var i in value) {
                                if (value.hasOwnProperty(i)) obj[i] = value[i];
                            }value = obj;
                        }
                        // Else let's try to construct one from a key-value object
                        return new this.resolvedType.clazz(value); // May throw for a hundred of reasons
                    }
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal value for " + this.toString(true) + ": " + value + " (undefined type " + this.type + ")");
        };

        /**
         * Calculates the byte length of an element on the wire.
         * @param {number} id Field number
         * @param {*} value Field value
         * @returns {number} Byte length
         * @throws {Error} If the value cannot be calculated
         * @expose
         */
        ElementPrototype.calculateLength = function (id, value) {
            if (value === null) return 0; // Nothing to encode
            // Tag has already been written
            var n;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["uint32"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["sint32"]:
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                case ProtoBuf.TYPES["fixed32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["float"]:
                    return 4;
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    return ByteBuffer.calculateVarint64(value);
                case ProtoBuf.TYPES["sint64"]:
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                case ProtoBuf.TYPES["fixed64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                    return 8;
                case ProtoBuf.TYPES["bool"]:
                    return 1;
                case ProtoBuf.TYPES["enum"]:
                    return ByteBuffer.calculateVarint32(value);
                case ProtoBuf.TYPES["double"]:
                    return 8;
                case ProtoBuf.TYPES["string"]:
                    n = ByteBuffer.calculateUTF8Bytes(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                case ProtoBuf.TYPES["message"]:
                    n = this.resolvedType.calculate(value);
                    return ByteBuffer.calculateVarint32(n) + n;
                case ProtoBuf.TYPES["group"]:
                    n = this.resolvedType.calculate(value);
                    return n + ByteBuffer.calculateVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
            }
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
        };

        /**
         * Encodes a value to the specified buffer. Does not encode the key.
         * @param {number} id Field number
         * @param {*} value Field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the value cannot be encoded
         * @expose
         */
        ElementPrototype.encodeValue = function (id, value, buffer) {
            if (value === null) return buffer; // Nothing to encode
            // Tag has already been written

            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long – it is, effectively, treated like a very large unsigned integer." (see #122)
                    if (value < 0) buffer.writeVarint64(value);else buffer.writeVarint32(value);
                    break;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    buffer.writeVarint32ZigZag(value);
                    break;

                // Fixed unsigned 32bit
                case ProtoBuf.TYPES["fixed32"]:
                    buffer.writeUint32(value);
                    break;

                // Fixed signed 32bit
                case ProtoBuf.TYPES["sfixed32"]:
                    buffer.writeInt32(value);
                    break;

                // 64bit varint as-is
                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["uint64"]:
                    buffer.writeVarint64(value); // throws
                    break;

                // 64bit varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    buffer.writeVarint64ZigZag(value); // throws
                    break;

                // Fixed unsigned 64bit
                case ProtoBuf.TYPES["fixed64"]:
                    buffer.writeUint64(value); // throws
                    break;

                // Fixed signed 64bit
                case ProtoBuf.TYPES["sfixed64"]:
                    buffer.writeInt64(value); // throws
                    break;

                // Bool
                case ProtoBuf.TYPES["bool"]:
                    if (typeof value === 'string') buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);else buffer.writeVarint32(value ? 1 : 0);
                    break;

                // Constant enum value
                case ProtoBuf.TYPES["enum"]:
                    buffer.writeVarint32(value);
                    break;

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    buffer.writeFloat32(value);
                    break;

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    buffer.writeFloat64(value);
                    break;

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    buffer.writeVString(value);
                    break;

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                    var prevOffset = value.offset;
                    buffer.writeVarint32(value.remaining());
                    buffer.append(value);
                    value.offset = prevOffset;
                    break;

                // Embedded message
                case ProtoBuf.TYPES["message"]:
                    var bb = new ByteBuffer().LE();
                    this.resolvedType.encode(value, bb);
                    buffer.writeVarint32(bb.offset);
                    buffer.append(bb.flip());
                    break;

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    this.resolvedType.encode(value, buffer);
                    buffer.writeVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
                    break;

                default:
                    // We should never end here
                    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
            }
            return buffer;
        };

        /**
         * Decode one element value from the specified buffer.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number} wireType The field wire type
         * @param {number} id The field number
         * @return {*} Decoded value
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        ElementPrototype.decode = function (buffer, wireType, id) {
            if (wireType != this.type.wireType) throw Error("Unexpected wire type for element");

            var value, nBytes;
            switch (this.type) {
                // 32bit signed varint
                case ProtoBuf.TYPES["int32"]:
                    return buffer.readVarint32() | 0;

                // 32bit unsigned varint
                case ProtoBuf.TYPES["uint32"]:
                    return buffer.readVarint32() >>> 0;

                // 32bit signed varint zig-zag
                case ProtoBuf.TYPES["sint32"]:
                    return buffer.readVarint32ZigZag() | 0;

                // Fixed 32bit unsigned
                case ProtoBuf.TYPES["fixed32"]:
                    return buffer.readUint32() >>> 0;

                case ProtoBuf.TYPES["sfixed32"]:
                    return buffer.readInt32() | 0;

                // 64bit signed varint
                case ProtoBuf.TYPES["int64"]:
                    return buffer.readVarint64();

                // 64bit unsigned varint
                case ProtoBuf.TYPES["uint64"]:
                    return buffer.readVarint64().toUnsigned();

                // 64bit signed varint zig-zag
                case ProtoBuf.TYPES["sint64"]:
                    return buffer.readVarint64ZigZag();

                // Fixed 64bit unsigned
                case ProtoBuf.TYPES["fixed64"]:
                    return buffer.readUint64();

                // Fixed 64bit signed
                case ProtoBuf.TYPES["sfixed64"]:
                    return buffer.readInt64();

                // Bool varint
                case ProtoBuf.TYPES["bool"]:
                    return !!buffer.readVarint32();

                // Constant enum value (varint)
                case ProtoBuf.TYPES["enum"]:
                    // The following Builder.Message#set will already throw
                    return buffer.readVarint32();

                // 32bit float
                case ProtoBuf.TYPES["float"]:
                    return buffer.readFloat();

                // 64bit float
                case ProtoBuf.TYPES["double"]:
                    return buffer.readDouble();

                // Length-delimited string
                case ProtoBuf.TYPES["string"]:
                    return buffer.readVString();

                // Length-delimited bytes
                case ProtoBuf.TYPES["bytes"]:
                    {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset + nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                // Length-delimited embedded message
                case ProtoBuf.TYPES["message"]:
                    {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                // Legacy group
                case ProtoBuf.TYPES["group"]:
                    return this.resolvedType.decode(buffer, -1, id);
            }

            // We should never end here
            throw Error("[INTERNAL] Illegal decode type");
        };

        /**
         * Converts a value from a string to the canonical element type.
         *
         * Legal only when isMapKey is true.
         *
         * @param {string} str The string value
         * @returns {*} The value
         */
        ElementPrototype.valueFromString = function (str) {
            if (!this.isMapKey) {
                throw Error("valueFromString() called on non-map-key element");
            }

            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return this.verifyValue(parseInt(str));

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    // Long-based fields support conversions from string already.
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bool"]:
                    return str === "true";

                case ProtoBuf.TYPES["string"]:
                    return this.verifyValue(str);

                case ProtoBuf.TYPES["bytes"]:
                    return ByteBuffer.fromBinary(str);
            }
        };

        /**
         * Converts a value from the canonical element type to a string.
         *
         * It should be the case that `valueFromString(valueToString(val))` returns
         * a value equivalent to `verifyValue(val)` for every legal value of `val`
         * according to this element type.
         *
         * This may be used when the element must be stored or used as a string,
         * e.g., as a map key on an Object.
         *
         * Legal only when isMapKey is true.
         *
         * @param {*} val The value
         * @returns {string} The string form of the value.
         */
        ElementPrototype.valueToString = function (value) {
            if (!this.isMapKey) {
                throw Error("valueToString() called on non-map-key element");
            }

            if (this.type === ProtoBuf.TYPES["bytes"]) {
                return value.toString("binary");
            } else {
                return value.toString();
            }
        };

        /**
         * @alias ProtoBuf.Reflect.Element
         * @expose
         */
        Reflect.Element = Element;

        /**
         * Constructs a new Message.
         * @exports ProtoBuf.Reflect.Message
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
         * @param {string} name Message name
         * @param {Object.<string,*>=} options Message options
         * @param {boolean=} isGroup `true` if this is a legacy group
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Message = function Message(builder, parent, name, options, isGroup, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Message";

            /**
             * Extensions range.
             * @type {!Array.<number>|undefined}
             * @expose
             */
            this.extensions = undefined;

            /**
             * Runtime message class.
             * @type {?function(new:ProtoBuf.Builder.Message)}
             * @expose
             */
            this.clazz = null;

            /**
             * Whether this is a legacy group or not.
             * @type {boolean}
             * @expose
             */
            this.isGroup = !!isGroup;

            // The following cached collections are used to efficiently iterate over or look up fields when decoding.

            /**
             * Cached fields.
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fields = null;

            /**
             * Cached fields by id.
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsById = null;

            /**
             * Cached fields by name.
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
             * @private
             */
            this._fieldsByName = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Message.prototype
         * @inner
         */
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the message and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Message
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
         * @return {ProtoBuf.Reflect.Message} Message class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        MessagePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Message class in its own scope
            var clazz = function (ProtoBuf, T) {

                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);

                /**
                 * Constructs a new runtime Message.
                 * @name ProtoBuf.Builder.Message
                 * @class Barebone of all runtime messages.
                 * @param {!Object.<string,*>|string} values Preset values
                 * @param {...string} var_args
                 * @constructor
                 * @throws {Error} If the message cannot be created
                 */
                var Message = function Message(values, var_args) {
                    ProtoBuf.Builder.Message.call(this);

                    // Create virtual oneof properties
                    for (var i = 0, k = oneofs.length; i < k; ++i) {
                        this[oneofs[i].name] = null;
                    } // Create fields and set default values
                    for (i = 0, k = fields.length; i < k; ++i) {
                        var field = fields[i];
                        this[field.name] = field.repeated ? [] : field.map ? new ProtoBuf.Map(field) : null;
                        if ((field.required || T.syntax === 'proto3') && field.defaultValue !== null) this[field.name] = field.defaultValue;
                    }

                    if (arguments.length > 0) {
                        var value;
                        // Set field values from a values object
                        if (arguments.length === 1 && values !== null && (typeof values === "undefined" ? "undefined" : _typeof(values)) === 'object' && (
                        /* not _another_ Message */typeof values.encode !== 'function' || values instanceof Message) &&
                        /* not a repeated field */!Array.isArray(values) &&
                        /* not a Map */!(values instanceof ProtoBuf.Map) &&
                        /* not a ByteBuffer */!ByteBuffer.isByteBuffer(values) &&
                        /* not an ArrayBuffer */!(values instanceof ArrayBuffer) &&
                        /* not a Long */!(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            this.$set(values);
                        } else // Set field values from arguments, in declaration order
                            for (i = 0, k = arguments.length; i < k; ++i) {
                                if (typeof (value = arguments[i]) !== 'undefined') this.$set(fields[i].name, value);
                            } // May throw
                    }
                };

                /**
                 * @alias ProtoBuf.Builder.Message.prototype
                 * @inner
                 */
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                /**
                 * Adds a value to a repeated field.
                 * @name ProtoBuf.Builder.Message#add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.add = function (key, value, noAssert) {
                    var field = T._fieldsByName[key];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + key + " is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated) throw Error(this + "#" + key + " is not a repeated field");
                        value = field.verifyValue(value, true);
                    }
                    if (this[key] === null) this[key] = [];
                    this[key].push(value);
                    return this;
                };

                /**
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                 * @name ProtoBuf.Builder.Message#$add
                 * @function
                 * @param {string} key Field name
                 * @param {*} value Value to add
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be added
                 * @expose
                 */
                MessagePrototype.$add = MessagePrototype.add;

                /**
                 * Sets a field's value.
                 * @name ProtoBuf.Builder.Message#set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.set = function (keyOrObj, value, noAssert) {
                    if (keyOrObj && (typeof keyOrObj === "undefined" ? "undefined" : _typeof(keyOrObj)) === 'object') {
                        noAssert = value;
                        for (var ikey in keyOrObj) {
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined') this.$set(ikey, value, noAssert);
                        }return this;
                    }
                    var field = T._fieldsByName[keyOrObj];
                    if (!noAssert) {
                        if (!field) throw Error(this + "#" + keyOrObj + " is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + keyOrObj + " is not a field: " + field.toString(true));
                        this[field.name] = value = field.verifyValue(value); // May throw
                    } else this[keyOrObj] = value;
                    if (field && field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field
                        if (value !== null) {
                            if (currentField !== null && currentField !== field.name) this[currentField] = null; // Clear currently set field
                            this[field.oneof.name] = field.name; // Point virtual field at this field
                        } else if ( /* value === null && */currentField === keyOrObj) this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)
                    }
                    return this;
                };

                /**
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                 * @name ProtoBuf.Builder.Message#$set
                 * @function
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                 * @throws {Error} If the value cannot be set
                 * @expose
                 */
                MessagePrototype.$set = MessagePrototype.set;

                /**
                 * Gets a field's value.
                 * @name ProtoBuf.Builder.Message#get
                 * @function
                 * @param {string} key Key
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.get = function (key, noAssert) {
                    if (noAssert) return this[key];
                    var field = T._fieldsByName[key];
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: undefined");
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true));
                    return this[field.name];
                };

                /**
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                 * @name ProtoBuf.Builder.Message#$get
                 * @function
                 * @param {string} key Key
                 * @return {*} Value
                 * @throws {Error} If there is no such field
                 * @expose
                 */
                MessagePrototype.$get = MessagePrototype.get;

                // Getters and setters

                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    // no setters for extension fields as these are named by their fqn
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField) continue;

                    if (T.builder.options['populateAccessors']) (function (field) {
                        // set/get[SomeValue]
                        var Name = field.originalName.replace(/(_[a-zA-Z])/g, function (match) {
                            return match.toUpperCase().replace('_', '');
                        });
                        Name = Name.substring(0, 1).toUpperCase() + Name.substring(1);

                        // set/get_[some_value] FIXME: Do we really need these?
                        var name = field.originalName.replace(/([A-Z])/g, function (match) {
                            return "_" + match;
                        });

                        /**
                         * The current field's unbound setter function.
                         * @function
                         * @param {*} value
                         * @param {boolean=} noAssert
                         * @returns {!ProtoBuf.Builder.Message}
                         * @inner
                         */
                        var setter = function setter(value, noAssert) {
                            this[field.name] = noAssert ? value : field.verifyValue(value);
                            return this;
                        };

                        /**
                         * The current field's unbound getter function.
                         * @function
                         * @returns {*}
                         * @inner
                         */
                        var getter = function getter() {
                            return this[field.name];
                        };

                        if (T.getChild("set" + Name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set" + Name] = setter;

                        if (T.getChild("set_" + name) === null)
                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
                             * @returns {!ProtoBuf.Builder.Message} this
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            MessagePrototype["set_" + name] = setter;

                        if (T.getChild("get" + Name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            MessagePrototype["get" + Name] = getter;

                        if (T.getChild("get_" + name) === null)
                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             *  another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            MessagePrototype["get_" + name] = getter;
                    })(field);
                }

                // En-/decoding

                /**
                 * Encodes the message.
                 * @name ProtoBuf.Builder.Message#$encode
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message#encode64
                 * @see ProtoBuf.Builder.Message#encodeHex
                 * @see ProtoBuf.Builder.Message#encodeAB
                 */
                MessagePrototype.encode = function (buffer, noVerify) {
                    if (typeof buffer === 'boolean') noVerify = buffer, buffer = undefined;
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var le = buffer.littleEndian;
                    try {
                        T.encode(this, buffer.LE(), noVerify);
                        return (isNew ? buffer.flip() : buffer).LE(le);
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Encodes a message using the specified data payload.
                 * @param {!Object.<string,*>} data Data payload
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @expose
                 */
                Message.encode = function (data, buffer, noVerify) {
                    return new Message(data).encode(buffer, noVerify);
                };

                /**
                 * Calculates the byte length of the message.
                 * @name ProtoBuf.Builder.Message#calculate
                 * @function
                 * @returns {number} Byte length
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.
                 * @expose
                 */
                MessagePrototype.calculate = function () {
                    return T.calculate(this);
                };

                /**
                 * Encodes the varint32 length-delimited message.
                 * @name ProtoBuf.Builder.Message#encodeDelimited
                 * @function
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeDelimited = function (buffer, noVerify) {
                    var isNew = false;
                    if (!buffer) buffer = new ByteBuffer(), isNew = true;
                    var enc = new ByteBuffer().LE();
                    T.encode(this, enc, noVerify).flip();
                    buffer.writeVarint32(enc.remaining());
                    buffer.append(enc);
                    return isNew ? buffer.flip() : buffer;
                };

                /**
                 * Directly encodes the message to an ArrayBuffer.
                 * @name ProtoBuf.Builder.Message#encodeAB
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeAB = function () {
                    try {
                        return this.encode().toArrayBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer
                 * @function
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;

                /**
                 * Directly encodes the message to a node Buffer.
                 * @name ProtoBuf.Builder.Message#encodeNB
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeNB = function () {
                    try {
                        return this.encode().toBuffer();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer
                 * @function
                 * @return {!Buffer}
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;

                /**
                 * Directly encodes the message to a base64 encoded string.
                 * @name ProtoBuf.Builder.Message#encode64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encode64 = function () {
                    try {
                        return this.encode().toBase64();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64
                 * @function
                 * @return {string} Base64 encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toBase64 = MessagePrototype.encode64;

                /**
                 * Directly encodes the message to a hex encoded string.
                 * @name ProtoBuf.Builder.Message#encodeHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.encodeHex = function () {
                    try {
                        return this.encode().toHex();
                    } catch (e) {
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                        throw e;
                    }
                };

                /**
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex
                 * @function
                 * @return {string} Hex encoded string
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.
                 * @expose
                 */
                MessagePrototype.toHex = MessagePrototype.encodeHex;

                /**
                 * Clones a message object or field value to a raw object.
                 * @param {*} obj Object to clone
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
                 * @returns {*} Cloned object
                 * @inner
                 */
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
                    if (obj === null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== 'object') {
                        // Convert enum values to their respective names
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
                            if (name !== null) return name;
                        }
                        // Pass-through string, number, boolean, null...
                        return obj;
                    }
                    // Convert ByteBuffers to raw buffer or strings
                    if (ByteBuffer.isByteBuffer(obj)) return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();
                    // Convert Longs to proper objects or strings
                    if (ProtoBuf.Long.isLong(obj)) return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
                    var clone;
                    // Clone arrays
                    if (Array.isArray(obj)) {
                        clone = [];
                        obj.forEach(function (v, k) {
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                        });
                        return clone;
                    }
                    clone = {};
                    // Convert maps to objects
                    if (obj instanceof ProtoBuf.Map) {
                        var it = obj.entries();
                        for (var e = it.next(); !e.done; e = it.next()) {
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        }return clone;
                    }
                    // Everything else is a non-null object
                    var type = obj.$type,
                        field = undefined;
                    for (var i in obj) {
                        if (obj.hasOwnProperty(i)) {
                            if (type && (field = type.getChild(i))) clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);else clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
                        }
                    }return clone;
                }

                /**
                 * Returns the message's raw payload.
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings
                 * @returns {Object.<string,*>} Raw payload
                 * @expose
                 */
                MessagePrototype.toRaw = function (binaryAsBase64, longsAsStrings) {
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                };

                /**
                 * Encodes a message to JSON.
                 * @returns {string} JSON string
                 * @expose
                 */
                MessagePrototype.encodeJSON = function () {
                    return JSON.stringify(cloneRaw(this,
                    /* binary-as-base64 */true,
                    /* longs-as-strings */true, this.$type));
                };

                /**
                 * Decodes a message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decode
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 * @see ProtoBuf.Builder.Message.decode64
                 * @see ProtoBuf.Builder.Message.decodeHex
                 */
                Message.decode = function (buffer, length, enc) {
                    if (typeof length === 'string') enc = length, length = -1;
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    var le = buffer.littleEndian;
                    try {
                        var msg = T.decode(buffer.LE(), length);
                        buffer.LE(le);
                        return msg;
                    } catch (e) {
                        buffer.LE(le);
                        throw e;
                    }
                };

                /**
                 * Decodes a varint32 length-delimited message from the specified buffer or string.
                 * @name ProtoBuf.Builder.Message.decodeDelimited
                 * @function
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeDelimited = function (buffer, enc) {
                    if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");else if (!ByteBuffer.isByteBuffer(buffer)) buffer = ByteBuffer.wrap(buffer); // May throw
                    if (buffer.remaining() < 1) return null;
                    var off = buffer.offset,
                        len = buffer.readVarint32();
                    if (buffer.remaining() < len) {
                        buffer.offset = off;
                        return null;
                    }
                    try {
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    } catch (err) {
                        buffer.offset += len;
                        throw err;
                    }
                };

                /**
                 * Decodes the message from the specified base64 encoded string.
                 * @name ProtoBuf.Builder.Message.decode64
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decode64 = function (str) {
                    return Message.decode(str, "base64");
                };

                /**
                 * Decodes the message from the specified hex encoded string.
                 * @name ProtoBuf.Builder.Message.decodeHex
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.
                 * @expose
                 */
                Message.decodeHex = function (str) {
                    return Message.decode(str, "hex");
                };

                /**
                 * Decodes the message from a JSON string.
                 * @name ProtoBuf.Builder.Message.decodeJSON
                 * @function
                 * @param {string} str String to decode from
                 * @return {!ProtoBuf.Builder.Message} Decoded message
                 * @throws {Error} If the message cannot be decoded or if required fields are
                 * missing.
                 * @expose
                 */
                Message.decodeJSON = function (str) {
                    return new Message(JSON.parse(str));
                };

                // Utility

                /**
                 * Returns a string representation of this Message.
                 * @name ProtoBuf.Builder.Message#toString
                 * @function
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"
                 * @expose
                 */
                MessagePrototype.toString = function () {
                    return T.toString();
                };

                // Properties

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Message options.
                 * @name ProtoBuf.Builder.Message#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message.$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Message#$type
                 * @type {!ProtoBuf.Reflect.Message}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Message, '$options', { "value": T.buildOpt() }), Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }), Object.defineProperty(Message, "$type", { "value": T }), Object.defineProperty(MessagePrototype, "$type", { "value": T });

                return Message;
            }(ProtoBuf, this);

            // Static enums and prototyped sub-messages / cached collections
            this._fields = [];
            this._fieldsById = {};
            this._fieldsByName = {};
            for (var i = 0, k = this.children.length, child; i < k; i++) {
                child = this.children[i];
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                    if (clazz.hasOwnProperty(child.name)) throw Error("Illegal reflect child of " + this.toString(true) + ": " + child.toString(true) + " cannot override static property '" + child.name + "'");
                    clazz[child.name] = child.build();
                } else if (child instanceof Message.Field) child.build(), this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child;else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
                    throw Error("Illegal reflect child of " + this.toString(true) + ": " + this.children[i].toString(true));
            }

            return this.clazz = clazz;
        };

        /**
         * Encodes a runtime message's contents to the specified buffer.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @param {ByteBuffer} buffer ByteBuffer to write to
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
         * @expose
         */
        MessagePrototype.encode = function (message, buffer, noVerify) {
            var fieldMissing = null,
                field;
            for (var i = 0, k = this._fields.length, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) {
                    if (fieldMissing === null) fieldMissing = field;
                } else field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
            }
            if (fieldMissing !== null) {
                var err = Error("Missing at least one required field for " + this.toString(true) + ": " + fieldMissing);
                err["encoded"] = buffer; // Still expose what we got
                throw err;
            }
            return buffer;
        };

        /**
         * Calculates a runtime message's byte length.
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
         * @returns {number} Byte length
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
         * @expose
         */
        MessagePrototype.calculate = function (message) {
            for (var n = 0, i = 0, k = this._fields.length, field, val; i < k; ++i) {
                field = this._fields[i];
                val = message[field.name];
                if (field.required && val === null) throw Error("Missing at least one required field for " + this.toString(true) + ": " + field);else n += field.calculate(val, message);
            }
            return n;
        };

        /**
         * Skips all data until the end of the specified group has been reached.
         * @param {number} expectedId Expected GROUPEND id
         * @param {!ByteBuffer} buf ByteBuffer
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
         * @inner
         */
        function skipTillGroupEnd(expectedId, buf) {
            var tag = buf.readVarint32(),
                // Throws on OOB
            wireType = tag & 0x07,
                id = tag >>> 3;
            switch (wireType) {
                case ProtoBuf.WIRE_TYPES.VARINT:
                    do {
                        tag = buf.readUint8();
                    } while ((tag & 0x80) === 0x80);
                    break;
                case ProtoBuf.WIRE_TYPES.BITS64:
                    buf.offset += 8;
                    break;
                case ProtoBuf.WIRE_TYPES.LDELIM:
                    tag = buf.readVarint32(); // reads the varint
                    buf.offset += tag; // skips n bytes
                    break;
                case ProtoBuf.WIRE_TYPES.STARTGROUP:
                    skipTillGroupEnd(id, buf);
                    break;
                case ProtoBuf.WIRE_TYPES.ENDGROUP:
                    if (id === expectedId) return false;else throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");
                case ProtoBuf.WIRE_TYPES.BITS32:
                    buf.offset += 4;
                    break;
                default:
                    throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
            }
            return true;
        }

        /**
         * Decodes an encoded message and returns the decoded message.
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {number=} length Message length. Defaults to decode all remaining data.
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
         * @return {ProtoBuf.Builder.Message} Decoded message
         * @throws {Error} If the message cannot be decoded
         * @expose
         */
        MessagePrototype.decode = function (buffer, length, expectedGroupEndId) {
            if (typeof length !== 'number') length = -1;
            var start = buffer.offset,
                msg = new this.clazz(),
                tag,
                wireType,
                id,
                field;
            while (buffer.offset < start + length || length === -1 && buffer.remaining() > 0) {
                tag = buffer.readVarint32();
                wireType = tag & 0x07;
                id = tag >>> 3;
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                    if (id !== expectedGroupEndId) throw Error("Illegal group end indicator for " + this.toString(true) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
                    break;
                }
                if (!(field = this._fieldsById[id])) {
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {
                        case ProtoBuf.WIRE_TYPES.VARINT:
                            buffer.readVarint32();
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS32:
                            buffer.offset += 4;
                            break;
                        case ProtoBuf.WIRE_TYPES.BITS64:
                            buffer.offset += 8;
                            break;
                        case ProtoBuf.WIRE_TYPES.LDELIM:
                            var len = buffer.readVarint32();
                            buffer.offset += len;
                            break;
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            while (skipTillGroupEnd(id, buffer)) {}
                            break;
                        default:
                            throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(true) + "#decode: " + wireType);
                    }
                    continue;
                }
                if (field.repeated && !field.options["packed"]) {
                    msg[field.name].push(field.decode(wireType, buffer));
                } else if (field.map) {
                    var keyval = field.decode(wireType, buffer);
                    msg[field.name].set(keyval[0], keyval[1]);
                } else {
                    msg[field.name] = field.decode(wireType, buffer);
                    if (field.oneof) {
                        // Field is part of an OneOf (not a virtual OneOf field)
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field
                        if (currentField !== null && currentField !== field.name) msg[currentField] = null; // Clear currently set field
                        msg[field.oneof.name] = field.name; // Point virtual field at this field
                    }
                }
            }

            // Check if all required fields are present and set default values for optional fields that are not
            for (var i = 0, k = this._fields.length; i < k; ++i) {
                field = this._fields[i];
                if (msg[field.name] === null) {
                    if (this.syntax === "proto3") {
                        // Proto3 sets default values by specification
                        msg[field.name] = field.defaultValue;
                    } else if (field.required) {
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got
                        throw err;
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null) msg[field.name] = field.defaultValue;
                }
            }
            return msg;
        };

        /**
         * @alias ProtoBuf.Reflect.Message
         * @expose
         */
        Reflect.Message = Message;

        /**
         * Constructs a new Message Field.
         * @exports ProtoBuf.Reflect.Message.Field
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string?} keytype Key data type, if any.
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {Object.<string,*>=} options Options
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Field = function Field(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
            T.call(this, builder, message, name);

            /**
             * @override
             */
            this.className = "Message.Field";

            /**
             * Message field required flag.
             * @type {boolean}
             * @expose
             */
            this.required = rule === "required";

            /**
             * Message field repeated flag.
             * @type {boolean}
             * @expose
             */
            this.repeated = rule === "repeated";

            /**
             * Message field map flag.
             * @type {boolean}
             * @expose
             */
            this.map = rule === "map";

            /**
             * Message field key type. Type reference string if unresolved, protobuf
             * type if resolved. Valid only if this.map === true, null otherwise.
             * @type {string|{name: string, wireType: number}|null}
             * @expose
             */
            this.keyType = keytype || null;

            /**
             * Message field type. Type reference string if unresolved, protobuf type if
             * resolved. In a map field, this is the value type.
             * @type {string|{name: string, wireType: number}}
             * @expose
             */
            this.type = type;

            /**
             * Resolved type reference inside the global namespace.
             * @type {ProtoBuf.Reflect.T|null}
             * @expose
             */
            this.resolvedType = null;

            /**
             * Unique message field id.
             * @type {number}
             * @expose
             */
            this.id = id;

            /**
             * Message field options.
             * @type {!Object.<string,*>}
             * @dict
             * @expose
             */
            this.options = options || {};

            /**
             * Default value.
             * @type {*}
             * @expose
             */
            this.defaultValue = null;

            /**
             * Enclosing OneOf.
             * @type {?ProtoBuf.Reflect.Message.OneOf}
             * @expose
             */
            this.oneof = oneof || null;

            /**
             * Syntax level of this definition (e.g., proto3).
             * @type {string}
             * @expose
             */
            this.syntax = syntax || 'proto2';

            /**
             * Original field name.
             * @type {string}
             * @expose
             */
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

            /**
             * Element implementation. Created in build() after types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.element = null;

            /**
             * Key element implementation, for map fields. Created in build() after
             * types are resolved.
             * @type {ProtoBuf.Element}
             * @expose
             */
            this.keyElement = null;

            // Convert field names to camel case notation if the override is set
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField)) this.name = ProtoBuf.Util.toCamelCase(this.name);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field.prototype
         * @inner
         */
        var FieldPrototype = Field.prototype = Object.create(T.prototype);

        /**
         * Builds the field.
         * @override
         * @expose
         */
        FieldPrototype.build = function () {
            this.element = new Element(this.type, this.resolvedType, false, this.syntax, this.name);
            if (this.map) this.keyElement = new Element(this.keyType, undefined, true, this.syntax, this.name);

            // In proto3, fields do not have field presence, and every field is set to
            // its type's default value ("", 0, 0.0, or false).
            if (this.syntax === 'proto3' && !this.repeated && !this.map) this.defaultValue = Element.defaultFieldValue(this.type);

            // Otherwise, default values are present when explicitly specified
            else if (typeof this.options['default'] !== 'undefined') this.defaultValue = this.verifyValue(this.options['default']);
        };

        /**
         * Checks if the given value can be set for this field.
         * @param {*} value Value to check
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
         * @return {*} Verified, maybe adjusted, value
         * @throws {Error} If the value cannot be set for this field
         * @expose
         */
        FieldPrototype.verifyValue = function (value, skipRepeated) {
            skipRepeated = skipRepeated || false;
            var self = this;
            function fail(val, msg) {
                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
            }
            if (value === null) {
                // NULL values for optional fields
                if (this.required) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "required");
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"]) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "proto3 field without field presence cannot be null");
                return null;
            }
            var i;
            if (this.repeated && !skipRepeated) {
                // Repeated values as arrays
                if (!Array.isArray(value)) value = [value];
                var res = [];
                for (i = 0; i < value.length; i++) {
                    res.push(this.element.verifyValue(value[i]));
                }return res;
            }
            if (this.map && !skipRepeated) {
                // Map values as objects
                if (!(value instanceof ProtoBuf.Map)) {
                    // If not already a Map, attempt to convert.
                    if (!(value instanceof Object)) {
                        fail(typeof value === "undefined" ? "undefined" : _typeof(value), "expected ProtoBuf.Map or raw object for map field");
                    }
                    return new ProtoBuf.Map(this, value);
                } else {
                    return value;
                }
            }
            // All non-repeated fields expect no array
            if (!this.repeated && Array.isArray(value)) fail(typeof value === "undefined" ? "undefined" : _typeof(value), "no array expected");

            return this.element.verifyValue(value);
        };

        /**
         * Determines whether the field will have a presence on the wire given its
         * value.
         * @param {*} value Verified field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {boolean} Whether the field will be present on the wire
         */
        FieldPrototype.hasWirePresence = function (value, message) {
            if (this.syntax !== 'proto3') return value !== null;
            if (this.oneof && message[this.oneof.name] === this.name) return true;
            switch (this.type) {
                case ProtoBuf.TYPES["int32"]:
                case ProtoBuf.TYPES["sint32"]:
                case ProtoBuf.TYPES["sfixed32"]:
                case ProtoBuf.TYPES["uint32"]:
                case ProtoBuf.TYPES["fixed32"]:
                    return value !== 0;

                case ProtoBuf.TYPES["int64"]:
                case ProtoBuf.TYPES["sint64"]:
                case ProtoBuf.TYPES["sfixed64"]:
                case ProtoBuf.TYPES["uint64"]:
                case ProtoBuf.TYPES["fixed64"]:
                    return value.low !== 0 || value.high !== 0;

                case ProtoBuf.TYPES["bool"]:
                    return value;

                case ProtoBuf.TYPES["float"]:
                case ProtoBuf.TYPES["double"]:
                    return value !== 0.0;

                case ProtoBuf.TYPES["string"]:
                    return value.length > 0;

                case ProtoBuf.TYPES["bytes"]:
                    return value.remaining() > 0;

                case ProtoBuf.TYPES["enum"]:
                    return value !== 0;

                case ProtoBuf.TYPES["message"]:
                    return value !== null;
                default:
                    return true;
            }
        };

        /**
         * Encodes the specified field value to the specified buffer.
         * @param {*} value Verified field value
         * @param {ByteBuffer} buffer ByteBuffer to encode to
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @return {ByteBuffer} The ByteBuffer for chaining
         * @throws {Error} If the field cannot be encoded
         * @expose
         */
        FieldPrototype.encode = function (value, buffer, message) {
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return buffer; // Optional omitted
            try {
                if (this.repeated) {
                    var i;
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin
                        for (i = 0; i < value.length; i++) {
                            this.element.encodeValue(this.id, value[i], buffer);
                        }var len = buffer.offset - start,
                            varintLen = ByteBuffer.calculateVarint32(len);
                        if (varintLen > 1) {
                            // We need to move the contents
                            var contents = buffer.slice(start, buffer.offset);
                            start += varintLen - 1;
                            buffer.offset = start;
                            buffer.append(contents);
                        }
                        buffer.writeVarint32(len, start - varintLen);
                    } else {
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"
                        for (i = 0; i < value.length; i++) {
                            buffer.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, value[i], buffer);
                        }
                    }
                } else if (this.map) {
                    // Write out each map entry as a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        // Submessage with wire type of length-delimited.
                        buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        buffer.writeVarint32(length);

                        // Write out the key and val.
                        buffer.writeVarint32(1 << 3 | this.keyType.wireType);
                        this.keyElement.encodeValue(1, key, buffer);
                        buffer.writeVarint32(2 << 3 | this.type.wireType);
                        this.element.encodeValue(2, val, buffer);
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        buffer.writeVarint32(this.id << 3 | this.type.wireType);
                        this.element.encodeValue(this.id, value, buffer);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return buffer;
        };

        /**
         * Calculates the length of this field's value on the network level.
         * @param {*} value Field value
         * @param {!ProtoBuf.Builder.Message} message Runtime message
         * @returns {number} Byte length
         * @expose
         */
        FieldPrototype.calculate = function (value, message) {
            value = this.verifyValue(value); // May throw
            if (this.type === null || _typeof(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
            if (value === null || this.repeated && value.length == 0) return 0; // Optional omitted
            var n = 0;
            try {
                if (this.repeated) {
                    var i, ni;
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        ni = 0;
                        for (i = 0; i < value.length; i++) {
                            ni += this.element.calculateLength(this.id, value[i]);
                        }n += ByteBuffer.calculateVarint32(ni);
                        n += ni;
                    } else {
                        for (i = 0; i < value.length; i++) {
                            n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), n += this.element.calculateLength(this.id, value[i]);
                        }
                    }
                } else if (this.map) {
                    // Each map entry becomes a submessage.
                    value.forEach(function (val, key, m) {
                        // Compute the length of the submessage (key, val) pair.
                        var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);

                        n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
                        n += ByteBuffer.calculateVarint32(length);
                        n += length;
                    }, this);
                } else {
                    if (this.hasWirePresence(value, message)) {
                        n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType);
                        n += this.element.calculateLength(this.id, value);
                    }
                }
            } catch (e) {
                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
            }
            return n;
        };

        /**
         * Decode the field value from the specified buffer.
         * @param {number} wireType Leading wire type
         * @param {ByteBuffer} buffer ByteBuffer to decode from
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for
         *             map fields, or an individual value otherwise.
         * @throws {Error} If the field cannot be decoded
         * @expose
         */
        FieldPrototype.decode = function (wireType, buffer, skipRepeated) {
            var value, nBytes;

            // We expect wireType to match the underlying type's wireType unless we see
            // a packed repeated field, or unless this is a map field.
            var wireTypeOK = !this.map && wireType == this.type.wireType || !skipRepeated && this.repeated && this.options["packed"] && wireType == ProtoBuf.WIRE_TYPES.LDELIM || this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM;
            if (!wireTypeOK) throw Error("Illegal wire type for field " + this.toString(true) + ": " + wireType + " (" + this.type.wireType + " expected)");

            // Handle packed repeated fields.
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {
                    nBytes = buffer.readVarint32();
                    nBytes = buffer.offset + nBytes; // Limit
                    var values = [];
                    while (buffer.offset < nBytes) {
                        values.push(this.decode(this.type.wireType, buffer, true));
                    }return values;
                }
                // Read the next value otherwise...
            }

            // Handle maps.
            if (this.map) {
                // Read one (key, value) submessage, and return [key, value]
                var key = Element.defaultFieldValue(this.keyType);
                value = Element.defaultFieldValue(this.type);

                // Read the length
                nBytes = buffer.readVarint32();
                if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());

                // Get a sub-buffer of this key/value submessage
                var msgbuf = buffer.clone();
                msgbuf.limit = msgbuf.offset + nBytes;
                buffer.offset += nBytes;

                while (msgbuf.remaining() > 0) {
                    var tag = msgbuf.readVarint32();
                    wireType = tag & 0x07;
                    var id = tag >>> 3;
                    if (id === 1) {
                        key = this.keyElement.decode(msgbuf, wireType, id);
                    } else if (id === 2) {
                        value = this.element.decode(msgbuf, wireType, id);
                    } else {
                        throw Error("Unexpected tag in map field key/value submessage");
                    }
                }

                return [key, value];
            }

            // Handle singular and non-packed repeated field values.
            return this.element.decode(buffer, wireType, this.id);
        };

        /**
         * @alias ProtoBuf.Reflect.Message.Field
         * @expose
         */
        Reflect.Message.Field = Field;

        /**
         * Constructs a new Message ExtensionField.
         * @exports ProtoBuf.Reflect.Message.ExtensionField
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} rule Rule, one of requried, optional, repeated
         * @param {string} type Data type, e.g. int32
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @param {!Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Message.Field
         */
        var ExtensionField = function ExtensionField(builder, message, rule, type, name, id, options) {
            Field.call(this, builder, message, rule, /* keytype = */null, type, name, id, options);

            /**
             * Extension reference.
             * @type {!ProtoBuf.Reflect.Extension}
             * @expose
             */
            this.extension;
        };

        // Extends Field
        ExtensionField.prototype = Object.create(Field.prototype);

        /**
         * @alias ProtoBuf.Reflect.Message.ExtensionField
         * @expose
         */
        Reflect.Message.ExtensionField = ExtensionField;

        /**
         * Constructs a new Message OneOf.
         * @exports ProtoBuf.Reflect.Message.OneOf
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Message} message Message reference
         * @param {string} name OneOf name
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var OneOf = function OneOf(builder, message, name) {
            T.call(this, builder, message, name);

            /**
             * Enclosed fields.
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
             * @expose
             */
            this.fields = [];
        };

        /**
         * @alias ProtoBuf.Reflect.Message.OneOf
         * @expose
         */
        Reflect.Message.OneOf = OneOf;

        /**
         * Constructs a new Enum.
         * @exports ProtoBuf.Reflect.Enum
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
         * @param {string} name Enum name
         * @param {Object.<string,*>=} options Enum options
         * @param {string?} syntax The syntax level (e.g., proto3)
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Enum = function Enum(builder, parent, name, options, syntax) {
            Namespace.call(this, builder, parent, name, options, syntax);

            /**
             * @override
             */
            this.className = "Enum";

            /**
             * Runtime enum object.
             * @type {Object.<string,number>|null}
             * @expose
             */
            this.object = null;
        };

        /**
         * Gets the string name of an enum value.
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
         * @param {number} value Enum value
         * @returns {?string} Name or `null` if not present
         * @expose
         */
        Enum.getName = function (enm, value) {
            var keys = Object.keys(enm);
            for (var i = 0, key; i < keys.length; ++i) {
                if (enm[key = keys[i]] === value) return key;
            }return null;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum.prototype
         * @inner
         */
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);

        /**
         * Builds this enum and returns the runtime counterpart.
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false
         * @returns {!Object.<string,number>}
         * @expose
         */
        EnumPrototype.build = function (rebuild) {
            if (this.object && !rebuild) return this.object;
            var enm = new ProtoBuf.Builder.Enum(),
                values = this.getChildren(Enum.Value);
            for (var i = 0, k = values.length; i < k; ++i) {
                enm[values[i]['name']] = values[i]['id'];
            }if (Object.defineProperty) Object.defineProperty(enm, '$options', {
                "value": this.buildOpt(),
                "enumerable": false
            });
            return this.object = enm;
        };

        /**
         * @alias ProtoBuf.Reflect.Enum
         * @expose
         */
        Reflect.Enum = Enum;

        /**
         * Constructs a new Enum Value.
         * @exports ProtoBuf.Reflect.Enum.Value
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
         * @param {string} name Field name
         * @param {number} id Unique field id
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Value = function Value(builder, enm, name, id) {
            T.call(this, builder, enm, name);

            /**
             * @override
             */
            this.className = "Enum.Value";

            /**
             * Unique enum value id.
             * @type {number}
             * @expose
             */
            this.id = id;
        };

        // Extends T
        Value.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Enum.Value
         * @expose
         */
        Reflect.Enum.Value = Value;

        /**
         * An extension (field).
         * @exports ProtoBuf.Reflect.Extension
         * @constructor
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.T} parent Parent object
         * @param {string} name Object name
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
         */
        var Extension = function Extension(builder, parent, name, field) {
            T.call(this, builder, parent, name);

            /**
             * Extended message field.
             * @type {!ProtoBuf.Reflect.Message.Field}
             * @expose
             */
            this.field = field;
        };

        // Extends T
        Extension.prototype = Object.create(T.prototype);

        /**
         * @alias ProtoBuf.Reflect.Extension
         * @expose
         */
        Reflect.Extension = Extension;

        /**
         * Constructs a new Service.
         * @exports ProtoBuf.Reflect.Service
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Namespace} root Root
         * @param {string} name Service name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Namespace
         */
        var Service = function Service(builder, root, name, options) {
            Namespace.call(this, builder, root, name, options);

            /**
             * @override
             */
            this.className = "Service";

            /**
             * Built runtime service class.
             * @type {?function(new:ProtoBuf.Builder.Service)}
             */
            this.clazz = null;
        };

        /**
         * @alias ProtoBuf.Reflect.Service.prototype
         * @inner
         */
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);

        /**
         * Builds the service and returns the runtime counterpart, which is a fully functional class.
         * @see ProtoBuf.Builder.Service
         * @param {boolean=} rebuild Whether to rebuild or not
         * @return {Function} Service class
         * @throws {Error} If the message cannot be built
         * @expose
         */
        ServicePrototype.build = function (rebuild) {
            if (this.clazz && !rebuild) return this.clazz;

            // Create the runtime Service class in its own scope
            return this.clazz = function (ProtoBuf, T) {

                /**
                 * Constructs a new runtime Service.
                 * @name ProtoBuf.Builder.Service
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.
                 * @constructor
                 * @throws {Error} If the service cannot be created
                 */
                var Service = function Service(rpcImpl) {
                    ProtoBuf.Builder.Service.call(this);

                    /**
                     * Service implementation.
                     * @name ProtoBuf.Builder.Service#rpcImpl
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose
                     */
                    this.rpcImpl = rpcImpl || function (name, msg, callback) {
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first
                        // argument or null and the actual response message.
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };
                };

                /**
                 * @alias ProtoBuf.Builder.Service.prototype
                 * @inner
                 */
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                /**
                 * Asynchronously performs an RPC call using the given RPC implementation.
                 * @name ProtoBuf.Builder.Service.[Method]
                 * @function
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                /**
                 * Asynchronously performs an RPC call using the instance's RPC implementation.
                 * @name ProtoBuf.Builder.Service#[Method]
                 * @function
                 * @param {ProtoBuf.Builder.Message} req Request
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes
                 * @abstract
                 */

                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                for (var i = 0; i < rpc.length; i++) {
                    (function (method) {

                        // service#Method(message, callback)
                        ServicePrototype[method.name] = function (req, callback) {
                            try {
                                try {
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
                                } catch (err) {
                                    if (!(err instanceof TypeError)) throw err;
                                }
                                if (req === null || (typeof req === "undefined" ? "undefined" : _typeof(req)) !== 'object') throw Error("Illegal arguments");
                                if (!(req instanceof method.resolvedRequestType.clazz)) req = new method.resolvedRequestType.clazz(req);
                                this.rpcImpl(method.fqn(), req, function (err, res) {
                                    // Assumes that this is properly async
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    // Coalesce to empty string when service response has empty content
                                    if (res === null) res = '';
                                    try {
                                        res = method.resolvedResponseType.clazz.decode(res);
                                    } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                        callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                                        return;
                                    }
                                    callback(null, res);
                                });
                            } catch (err) {
                                setTimeout(callback.bind(this, err), 0);
                            }
                        };

                        // Service.Method(rpcImpl, message, callback)
                        Service[method.name] = function (rpcImpl, req, callback) {
                            new Service(rpcImpl)[method.name](req, callback);
                        };

                        if (Object.defineProperty) Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }), Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);
                }

                // Properties

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service.$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $optionsS; // cc needs this

                /**
                 * Service options.
                 * @name ProtoBuf.Builder.Service#$options
                 * @type {Object.<string,*>}
                 * @expose
                 */
                var $options;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service.$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $typeS;

                /**
                 * Reflection type.
                 * @name ProtoBuf.Builder.Service#$type
                 * @type {!ProtoBuf.Reflect.Service}
                 * @expose
                 */
                var $type;

                if (Object.defineProperty) Object.defineProperty(Service, "$options", { "value": T.buildOpt() }), Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }), Object.defineProperty(Service, "$type", { "value": T }), Object.defineProperty(ServicePrototype, "$type", { "value": T });

                return Service;
            }(ProtoBuf, this);
        };

        /**
         * @alias ProtoBuf.Reflect.Service
         * @expose
         */
        Reflect.Service = Service;

        /**
         * Abstract service method.
         * @exports ProtoBuf.Reflect.Service.Method
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.T
         */
        var Method = function Method(builder, svc, name, options) {
            T.call(this, builder, svc, name);

            /**
             * @override
             */
            this.className = "Service.Method";

            /**
             * Options.
             * @type {Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Reflect.Service.Method.prototype
         * @inner
         */
        var MethodPrototype = Method.prototype = Object.create(T.prototype);

        /**
         * Builds the method's '$options' property.
         * @name ProtoBuf.Reflect.Service.Method#buildOpt
         * @function
         * @return {Object.<string,*>}
         */
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;

        /**
         * @alias ProtoBuf.Reflect.Service.Method
         * @expose
         */
        Reflect.Service.Method = Method;

        /**
         * RPC service method.
         * @exports ProtoBuf.Reflect.Service.RPCMethod
         * @param {!ProtoBuf.Builder} builder Builder reference
         * @param {!ProtoBuf.Reflect.Service} svc Service
         * @param {string} name Method name
         * @param {string} request Request message name
         * @param {string} response Response message name
         * @param {boolean} request_stream Whether requests are streamed
         * @param {boolean} response_stream Whether responses are streamed
         * @param {Object.<string,*>=} options Options
         * @constructor
         * @extends ProtoBuf.Reflect.Service.Method
         */
        var RPCMethod = function RPCMethod(builder, svc, name, request, response, request_stream, response_stream, options) {
            Method.call(this, builder, svc, name, options);

            /**
             * @override
             */
            this.className = "Service.RPCMethod";

            /**
             * Request message name.
             * @type {string}
             * @expose
             */
            this.requestName = request;

            /**
             * Response message name.
             * @type {string}
             * @expose
             */
            this.responseName = response;

            /**
             * Whether requests are streamed
             * @type {bool}
             * @expose
             */
            this.requestStream = request_stream;

            /**
             * Whether responses are streamed
             * @type {bool}
             * @expose
             */
            this.responseStream = response_stream;

            /**
             * Resolved request message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedRequestType = null;

            /**
             * Resolved response message type.
             * @type {ProtoBuf.Reflect.Message}
             * @expose
             */
            this.resolvedResponseType = null;
        };

        // Extends Method
        RPCMethod.prototype = Object.create(Method.prototype);

        /**
         * @alias ProtoBuf.Reflect.Service.RPCMethod
         * @expose
         */
        Reflect.Service.RPCMethod = RPCMethod;

        return Reflect;
    }(ProtoBuf);

    /**
     * @alias ProtoBuf.Builder
     * @expose
     */
    ProtoBuf.Builder = function (ProtoBuf, Lang, Reflect) {
        "use strict";

        /**
         * Constructs a new Builder.
         * @exports ProtoBuf.Builder
         * @class Provides the functionality to build protocol messages.
         * @param {Object.<string,*>=} options Options
         * @constructor
         */

        var Builder = function Builder(options) {

            /**
             * Namespace.
             * @type {ProtoBuf.Reflect.Namespace}
             * @expose
             */
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

            /**
             * Namespace pointer.
             * @type {ProtoBuf.Reflect.T}
             * @expose
             */
            this.ptr = this.ns;

            /**
             * Resolved flag.
             * @type {boolean}
             * @expose
             */
            this.resolved = false;

            /**
             * The current building result.
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
             * @expose
             */
            this.result = null;

            /**
             * Imported files.
             * @type {Array.<string>}
             * @expose
             */
            this.files = {};

            /**
             * Import root override.
             * @type {?string}
             * @expose
             */
            this.importRoot = null;

            /**
             * Options.
             * @type {!Object.<string, *>}
             * @expose
             */
            this.options = options || {};
        };

        /**
         * @alias ProtoBuf.Builder.prototype
         * @inner
         */
        var BuilderPrototype = Builder.prototype;

        // ----- Definition tests -----

        /**
         * Tests if a definition most likely describes a message.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessage = function (def) {
            // Messages require a string name
            if (typeof def["name"] !== 'string') return false;
            // Messages do not contain values (enum) or rpc methods (service)
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a message field.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isMessageField = function (def) {
            // Message fields require a string rule, name and type and an id
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined') return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an enum.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isEnum = function (def) {
            // Enums require a string name
            if (typeof def["name"] !== 'string') return false;
            // Enums require at least one value
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes a service.
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isService = function (def) {
            // Services require a string name and an rpc object
            if (typeof def["name"] !== 'string' || _typeof(def["rpc"]) !== 'object' || !def["rpc"]) return false;
            return true;
        };

        /**
         * Tests if a definition most likely describes an extended message
         * @param {!Object} def
         * @returns {boolean}
         * @expose
         */
        Builder.isExtend = function (def) {
            // Extends rquire a string ref
            if (typeof def["ref"] !== 'string') return false;
            return true;
        };

        // ----- Building -----

        /**
         * Resets the pointer to the root namespace.
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.reset = function () {
            this.ptr = this.ns;
            return this;
        };

        /**
         * Defines a namespace on top of the current pointer position and places the pointer on it.
         * @param {string} namespace
         * @return {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.define = function (namespace) {
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace)) throw Error("illegal namespace: " + namespace);
            namespace.split(".").forEach(function (part) {
                var ns = this.ptr.getChild(part);
                if (ns === null) // Keep existing
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
                this.ptr = ns;
            }, this);
            return this;
        };

        /**
         * Creates the specified definitions at the current pointer position.
         * @param {!Array.<!Object>} defs Messages, enums or services to create
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If a message definition is invalid
         * @expose
         */
        BuilderPrototype.create = function (defs) {
            if (!defs) return this; // Nothing to create
            if (!Array.isArray(defs)) defs = [defs];else {
                if (defs.length === 0) return this;
                defs = defs.slice();
            }

            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
            var stack = [defs];
            while (stack.length > 0) {
                defs = stack.pop();

                if (!Array.isArray(defs)) // Stack always contains entire namespaces
                    throw Error("not a valid namespace: " + JSON.stringify(defs));

                while (defs.length > 0) {
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

                    if (Builder.isMessage(def)) {
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);

                        // Create OneOfs
                        var oneofs = {};
                        if (def["oneofs"]) Object.keys(def["oneofs"]).forEach(function (name) {
                            obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                        }, this);

                        // Create fields
                        if (def["fields"]) def["fields"].forEach(function (fld) {
                            if (obj.getChild(fld["id"] | 0) !== null) throw Error("duplicate or invalid field id in " + obj.name + ": " + fld['id']);
                            if (fld["options"] && _typeof(fld["options"]) !== 'object') throw Error("illegal field options in " + obj.name + "#" + fld["name"]);
                            var oneof = null;
                            if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]])) throw Error("illegal oneof in " + obj.name + "#" + fld["name"] + ": " + fld["oneof"]);
                            fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                            if (oneof) oneof.fields.push(fld);
                            obj.addChild(fld);
                        }, this);

                        // Push children to stack
                        var subObj = [];
                        if (def["enums"]) def["enums"].forEach(function (enm) {
                            subObj.push(enm);
                        });
                        if (def["messages"]) def["messages"].forEach(function (msg) {
                            subObj.push(msg);
                        });
                        if (def["services"]) def["services"].forEach(function (svc) {
                            subObj.push(svc);
                        });

                        // Set extension ranges
                        if (def["extensions"]) {
                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
                                obj.extensions = [def["extensions"]];else obj.extensions = def["extensions"];
                        }

                        // Create on top of current namespace
                        this.ptr.addChild(obj);
                        if (subObj.length > 0) {
                            stack.push(defs); // Push the current level back
                            defs = subObj; // Continue processing sub level
                            subObj = null;
                            this.ptr = obj; // And move the pointer to this namespace
                            obj = null;
                            continue;
                        }
                        subObj = null;
                    } else if (Builder.isEnum(def)) {

                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
                        def["values"].forEach(function (val) {
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isService(def)) {

                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
                        Object.keys(def["rpc"]).forEach(function (name) {
                            var mtd = def["rpc"][name];
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);
                        this.ptr.addChild(obj);
                    } else if (Builder.isExtend(def)) {

                        obj = this.ptr.resolve(def["ref"], true);
                        if (obj) {
                            def["fields"].forEach(function (fld) {
                                if (obj.getChild(fld['id'] | 0) !== null) throw Error("duplicate extended field id in " + obj.name + ": " + fld['id']);
                                // Check if field id is allowed to be extended
                                if (obj.extensions) {
                                    var valid = false;
                                    obj.extensions.forEach(function (range) {
                                        if (fld["id"] >= range[0] && fld["id"] <= range[1]) valid = true;
                                    });
                                    if (!valid) throw Error("illegal extended field id in " + obj.name + ": " + fld['id'] + " (not within valid ranges)");
                                }
                                // Convert extension field names to camel case notation if the override is set
                                var name = fld["name"];
                                if (this.options['convertFieldsToCamelCase']) name = ProtoBuf.Util.toCamelCase(name);
                                // see #161: Extensions use their fully qualified name as their runtime key and...
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn() + '.' + name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for
                                // resolving their type later on (the extension always keeps the original name to
                                // prevent naming collisions)
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
                                field.extension = ext;
                                this.ptr.addChild(ext);
                                obj.addChild(field);
                            }, this);
                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                            throw Error("extended message " + def["ref"] + " is not defined");
                    } else throw Error("not a valid definition: " + JSON.stringify(def));

                    def = null;
                    obj = null;
                }
                // Break goes here
                defs = null;
                this.ptr = this.ptr.parent; // Namespace done, continue at parent
            }
            this.resolved = false; // Require re-resolve
            this.result = null; // Require re-build
            return this;
        };

        /**
         * Propagates syntax to all children.
         * @param {!Object} parent
         * @inner
         */
        function propagateSyntax(parent) {
            if (parent['messages']) {
                parent['messages'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                    propagateSyntax(child);
                });
            }
            if (parent['enums']) {
                parent['enums'].forEach(function (child) {
                    child["syntax"] = parent["syntax"];
                });
            }
        }

        /**
         * Imports another definition into this builder.
         * @param {Object.<string,*>} json Parsed import
         * @param {(string|{root: string, file: string})=} filename Imported file name
         * @returns {!ProtoBuf.Builder} this
         * @throws {Error} If the definition or file cannot be imported
         * @expose
         */
        BuilderPrototype["import"] = function (json, filename) {
            var delim = '/';

            // Make sure to skip duplicate imports

            if (typeof filename === 'string') {

                if (ProtoBuf.Util.IS_NODE) filename = require("path")['resolve'](filename);
                if (this.files[filename] === true) return this.reset();
                this.files[filename] = true;
            } else if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                // Object with root, file.

                var root = filename.root;
                if (ProtoBuf.Util.IS_NODE) root = require("path")['resolve'](root);
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0) delim = '\\';
                var fname = root + delim + filename.file;
                if (this.files[fname] === true) return this.reset();
                this.files[fname] = true;
            }

            // Import imports

            if (json['imports'] && json['imports'].length > 0) {
                var importRoot,
                    resetRoot = false;

                if ((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object') {
                    // If an import root is specified, override

                    this.importRoot = filename["root"];resetRoot = true; // ... and reset afterwards
                    importRoot = this.importRoot;
                    filename = filename["file"];
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                } else if (typeof filename === 'string') {

                    if (this.importRoot) // If import root is overridden, use it
                        importRoot = this.importRoot;else {
                        // Otherwise compute from filename
                        if (filename.indexOf("/") >= 0) {
                            // Unix
                            importRoot = filename.replace(/\/[^\/]*$/, "");
                            if ( /* /file.proto */importRoot === "") importRoot = "/";
                        } else if (filename.indexOf("\\") >= 0) {
                            // Windows
                            importRoot = filename.replace(/\\[^\\]*$/, "");
                            delim = '\\';
                        } else importRoot = ".";
                    }
                } else importRoot = null;

                for (var i = 0; i < json['imports'].length; i++) {
                    if (typeof json['imports'][i] === 'string') {
                        // Import file
                        if (!importRoot) throw Error("cannot determine import root");
                        var importFilename = json['imports'][i];
                        if (importFilename === "google/protobuf/descriptor.proto") continue; // Not needed and therefore not used
                        importFilename = importRoot + delim + importFilename;
                        if (this.files[importFilename] === true) continue; // Already imported
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto) // If this is a light build
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);
                        if (contents === null) throw Error("failed to import '" + importFilename + "' in '" + filename + "': file not found");
                        if (/\.json$/i.test(importFilename)) // Always possible
                            this["import"](JSON.parse(contents + ""), importFilename); // May throw
                        else this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                    } else // Import structure
                        if (!filename) this["import"](json['imports'][i]);else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function ($0, $1, $2) {
                                return $1 + "_import" + i + "." + $2;
                            }));else // Without extension: Append _importN to make it unique
                            this["import"](json['imports'][i], filename + "_import" + i);
                }
                if (resetRoot) // Reset import root override when all imports are done
                    this.importRoot = null;
            }

            // Import structures

            if (json['package']) this.define(json['package']);
            if (json['syntax']) propagateSyntax(json);
            var base = this.ptr;
            if (json['options']) Object.keys(json['options']).forEach(function (key) {
                base.options[key] = json['options'][key];
            });
            if (json['messages']) this.create(json['messages']), this.ptr = base;
            if (json['enums']) this.create(json['enums']), this.ptr = base;
            if (json['services']) this.create(json['services']), this.ptr = base;
            if (json['extends']) this.create(json['extends']);

            return this.reset();
        };

        /**
         * Resolves all namespace objects.
         * @throws {Error} If a type cannot be resolved
         * @returns {!ProtoBuf.Builder} this
         * @expose
         */
        BuilderPrototype.resolveAll = function () {
            // Resolve all reflected objects
            var res;
            if (this.ptr == null || _typeof(this.ptr.type) === 'object') return this; // Done (already resolved)

            if (this.ptr instanceof Reflect.Namespace) {
                // Resolve children

                this.ptr.children.forEach(function (child) {
                    this.ptr = child;
                    this.resolveAll();
                }, this);
            } else if (this.ptr instanceof Reflect.Message.Field) {
                // Resolve type

                if (!Lang.TYPE.test(this.ptr.type)) {
                    if (!Lang.TYPEREF.test(this.ptr.type)) throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res) throw Error("unresolvable type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                    this.ptr.resolvedType = res;
                    if (res instanceof Reflect.Enum) {
                        this.ptr.type = ProtoBuf.TYPES["enum"];
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3') throw Error("proto3 message cannot reference proto2 enum");
                    } else if (res instanceof Reflect.Message) this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];else throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                } else this.ptr.type = ProtoBuf.TYPES[this.ptr.type];

                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                if (this.ptr.map) {
                    if (!Lang.TYPE.test(this.ptr.keyType)) throw Error("illegal key type for map field in " + this.ptr.toString(true) + ": " + this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                }
            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {

                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.requestName);
                    this.ptr.resolvedRequestType = res;
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.responseName);
                    this.ptr.resolvedResponseType = res;
                } else // Should not happen as nothing else is implemented
                    throw Error("illegal service type in " + this.ptr.toString(true));
            } else if (!(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
            !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
            ) throw Error("illegal object in namespace: " + _typeof(this.ptr) + ": " + this.ptr);

            return this.reset();
        };

        /**
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
         * return the built package.
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
         * @throws {Error} If a type could not be resolved
         * @expose
         */
        BuilderPrototype.build = function (path) {
            this.reset();
            if (!this.resolved) this.resolveAll(), this.resolved = true, this.result = null; // Require re-build
            if (this.result === null) // (Re-)Build
                this.result = this.ns.build();
            if (!path) return this.result;
            var part = typeof path === 'string' ? path.split(".") : path,
                ptr = this.result; // Build namespace pointer (no hasChild etc.)
            for (var i = 0; i < part.length; i++) {
                if (ptr[part[i]]) ptr = ptr[part[i]];else {
                    ptr = null;
                    break;
                }
            }return ptr;
        };

        /**
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
         */
        BuilderPrototype.lookup = function (path, excludeNonNamespace) {
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
        };

        /**
         * Returns a string representation of this object.
         * @return {string} String representation as of "Builder"
         * @expose
         */
        BuilderPrototype.toString = function () {
            return "Builder";
        };

        // ----- Base classes -----
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Message = function () {};

        /**
         * @alias ProtoBuf.Builder.Enum
         */
        Builder.Enum = function () {};

        /**
         * @alias ProtoBuf.Builder.Message
         */
        Builder.Service = function () {};

        return Builder;
    }(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);

    /**
     * @alias ProtoBuf.Map
     * @expose
     */
    ProtoBuf.Map = function (ProtoBuf, Reflect) {
        "use strict";

        /**
         * Constructs a new Map. A Map is a container that is used to implement map
         * fields on message objects. It closely follows the ES6 Map API; however,
         * it is distinct because we do not want to depend on external polyfills or
         * on ES6 itself.
         *
         * @exports ProtoBuf.Map
         * @param {!ProtoBuf.Reflect.Field} field Map field
         * @param {Object.<string,*>=} contents Initial contents
         * @constructor
         */

        var Map = function Map(field, contents) {
            if (!field.map) throw Error("field is not a map");

            /**
             * The field corresponding to this map.
             * @type {!ProtoBuf.Reflect.Field}
             */
            this.field = field;

            /**
             * Element instance corresponding to key type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);

            /**
             * Element instance corresponding to value type.
             * @type {!ProtoBuf.Reflect.Element}
             */
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);

            /**
             * Internal map: stores mapping of (string form of key) -> (key, value)
             * pair.
             *
             * We provide map semantics for arbitrary key types, but we build on top
             * of an Object, which has only string keys. In order to avoid the need
             * to convert a string key back to its native type in many situations,
             * we store the native key value alongside the value. Thus, we only need
             * a one-way mapping from a key type to its string form that guarantees
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
             * === K2).
             *
             * @type {!Object<string, {key: *, value: *}>}
             */
            this.map = {};

            /**
             * Returns the number of elements in the map.
             */
            Object.defineProperty(this, "size", {
                get: function get() {
                    return Object.keys(this.map).length;
                }
            });

            // Fill initial contents from a raw object.
            if (contents) {
                var keys = Object.keys(contents);
                for (var i = 0; i < keys.length; i++) {
                    var key = this.keyElem.valueFromString(keys[i]);
                    var val = this.valueElem.verifyValue(contents[keys[i]]);
                    this.map[this.keyElem.valueToString(key)] = { key: key, value: val };
                }
            }
        };

        var MapPrototype = Map.prototype;

        /**
         * Helper: return an iterator over an array.
         * @param {!Array<*>} arr the array
         * @returns {!Object} an iterator
         * @inner
         */
        function arrayIterator(arr) {
            var idx = 0;
            return {
                next: function next() {
                    if (idx < arr.length) return { done: false, value: arr[idx++] };
                    return { done: true };
                }
            };
        }

        /**
         * Clears the map.
         */
        MapPrototype.clear = function () {
            this.map = {};
        };

        /**
         * Deletes a particular key from the map.
         * @returns {boolean} Whether any entry with this key was deleted.
         */
        MapPrototype["delete"] = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            var hadKey = keyValue in this.map;
            delete this.map[keyValue];
            return hadKey;
        };

        /**
         * Returns an iterator over [key, value] pairs in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.entries = function () {
            var entries = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                entries.push([(entry = this.map[strKeys[i]]).key, entry.value]);
            }return arrayIterator(entries);
        };

        /**
         * Returns an iterator over keys in the map.
         * @returns {Object} The iterator
         */
        MapPrototype.keys = function () {
            var keys = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                keys.push(this.map[strKeys[i]].key);
            }return arrayIterator(keys);
        };

        /**
         * Returns an iterator over values in the map.
         * @returns {!Object} The iterator
         */
        MapPrototype.values = function () {
            var values = [];
            var strKeys = Object.keys(this.map);
            for (var i = 0; i < strKeys.length; i++) {
                values.push(this.map[strKeys[i]].value);
            }return arrayIterator(values);
        };

        /**
         * Iterates over entries in the map, calling a function on each.
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
         * @param {Object=} thisArg The `this` value for the callback
         */
        MapPrototype.forEach = function (cb, thisArg) {
            var strKeys = Object.keys(this.map);
            for (var i = 0, entry; i < strKeys.length; i++) {
                cb.call(thisArg, (entry = this.map[strKeys[i]]).value, entry.key, this);
            }
        };

        /**
         * Sets a key in the map to the given value.
         * @param {*} key The key
         * @param {*} value The value
         * @returns {!ProtoBuf.Map} The map instance
         */
        MapPrototype.set = function (key, value) {
            var keyValue = this.keyElem.verifyValue(key);
            var valValue = this.valueElem.verifyValue(value);
            this.map[this.keyElem.valueToString(keyValue)] = { key: keyValue, value: valValue };
            return this;
        };

        /**
         * Gets the value corresponding to a key in the map.
         * @param {*} key The key
         * @returns {*|undefined} The value, or `undefined` if key not present
         */
        MapPrototype.get = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            if (!(keyValue in this.map)) return undefined;
            return this.map[keyValue].value;
        };

        /**
         * Determines whether the given key is present in the map.
         * @param {*} key The key
         * @returns {boolean} `true` if the key is present
         */
        MapPrototype.has = function (key) {
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
            return keyValue in this.map;
        };

        return Map;
    }(ProtoBuf, ProtoBuf.Reflect);

    /**
     * Loads a .proto string and returns the Builder.
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadProto = function (proto, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = undefined;
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
    };

    /**
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
     * @function
     * @param {string} proto .proto file contents
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

    /**
     * Loads a .proto file and returns the Builder.
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadProtoFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadProto(contents, builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
    };

    /**
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
     * @function
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


    /**
     * Constructs a new empty Builder.
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
     * @return {!ProtoBuf.Builder} Builder
     * @expose
     */
    ProtoBuf.newBuilder = function (options) {
        options = options || {};
        if (typeof options['convertFieldsToCamelCase'] === 'undefined') options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
        if (typeof options['populateAccessors'] === 'undefined') options['populateAccessors'] = ProtoBuf.populateAccessors;
        return new ProtoBuf.Builder(options);
    };

    /**
     * Loads a .json definition and returns the Builder.
     * @param {!*|string} json JSON definition
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages
     * @throws {Error} If the definition cannot be parsed or built
     * @expose
     */
    ProtoBuf.loadJson = function (json, builder, filename) {
        if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = null;
        if (!builder || (typeof builder === "undefined" ? "undefined" : _typeof(builder)) !== 'object') builder = ProtoBuf.newBuilder();
        if (typeof json === 'string') json = JSON.parse(json);
        builder["import"](json, filename);
        builder.resolveAll();
        return builder;
    };

    /**
     * Loads a .json file and returns the Builder.
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
     *  an overridden 'root' path for all imported files.
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
     *  file will be read synchronously and this function will return the Builder.
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
     *   request has failed), else undefined
     * @expose
     */
    ProtoBuf.loadJsonFile = function (filename, callback, builder) {
        if (callback && (typeof callback === "undefined" ? "undefined" : _typeof(callback)) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
        if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
            if (contents === null) {
                callback(Error("Failed to fetch file"));
                return;
            }
            try {
                callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
            } catch (e) {
                callback(e);
            }
        });
        var contents = ProtoBuf.Util.fetch((typeof filename === "undefined" ? "undefined" : _typeof(filename)) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
    };

    return ProtoBuf;
});

cc._RFpop();
}).call(this,require('_process'))

},{"_process":2,"bytebuffer":"bytebuffer","fs":undefined,"path":1}]},{},["LLEvent","LoadingDialog","Msgbox","Notice","SettingView","SettingViewLoad","Msgcode","TuiBingConfig","errorcode","etc","bytebuffer","long","protobuf","OnGmAddGoldLayerLoad","OnGmLayerLoad","GameLogic","OnBankerLayerLoad","OnGameViewLoad","PreBankerItem","HelloWorld","Lscrollview","OnLoadingViewLoad","OnLogin","OnLoginLayerLoad","OnLoginViewLoad","OnPhoneRegisterLoad","OnRegisterLayerLoad","OnMainViewLoad","OnTransferViewLoad","AudioManager","SceneManager","Lpackage","Lwebsocket","msgdispatch","Player","PlayerManager"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0cy9TY3JpcHQvTWFuYWdlci9BdWRpb01hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0L0dhbWVWaWV3L0dhbWVMb2dpYy5qcyIsImFzc2V0cy9TY3JpcHQvSGVsbG9Xb3JsZC5qcyIsImFzc2V0cy9TY3JpcHQvQ29tbW9uL0xMRXZlbnQuanMiLCJhc3NldHMvU2NyaXB0L0NvbW1vbi9Mb2FkaW5nRGlhbG9nLmpzIiwiYXNzZXRzL1NjcmlwdC9OZXRXb3JrL0xwYWNrYWdlLmpzIiwiYXNzZXRzL1NjcmlwdC9MY29tcG9uZW50L0xzY3JvbGx2aWV3LmpzIiwiYXNzZXRzL1NjcmlwdC9OZXRXb3JrL0x3ZWJzb2NrZXQuanMiLCJhc3NldHMvU2NyaXB0L0NvbW1vbi9Nc2dib3guanMiLCJhc3NldHMvU2NyaXB0L0V0Yy9Nc2djb2RlLmpzIiwiYXNzZXRzL1NjcmlwdC9Db21tb24vTm90aWNlLmpzIiwiYXNzZXRzL1NjcmlwdC9HYW1lVmlldy9PbkJhbmtlckxheWVyTG9hZC5qcyIsImFzc2V0cy9TY3JpcHQvR2FtZVZpZXcvT25HYW1lVmlld0xvYWQuanMiLCJhc3NldHMvU2NyaXB0L0dNTGF5ZXIvT25HbUFkZEdvbGRMYXllckxvYWQuanMiLCJhc3NldHMvU2NyaXB0L0dNTGF5ZXIvT25HbUxheWVyTG9hZC5qcyIsImFzc2V0cy9TY3JpcHQvTG9hZFZpZXcvT25Mb2FkaW5nVmlld0xvYWQuanMiLCJhc3NldHMvU2NyaXB0L0xvZ2luVmlldy9PbkxvZ2luTGF5ZXJMb2FkLmpzIiwiYXNzZXRzL1NjcmlwdC9Mb2dpblZpZXcvT25Mb2dpblZpZXdMb2FkLmpzIiwiYXNzZXRzL1NjcmlwdC9Mb2dpblZpZXcvT25Mb2dpbi5qcyIsImFzc2V0cy9TY3JpcHQvTWFpblZpZXcvT25NYWluVmlld0xvYWQuanMiLCJhc3NldHMvU2NyaXB0L0xvZ2luVmlldy9PblBob25lUmVnaXN0ZXJMb2FkLmpzIiwiYXNzZXRzL1NjcmlwdC9Mb2dpblZpZXcvT25SZWdpc3RlckxheWVyTG9hZC5qcyIsImFzc2V0cy9TY3JpcHQvTWFpblZpZXcvT25UcmFuc2ZlclZpZXdMb2FkLmpzIiwiYXNzZXRzL1NjcmlwdC9Sb2xlL1BsYXllck1hbmFnZXIuanMiLCJhc3NldHMvU2NyaXB0L1JvbGUvUGxheWVyLmpzIiwiYXNzZXRzL1NjcmlwdC9HYW1lVmlldy9QcmVCYW5rZXJJdGVtLmpzIiwiYXNzZXRzL1NjcmlwdC9NYW5hZ2VyL1NjZW5lTWFuYWdlci5qcyIsImFzc2V0cy9TY3JpcHQvQ29tbW9uL1NldHRpbmdWaWV3TG9hZC5qcyIsImFzc2V0cy9TY3JpcHQvQ29tbW9uL1NldHRpbmdWaWV3LmpzIiwiYXNzZXRzL1NjcmlwdC9FdGMvVHVpQmluZ0NvbmZpZy5qcyIsImFzc2V0cy9TY3JpcHQvRXh0ZW5kL2J5dGVidWZmZXIuanMiLCJhc3NldHMvU2NyaXB0L0V0Yy9lcnJvcmNvZGUuanMiLCJhc3NldHMvU2NyaXB0L0V0Yy9ldGMuanMiLCJhc3NldHMvU2NyaXB0L0V4dGVuZC9sb25nLmpzIiwiYXNzZXRzL1NjcmlwdC9OZXRXb3JrL21zZ2Rpc3BhdGNoLmpzIiwiYXNzZXRzL1NjcmlwdC9FeHRlbmQvcHJvdG9idWYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUhXO0FBS1o7QUFDQztBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNEO0FBQ087QUFDSDs7QUFFSjtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNNO0FBQ0k7QUFDSDtBQUNQO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0M7QUFDQTs7QUFFRDtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTtBQWxGTTtBQU5XOztBQTRGcEI7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBOUNROztBQWlEWjtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSztBQUNBO0FBQ0g7O0FBRUY7QUFDQTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0c7QUFDSDtBQUNIOztBQUVGO0FBQ0E7QUFHQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTs7QUFFQTtBQUNJO0FBQThCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQStCO0FBRS9CO0FBQTJDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFBMEM7QUFDdEM7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUErQjtBQUMzQjtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUFrQztBQUM5QjtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQWtDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFBZ0M7QUFDNUI7QUFDQTtBQUNBO0FBQ0g7QUE1Q0w7QUE4Q0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0c7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQVE7QUFDUjtBQUFRO0FBQ1I7QUFBUTtBQUNSO0FBQVE7QUFKWjtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBVUE7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUF1QjtBQUFTO0FBQ2hDO0FBQXVCO0FBQVM7QUFDaEM7QUFBdUI7QUFBUztBQUNoQztBQUF1QjtBQUFTOztBQUVoQztBQUNBO0FBRUk7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQU9KO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNHO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUFlO0FBQ1g7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQWU7QUFDWDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBZTtBQUNYO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKO0FBQ0Q7QUFPSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBMXZCSTs7Ozs7Ozs7OztBQ0xUO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGRztBQUlQO0FBQ0E7QUFOUTs7QUFTWjtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBbEJLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTtBQUNBO0FBR0E7QUFDQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7O0FBRUQ7QUF4Q1E7QUFMVTs7QUFtRHZCOzs7Ozs7Ozs7O0FDbkRBOztBQUVBO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUNTO0FBQ0k7QUFDQTtBQUNIO0FBQ1Y7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUFzQjtBQUFzQjtBQUM1QztBQUNEO0FBQ0Q7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBN0JNO0FBRGM7O0FBa0N2Qjs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFIVztBQUtaO0FBQ0M7QUFDQTtBQUZRO0FBSVQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFsQ3NCO0FBb0N4Qjs7Ozs7Ozs7OztBQ3RDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBOztBQWpCSzs7Ozs7Ozs7OztBQ0FUOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKYzs7QUFPbEI7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBM0VJO0FBSGE7O0FBa0YxQjs7Ozs7Ozs7OztBQzNGQTs7QUFFQTtBQUNJO0FBQ0E7QUFHQTtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUEvQkk7QUFMUztBQXVDdEI7Ozs7Ozs7Ozs7QUN6Q0E7O0FBRUE7QUFDQTs7QUF3QkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBOzs7Ozs7Ozs7O0FDaERBOztBQUVBO0FBQ0k7QUFDQTtBQUdBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNJOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUNEOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUExREk7QUFMWTtBQWtFekI7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFOUTs7QUFTWjtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUE1R0k7Ozs7Ozs7Ozs7QUNIVDtBQUNBO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZPO0FBSVg7QUFDSTtBQUNBO0FBRk87O0FBS1g7QUFDQTtBQUNBOztBQUVBO0FBZFE7O0FBaUJaO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBaExJOzs7Ozs7Ozs7O0FDSlQ7QUFDQTtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUpROztBQU9aO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQXhFSTs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSFE7O0FBTVo7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHSTtBQUNIOztBQUVEO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQS9FSTs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQlE7O0FBcUJaO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQXBISTs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7QUFDQTs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRmlCOztBQUtyQjs7QUFFQTtBQUNDO0FBQ0E7QUFGWTs7QUFLYjtBQUNDO0FBQ0E7QUFGYTs7QUFLZDs7QUFFQTtBQXBCUTtBQXNCWjtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0M7QUFDRztBQUNIOztBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUFyRUk7Ozs7Ozs7Ozs7QUNGVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQTlCSTs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZjO0FBRFY7O0FBT1o7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFHQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSDtBQUNEOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNHO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBMUVJOzs7Ozs7Ozs7O0FDSFQ7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUZPO0FBSVg7QUFDSTtBQUNBO0FBRk87O0FBS1g7QUFyQlE7O0FBd0JaO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQXZFSTs7Ozs7Ozs7OztBQ0ZUO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZTOztBQUtiO0FBQ0k7QUFDQTtBQUZPOztBQUtYO0FBQ0k7QUFDQTtBQUZVOztBQUtkO0FBQ0E7QUFqQlE7O0FBb0JaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQTdHSTs7Ozs7Ozs7OztBQ0hUO0FBQ0E7O0FBRUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZTOztBQUtiO0FBQ0k7QUFDQTtBQUZVOztBQUtkO0FBQ0k7QUFDQTtBQUZXO0FBWFA7O0FBaUJaO0FBQ0E7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBRUk7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBdkRJOzs7Ozs7Ozs7O0FDSFQ7QUFDQTs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSFE7O0FBTVo7QUFDQTs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUE1RUk7Ozs7Ozs7Ozs7QUNIVDs7QUFFQTtBQUNJO0FBQ0k7QUFEUTtBQUdaO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFQSztBQUpNOztBQWVwQjs7Ozs7Ozs7OztBQ2pCQTtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJXOztBQVdaO0FBQ0M7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ007QUFDTjs7QUFFRDtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQWpEZTs7QUFvRGpCOzs7Ozs7Ozs7O0FDcERBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZFE7O0FBaUJaO0FBQ0E7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBaERJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNDO0FBQ0M7QUFDQztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFQTTtBQURlOztBQVl4Qjs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDSTs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBSlc7O0FBT1o7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0M7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDSTtBQUNIO0FBN0NJOzs7Ozs7Ozs7O0FDRFQ7QUFDQTtBQUNDO0FBQ0M7QUFEVztBQUdaO0FBQ0M7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFWTTtBQUpjOztBQWtCdkI7Ozs7Ozs7Ozs7QUNuQkE7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYTTs7QUFjUDtBQUNBO0FBQ0E7QUFDQTs7QUFHRDs7Ozs7Ozs7Ozs7O0FDL0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7QUFNQTs7QUFFSTtBQUVBO0FBRVE7QUFBZ0I7QUFBeUI7QUFDekM7QUFDSDtBQUNMO0FBR0g7QUFDRzs7QUFFQTs7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0k7QUFFQTtBQUVBO0FBRUE7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNIOztBQUVEOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSDJEOztBQU0vRDs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUNJO0FBRUE7QUFHQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFDSDtBQUNEO0FBRUE7QUFBQTtBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDtBQUNEOzs7OztBQUtBO0FBQ0k7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUVBO0FBQ0k7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBWlI7QUFjSDtBQUNEO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFBb0M7QUFDaEM7QUFDQTtBQUF5QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFBMkM7QUFDeEM7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUF5RTtBQUN0RTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBRUg7QUFFRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUVBO0FBRUE7QUFDQTtBQUVEOztBQUVEO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7O0FBRUE7QUFDRTtBQVFBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQWtCO0FBQWxCO0FBRUQ7O0FBRUQ7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0E7QUFBa0I7QUFBbEI7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOztBQUVBOztBQUVJOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQU1BO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBTUE7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBRUg7OztBQUdEOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUdBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0s7QUFLUjs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFBQTtBQUFBO0FBR0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBRkc7QUFJVjs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNBO0FBSUE7QUFDSDs7QUFFRDs7QUFFQTs7QUFFSTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0k7QUFDSTtBQUlIO0FBQ0c7QUFJSDtBQUNKO0FBRUo7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFLQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFLQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQU1BO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDSTtBQUFTO0FBQ1Q7QUFBUztBQUNUO0FBQVM7QUFDVDtBQUFTO0FBQ1Q7QUFBUztBQUNUO0FBQVM7QUFDVDtBQUFTO0FBQ1Q7QUFBUztBQUNUO0FBQVM7QUFDVDtBQUFTO0FBVmI7QUFZQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQWdDO0FBQUM7QUFBQztBQUFDO0FBQUM7QUFBQztBQUFDO0FBQUM7QUFBQztBQUFDO0FBQ3pDO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNJO0FBQ0E7QUFGRztBQUlWO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTtBQUlBO0FBQ0g7QUFFSjs7O0FBR0Q7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNJO0FBRUE7QUFDSTtBQUVIO0FBQ0Q7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0k7QUFDQTtBQUZHO0FBSVY7QUFDSjs7QUFFRDs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNJO0FBQ0E7QUFGRztBQUlWO0FBQ0o7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFBQTtBQUFBO0FBR0E7QUFBNEM7QUFDeEM7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0k7QUFDQTtBQUZHO0FBSVY7QUFDSjtBQUNHO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNJO0FBQ0E7QUFGRztBQUlWO0FBQ0o7QUFFSjs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUE7O0FBRUE7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDSTtBQUNBO0FBRkc7QUFJVjtBQUNKOztBQUdEOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7QUFDRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNJO0FBRUE7QUFDSTtBQUVIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBR0E7QUFDQTs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUVBO0FBQW9CO0FBQXBCO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFSDtBQUNEO0FBQ0E7QUFDSDtBQUNEOzs7Ozs7QUFNQTtBQUNJO0FBQ0k7QUFFSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFnQjtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBS0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDtBQUNEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDSDtBQUNEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFFQTtBQUNBO0FBQ0g7QUFDRDs7Ozs7O0FBTUE7QUFDSTtBQUNJO0FBRUE7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUVIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7Ozs7Ozs7O0FBUUE7QUFDSTtBQUFBO0FBRUE7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBRUE7QUFJQTtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFkUjtBQWdCSDs7QUFFRDs7QUFFQTs7Ozs7QUFLQTtBQUNJOztBQUVBOzs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFPQTs7Ozs7QUFLQTtBQUNBO0FBQ0k7QUFESjs7Ozs7OztBQVVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBTUg7QUFJSjtBQUNKOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFFQTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUFBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNJO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBRUE7QUFBQTtBQUVBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNJO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBRUE7QUFDSTtBQUNBO0FBR0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0k7QUFDQTtBQUVBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDSTtBQUNJO0FBQ0E7QUFFQTtBQUVIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0k7QUFBNEI7QUFBNUI7QUFFQTtBQUNIO0FBQ0o7QUFDRDtBQVFIO0FBQ0Q7QUFDSTtBQUNJO0FBREo7QUFHSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUk7QUFGSjtBQUFBO0FBQUE7QUFHSTtBQUNKO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBQ0E7QUE5RlI7QUFnR0E7QUFFSDtBQUNEO0FBQ0k7QUFFQTtBQUVIO0FBQ0Q7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7OztBQU9BO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFBQTtBQUVBO0FBQ0k7QUFDQTtBQUdIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFDSTtBQUVBO0FBRUg7QUFDRDtBQUFBO0FBQUE7QUFHQTtBQUNJO0FBQ0E7QUFHQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOztBQUVBOzs7OztBQUtBO0FBQ0k7O0FBRUE7Ozs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFFdUI7QUFBYztBQUNyQztBQUNJO0FBY0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBWUg7QUFDSjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFBQTtBQUNBO0FBQ0k7QUFFQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDaUM7QUFBYztBQUMvQztBQUNJO0FBTUE7QUFDSDtBQUNKOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQUE7QUFDQTtBQUNJO0FBREo7QUFHSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUFBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNIOztBQUVEOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUg7QUFDRDtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFFSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNJO0FBR0E7QUFBQTtBQUVBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNIOzs7Ozs7Ozs7O0FDanFIRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFKUTs7QUFGRDs7Ozs7Ozs7Ozs7O0FDQVQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7OztBQUtBOztBQUVJO0FBRUE7QUFFQTtBQUdIO0FBQ0c7O0FBRUE7Ozs7Ozs7Ozs7O0FBVUE7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBSGdEOztBQU1wRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBRUE7QUFDSDtBQUNHO0FBQ0E7QUFDSTtBQUNBO0FBRUg7QUFDRDtBQUNBO0FBRUE7QUFDSDtBQUNKOztBQUVEOzs7Ozs7OztBQVFBOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSTtBQUVBO0FBRUg7QUFDRztBQUVBO0FBRUg7QUFDRDtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBRUE7QUFDSTtBQUNBO0FBRUg7QUFDRztBQUNIO0FBQ0Q7QUFDQTs7QUFHQTtBQUNBO0FBR0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0E7QUFFQTtBQUVBO0FBQXlCO0FBQ3JCO0FBQ0k7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0g7QUFFSjs7QUFFRDtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDSTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBR0k7QUFDSTtBQURKO0FBR0g7QUFDSjtBQUNKOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0k7QUFDSjtBQUNBO0FBQ0k7QUFESjtBQUlIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFFQTtBQUVBO0FBRUE7O0FBR0E7QUFDSTtBQUlIOztBQUdEO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUFBO0FBS0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBRUQ7QUFDSTtBQUVBO0FBQ0g7QUFFRDtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNJO0FBQ0o7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUNJO0FBTEo7QUFPQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFNSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFNSDs7QUFFRDs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTtBQUNJO0FBRUE7QUFDQTtBQUdJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFJSjtBQUNKOztBQUVEOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSDs7Ozs7Ozs7OztBQzdzQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBRlM7QUFJYjtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUF1QjtBQUE0QjtBQUN0RDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTTtBQU1WO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QlU7O0FBMEJkO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQVJHO0FBSGU7QUFjM0I7Ozs7Ozs7Ozs7Ozs7QUNsVUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7O0FBS0E7O0FBRUk7QUFFQTtBQUVBO0FBR0g7QUFDRzs7QUFFQTs7Ozs7OztBQU1BOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQU1BOzs7Ozs7O0FBT0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUFLVDtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUFLVDtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSEk7QUFLUjtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0k7QUFDQTtBQUNBO0FBSEs7QUFLVDtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDSTtBQUNBO0FBQ0E7QUFIUTtBQUtaO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNJO0FBQ0E7QUFDQTtBQUhRO0FBS1o7QUFDSTtBQUNBO0FBQ0E7QUFISztBQUtUO0FBQ0k7QUFDQTtBQUNBO0FBSEk7QUFLUjtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDSTtBQUNBO0FBQ0E7QUFISztBQXZGSTs7QUE4RmpCOzs7Ozs7QUFNQTs7QUFnQkE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7OztBQUtBOztBQUVBOzs7Ozs7QUFNQTs7QUFJQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ2lCO0FBQTRCO0FBQzVCO0FBQTJDO0FBQzNDO0FBQTJDO0FBQzNDO0FBQThDO0FBRS9EO0FBQ0E7QUFDQTtBQUNJO0FBQU07QUFBOEI7QUFDeEI7QUFBVztBQUN2QjtBQUNIO0FBQ0Q7QUFFQTtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBSUg7QUFDSjtBQUVPO0FBQ0g7QUFDRztBQUNIO0FBQ1I7QUFDRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFJSDtBQUNEO0FBRUE7QUFDSDtBQUNHO0FBQ0E7QUFFQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNIOztBQUVEOzs7OztBQUtBOztBQUVJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUF6RFk7O0FBNERoQjs7OztBQUlBO0FBQ0k7O0FBRUE7Ozs7OztBQUtBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUk7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFFQTtBQUVBOztBQUdBO0FBR0E7QUFDSTs7QUFFQTtBQUNBO0FBQ0k7QUFFQTtBQUVIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQThDO0FBQzFDO0FBQ0k7QUFESjtBQUlBO0FBQ0E7QUFDSDtBQUE2RDtBQUMxRDtBQUNJO0FBRUE7QUFFQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFFSjtBQUNKOztBQUVEOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFUTtBQURKO0FBR0o7QUFFQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSTtBQUNBO0FBRUE7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUg7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFSTs7Ozs7QUFLQTs7QUFFQTs7OztBQUlBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSVztBQVVmO0FBQUE7QUFBQTtBQUdBO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUVBO0FBQ0E7QUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7QUFDSjtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQS9DUjtBQWlESDtBQUNKO0FBQ0c7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBUUE7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBWUE7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQUE7QUFBQTtBQUdBO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUg7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFBQTtBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDUjtBQUNBO0FBQWM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBRUg7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBR0k7QUFFQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUFxQjtBQUNqQjtBQUNIO0FBQVE7QUFDTDtBQUNBO0FBQ0k7QUFFQTtBQUlIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBSE07QUFLVjtBQUNBO0FBQ0k7QUFNSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTFM7QUFPYjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFJSDtBQUNEO0FBQ0g7QUFFRDtBQUVBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSTTtBQVVWO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0E7QUFDSTtBQWFJO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFMQTtBQU1BO0FBS0Q7QUFFQTtBQUNIO0FBRUo7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7OztBQUlBO0FBQ0k7QUFDSTtBQURKO0FBR0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxNO0FBT1Y7QUFDQTs7QUFFSTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFSDs7QUFFRzs7QUFFQTs7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUg7O0FBRUc7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFBQTtBQUVBO0FBQ0k7QUFFQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUdJO0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFGTTtBQUlWO0FBQ0E7QUFFQTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFHQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBVFI7QUFXQTtBQUNBO0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFFQTtBQUNJO0FBQ0E7QUFGTTtBQUlWO0FBQ0E7QUFDSTtBQUdJO0FBRUE7QUFDSDtBQUVKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7O0FBRUE7Ozs7QUFJQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTtBQUVIOztBQUVEOzs7O0FBSUE7QUFDSTs7QUFFQTs7Ozs7O0FBS0E7O0FBRUE7Ozs7Ozs7OztBQVNBOztBQUVJOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFFQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDQTtBQUNJO0FBREo7QUFJSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUFBO0FBTUg7QUFDRDtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDSTtBQURKO0FBSUg7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQUE7QUFBQTtBQUdBO0FBQXNCO0FBQ2xCO0FBQ0k7QUFESjtBQUdIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBRUE7QUFDQTtBQUVIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUFBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFFSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFFSDtBQUNEO0FBRUE7QUFDSDs7QUFFRDs7OztBQUlBO0FBQ0k7QUFBQTtBQUVBO0FBQ0k7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBRUE7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O0FBRUk7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBRUg7O0FBRUQ7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFFQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFHQTtBQUVBO0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRUE7O0FBRUo7QUFDQTtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUFpQztBQUM3QjtBQUVRO0FBQ0g7QUFDRztBQUNIO0FBR1I7O0FBRUQ7QUFDQTtBQUNBO0FBQWdDO0FBQzVCO0FBRVE7QUFDSDtBQUNHO0FBQ0g7QUFHUjs7QUFFRDtBQUNBO0FBQ0k7QUFFQTs7QUFFSjtBQUNBO0FBQ0E7QUFDSTtBQUVBOztBQUVKO0FBQ0E7QUFDSTtBQUVBOztBQUVKO0FBQ0E7QUFDSTtBQUVBOztBQUVKO0FBQ0E7QUFBNkI7QUFDekI7QUFDQTtBQUNJO0FBREo7QUFPSTtBQUNBO0FBRUE7QUFFQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFBZ0M7QUFDNUI7QUFFQTtBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUlIO0FBQ0Q7QUFDQTtBQUNIO0FBM0dMOztBQThHQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNJO0FBQ0o7QUFDQTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0E7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFFQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQXJDUjtBQXVDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFJQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0k7QUFDQTs7QUFFSjtBQUNBO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUlBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUNBOztBQUVKO0FBQ0E7QUFDSTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNJO0FBQ0E7QUExR1I7QUE0R0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTs7QUFHQTtBQUNBO0FBQ0k7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUNJO0FBQ0E7O0FBRUo7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0k7O0FBRUo7QUFDQTtBQUE4QjtBQUMxQjtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQWdDO0FBQzVCO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFoRlI7O0FBbUZBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ007QUFDQTs7QUFFTjtBQUNNOztBQUVOO0FBQ007O0FBRU47QUFDTTtBQXZCVjtBQXlCSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNJOztBQUdBO0FBQ0E7O0FBRUk7QUFBQTs7QUFHQTs7Ozs7Ozs7O0FBU0E7QUFDSTs7QUFFQTtBQUNBO0FBQ0k7QUFESjtBQUdBO0FBQ0k7QUFDQTtBQUdBO0FBR0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDSTtBQURKO0FBR1A7QUFDSjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7QUFDQTtBQUNJO0FBRUE7QUFFQTtBQUVBO0FBQ0g7QUFDRDtBQUVBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBREo7QUFJSDtBQUNEO0FBQ0E7QUFDSTtBQUVBO0FBRUE7QUFDSDtBQUVEO0FBQTRCO0FBQ3hCO0FBQ0E7QUFDSTtBQUVBO0FBQ0g7QUFFSjtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0k7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTs7QUFHQTtBQUVRO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDSDs7QUFFRDtBQUNJOzs7Ozs7Ozs7OztBQVdBOztBQUVKO0FBQ0k7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUo7QUFDSTs7Ozs7Ozs7QUFRQTs7QUFFSjtBQUNJOzs7Ozs7OztBQVFBO0FBRVA7QUFDUjs7QUFFRDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNJO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNJO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQ0k7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7QUFTQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUNJO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUVIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUdIO0FBQ0Q7QUFDQTtBQUFBO0FBRUE7QUFDSTtBQUNJO0FBSUg7QUFOTDtBQVFIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFFUztBQUNBO0FBSVo7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDSTtBQUdBO0FBSUE7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0E7QUFDSTtBQUlBO0FBRUE7QUFBQTtBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDSTtBQUNIOztBQUVEOztBQUVBOzs7Ozs7O0FBT0E7QUFDSTtBQUNIOztBQUVEOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7QUFNQTtBQUVIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFFQTtBQUNIO0FBTUc7QUFDUDs7QUFFRDtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBQUE7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBRUg7QUFFSjtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUlIO0FBQ0Q7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNJO0FBQUE7QUFDSTtBQURKO0FBR0E7QUFDSTtBQUNJO0FBQUc7QUFBSDtBQUVBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBSUo7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQXhCUjtBQTBCQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBRUE7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0o7QUFDSTtBQWxCUjtBQW9CQTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0c7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUFtQjtBQUNmO0FBQ0E7QUFFQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQWdDO0FBQzVCO0FBQ0g7QUFDRztBQUNBO0FBQ0E7QUFDSDtBQUVKO0FBQ0o7QUFDRDtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDSTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFFSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7OztBQUtBO0FBQ0k7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFIQTtBQU1IOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQXNCO0FBQ2xCO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFDQTtBQUFzQztBQUNsQztBQUVBO0FBQ0E7QUFDSTtBQURKO0FBR0g7QUFDRDtBQUFpQztBQUM3QjtBQUNJO0FBQ0E7QUFDSTtBQUVIO0FBQ0Q7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7O0FBR0E7QUFDSDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0k7QUFFQTtBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0E7QUFDSTs7QUFFSjtBQUNJOztBQUVKO0FBQ0k7O0FBRUo7QUFDSTs7QUFFSjtBQUNJO0FBQ0o7QUFDSTtBQWxDUjtBQW9DSDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDSTtBQUVBO0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBRUE7QUFFQTtBQUFxQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDtBQUNKO0FBQ0c7QUFDQTtBQUNJO0FBQ0E7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0c7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0c7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0E7QUFDSDtBQUNHO0FBQ0k7QUFESjtBQUdIO0FBQ0o7QUFDRztBQUNBO0FBQ0k7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0c7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0c7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUtBOztBQUdBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0k7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0k7O0FBRUE7Ozs7O0FBS0E7QUFDSDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBQ0E7QUFDSTtBQURKO0FBSUg7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQUE7QUFFQTtBQUNJO0FBREo7QUFJUTtBQUNBO0FBRm1DO0FBSTNDO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNJOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDSTs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDSTs7QUFHQTtBQUNBOztBQUVJOzs7Ozs7OztBQVFBO0FBQ0k7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0k7O0FBRUk7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUVIO0FBQ0Q7QUFFQTtBQUVBO0FBQXFEO0FBQ2pEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUVBO0FBQU07QUFBc0Q7QUFDNUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUFDRztBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFHSDtBQUNKOztBQUVEOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7QUFNQTtBQUVIO0FBQ0o7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0k7O0FBRUE7OztBQUdBOztBQUVBOzs7OztBQUtBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNJOztBQUVBOzs7QUFHQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUVIOztBQUVEOzs7O0FBSUE7QUFDSTs7QUFFQTs7Ozs7Ozs7QUFPQTs7QUFFSTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTtBQUNIOztBQUVEOzs7O0FBSUE7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFFQTtBQUNIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7QUFFQTs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0o7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNJO0FBRUE7QUFHSTtBQUVBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7O0FBRUE7QUFDSTs7QUFFSjtBQUNJOztBQUVBO0FBQ0k7O0FBRUE7QUFDQTtBQUNBO0FBRVE7QUFDSDs7QUFFTDtBQUNBO0FBRVE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDSDs7QUFFTDtBQUNBO0FBQ0E7QUFFUTtBQUNIO0FBQ0w7QUFFUTtBQUNIO0FBQ0w7QUFFUTtBQUNIOztBQUVMO0FBQ0E7QUFDSTtBQUNJO0FBR1A7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUVIOztBQUVHO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFFSDs7QUFFRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFFSDs7QUFFRztBQUNBO0FBQ0k7QUFDSTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFFSDtBQUNEO0FBRUg7QUFDRDtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVKO0FBQ0c7QUFFUDs7QUFHRDtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7O0FBRUE7O0FBRUE7O0FBRUk7QUFFQTtBQUVBO0FBRUg7QUFBMEM7O0FBRXZDO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFBQTs7QUFHQTtBQUFvQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFHSDs7QUFFRztBQUNJO0FBQ0c7QUFDSDtBQUFrQztBQUM5QjtBQUNBO0FBRUg7QUFBeUM7QUFDdEM7QUFDQTtBQUNIO0FBRUo7QUFFSjs7QUFHRDtBQUNJO0FBQThDO0FBQzFDO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNJO0FBQ0o7QUFDQTtBQUVBO0FBQ0k7QUFESjtBQUlIO0FBQ0c7QUFHSTtBQUE0RjtBQUErQjtBQUUzSDtBQUNYO0FBQ0Q7QUFDSTtBQUNQOztBQUVEOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRVE7QUFDSDtBQUNMO0FBR0E7QUFHQTtBQUdBOztBQUdBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BO0FBQ0k7QUFDQTtBQUNBOztBQUdBO0FBQTZDOztBQUV6QztBQUNJO0FBQ0E7QUFDSDtBQUVKO0FBQXVEOztBQUVwRDtBQUNJO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBRUg7QUFLSjs7QUFHRDtBQUNBO0FBQ0E7QUFDSTtBQUVBO0FBQ0g7QUFFSjs7QUFFRztBQUNJO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNIO0FBQ0c7QUFFUDtBQUVHO0FBQ0E7QUFIRzs7QUFPUDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0k7QUFDQTtBQUlBO0FBQ0k7QUFDSjtBQUVBO0FBQUE7QUFFQTtBQUNJO0FBR0k7QUFDQTtBQUNIO0FBTkw7QUFRSDs7QUFFRDs7Ozs7O0FBTUE7QUFDSTtBQUNIOztBQUVEOzs7OztBQUtBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBO0FBRUg7O0FBRUQ7Ozs7QUFJQTtBQUNJOztBQUVBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNJOztBQUdBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBOztBQUVBOzs7QUFHQTtBQUNJO0FBQWtCO0FBQXNDO0FBRHhCOztBQUlwQztBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUVIO0FBQ0o7QUFDSjs7QUFFRDs7QUFFQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUVBO0FBQ0g7QUFMRTtBQU9WOztBQUVEOzs7QUFHQTtBQUNJO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7Ozs7QUFJQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBREo7QUFHSDs7QUFFRDs7OztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFESjtBQUdIOztBQUVEOzs7O0FBSUE7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQURKO0FBR0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBQ0k7QUFESjtBQUVIOztBQUVEOzs7Ozs7QUFNQTtBQUNJO0FBQ0E7QUFDQTtBQUVBO0FBQ0g7O0FBRUQ7Ozs7O0FBS0E7QUFDSTtBQUNBO0FBRUE7QUFDSDs7QUFFRDs7Ozs7QUFLQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNIOztBQUdEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBR0E7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNJO0FBS0E7QUFFUTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNMO0FBQ0E7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWFBOzs7QUFHQTs7Ozs7O0FBTUE7QUFDSTtBQUNBO0FBRUE7QUFFQTtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNJO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNJO0FBS0E7QUFFUTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNMO0FBQ0E7QUFDSDs7QUFFRDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLy9BdWRpb01hbmFnZXIuanNcbnZhciBBTWdyID0gY2MuQ2xhc3Moe1xuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0X3NvdW5kX3NpemUgOiAwLjUsXG5cdFx0X2N1cnJlbnQgOiAwLFxuXHRcdF9jdXJiZ20gOiBcIlwiLFxuXHR9LFxuXHRzdGF0aWNzOntcblx0XHRpbml0IDogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBzaXplID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzb3VuZFNpemUnKTtcblx0XHRcdGlmKCBzaXplID09IG51bGwgKXtcblx0XHRcdFx0c2l6ZSA9IDE7XG5cdFx0XHRcdGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc291bmRTaXplJywgMSk7XG5cdFx0XHR9XG5cdFx0XHRzaXplID0gTnVtYmVyKHNpemUpO1xuXHRcdFx0dGhpcy5fc291bmRfc2l6ZSA9IHNpemU7XG5cblx0XHRcdGNjLmdhbWUub24oY2MuZ2FtZS5FVkVOVF9ISURFLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgY29uc29sZS5sb2coXCJjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbFwiKTtcblx0XHRcdCAgICBjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfU0hPVywgZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGNvbnNvbGUubG9nKFwiY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsXCIpO1xuXHRcdFx0ICAgIGNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRnZXRVcmw6ZnVuY3Rpb24odXJsKXtcblx0ICAgICAgICByZXR1cm4gY2MudXJsLnJhdyhcInJlc291cmNlcy9zb3VuZC9cIiArIHVybCArIFwiLm1wM1wiKTtcblx0ICAgIH0sXG5cblx0XHRwbGF5QkdNIDogZnVuY3Rpb24oIHVybCApe1xuXHRcdFx0dGhpcy5fY3VyYmdtID0gdXJsO1xuXHRcdFx0aWYodGhpcy5fc291bmRfc2l6ZSA8PSAwKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGF1ZGlvVXJsID0gdGhpcy5nZXRVcmwodXJsKTtcblx0XHRcdGNvbnNvbGUubG9nKGF1ZGlvVXJsKTtcblx0ICAgICAgICBpZih0aGlzLl9jdXJyZW50ID49IDApe1xuXHQgICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5zdG9wKHRoaXMuX2N1cnJlbnQpO1xuXHQgICAgICAgIH1cblx0XHRcdHRoaXMuX2N1cnJlbnQgPSBjYy5hdWRpb0VuZ2luZS5wbGF5KCBhdWRpb1VybCwgdHJ1ZSwgdGhpcy5fc291bmRfc2l6ZSk7XG5cdFx0fSxcblx0XHRzdG9wQkdNIDogZnVuY3Rpb24oKXtcblx0XHRcdGNjLmF1ZGlvRW5naW5lLnN0b3AoIHRoaXMuX2N1cnJlbnQgKTtcblx0XHR9LFxuXHRcdHBhdXNlQkdNOmZ1bmN0aW9uKCl7XG5cdFx0XHRjYy5hdWRpb0VuZ2luZS5wYXVzZSh0aGlzLl9jdXJyZW50KTtcblx0XHR9LFxuXHRcdHJlc3VtZUJHTTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjYy5hdWRpb0VuZ2luZS5yZXN1bWUodGhpcy5fY3VycmVudCk7XG5cdFx0fSxcblxuXHRcdHNldFNpemUgOiBmdW5jdGlvbiggc2l6ZSApe1xuXHRcdFx0aWYoIHNpemUgPCAwIHx8IHNpemUgPiAxICl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCB0aGlzLl9zb3VuZF9zaXplID09IHNpemUgKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zb3VuZF9zaXplID0gc2l6ZTtcblx0XHRcdGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc291bmRTaXplJywgdGhpcy5fc291bmRfc2l6ZSk7XG5cdFx0XHRpZiAoc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdGNjLmF1ZGlvRW5naW5lLnBhdXNlKHRoaXMuX2N1cnJlbnQpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGlmKCBOdW1iZXIodGhpcy5fY3VycmVudCkgPT0gMCApe1xuXHRcdFx0XHRcdGlmKCB0aGlzLl9jdXJiZ20gIT0gXCJcIiApe1xuXHRcdFx0XHRcdFx0dGhpcy5wbGF5QkdNKCB0aGlzLl9jdXJiZ20gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGNjLmF1ZGlvRW5naW5lLnJlc3VtZSh0aGlzLl9jdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVx0XHRcdFxuXHRcdH0sXG5cdFx0Z2V0U2l6ZSA6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc291bmRfc2l6ZTtcblx0XHR9LFxuXG5cdFx0cGxheSA6IGZ1bmN0aW9uKCB1cmwgKXtcblx0XHRcdGlmKHRoaXMuX3NvdW5kX3NpemUgPD0gMCl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBhdWRpb1VybCA9IHRoaXMuZ2V0VXJsKHVybCk7XG5cdFx0XHRjYy5hdWRpb0VuZ2luZS5wbGF5KCBhdWRpb1VybCwgZmFsc2UsIHRoaXMuX3NvdW5kX3NpemUpO1xuXHRcdFx0Ly8gY2MuYXVkaW9FbmdpbmUucGxheUVmZmVjdChhdWRpb1VybCwgZmFsc2UsIDEpXG5cdFx0fSxcblxuXHRcdHBsYXlOb3JtYWxCdG5DbGljayA6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLnBsYXkoXCJidG5DbGlja1wiKTtcblx0XHR9LFxuXHR9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQU1ncjsiLCJ2YXIgcGFja2V0ID0gcmVxdWlyZSggJ0xwYWNrYWdlJyApXG52YXIgRXJyb3JDb2RlID0gcmVxdWlyZShcImVycm9yY29kZVwiKVxudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxudmFyIFR1aUJpbmdDb25maWcgPSByZXF1aXJlKFwiVHVpQmluZ0NvbmZpZ1wiKVxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBwZXJCYW5rZXJMaXN0IDogY2MuU2Nyb2xsVmlldyxcbiAgICAgICAgaXRlbVByZWZvcmIgOiBjYy5QcmVmYWIsXG4gICAgICAgIGdvbGRQcmVmYWIgOiBjYy5QcmVmYWIsXG5cbiAgICAgICAgYmFua2VyTmFtZUxhYmVsIDogY2MuTGFiZWwsXG4gICAgICAgIGJhbmtlckdvbGRMYWJlbCA6IGNjLkxhYmVsLFxuICAgICAgICBiYW5rZXJUaW1lc0xhYmVsIDogY2MuTGFiZWwsXG5cbiAgICAgICAgbm90aWNlTGFiZWwgOiBjYy5MYWJlbCwgXG5cbiAgICAgICAgYmV0UG9vbExhYmVsIDogW2NjLkxhYmVsXSxcblxuICAgICAgICBtYUppYW5nTGlzdDpbY2MuTm9kZV0sXG4gICAgICAgIGJnTGlzdDpbY2MuTm9kZV0sXG5cbiAgICAgICAgYnRuQmVCYW5rZXIgOiBjYy5CdXR0b24sXG4gICAgICAgIGJ0blVuQmFua2VyIDogY2MuQnV0dG9uLFxuICAgICAgICBidG5LZWVwQmFua2VyIDogY2MuQnV0dG9uLFxuICAgICAgICBiYW5rZXJMYWJlbCA6IGNjLkxhYmVsLCBcblxuICAgICAgICBkaWNlIDogY2MuTm9kZSxcbiAgICAgICAgLy8gZ2FtZSBwYXJhbXNcbiAgICAgICAgX2Jhbmtlcl9pZCA6IDAsXG4gICAgICAgIF9iYW5rZXJfbmFtZSA6IG1zZ2NvZGUuVFVJQklOR19OT19CQU5LRVIsXG4gICAgICAgIF9nYW1lX3N0YXRlIDogMCxcbiAgICAgICAgX2Jhbmtlcl90aW1lcyA6IDAsXG4gICAgICAgIF9iYW5rZXJfZ29sZCA6IDAsXG5cbiAgICAgICAgX3NvdXRoX3Bvb2wgOiBuZXcgQXJyYXkoKSxcbiAgICAgICAgX3NreV9wb29sIDogbmV3IEFycmF5KCksXG4gICAgICAgIF9ub3J0aF9wb29sIDogbmV3IEFycmF5KCksXG5cbiAgICAgICAgX3NlbGVjdF9nb2xkIDogMCxcbiAgICAgICAgX2dvbGRfbGlzdCA6IFtjYy5JbnRlZ2VyXSxcbiAgICAgICAgX2Nhbl9iZXRfZ29sZCA6IDAsIFxuICAgICAgICBfYmVfYmFua2VyX2xpc3QgOiBbT2JqZWN0XSxcblxuICAgICAgICBfbWpfbW92ZV9rZXkgOiAxLFxuICAgICAgICBfbWpfb2xkX3BvcyA6IFtjYy5WZWMyXSxcblxuICAgICAgICBfdGltZXIgOiAwLFxuICAgICAgICBNYWppYW5nU3ByaXRlTGlzdCA6IGNjLlNwcml0ZUF0bGFzLFxuXG4gICAgICAgIF91bkJhbmtlckZsYWcgOiBmYWxzZSxcblxuICAgICAgICBfZ21Mb2dpYyA6IG51bGwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RfZ29sZCA9IDEwMDAwO1xuICAgICAgICB2YXIgb2JqID0ge3BsYXllcmlkOiAwLCBnb2xkIDogMH07XG4gICAgICAgIHRoaXMuX3NvdXRoX3Bvb2wucHVzaCggb2JqICk7XG4gICAgICAgIHRoaXMuX2dvbGRfbGlzdCA9IFsgMTAwMDAsIDEwMDAwMCwgMTAwMDAwMCwgNTAwMDAwMCwgMTAwMDAwMDAgXTtcbiAgICAgICAgLy8gdmFyIGJ0biA9IHRoaXMuZ29sZEJ0bkxzaXRbMF07XG4gICAgICAgIC8vIGlmKCBidG4gIT0gbnVsbCApe1xuICAgICAgICAvLyAgICAgdmFyIGJ1dHRvbiA9IGJ0bi5nZXRDb21wb25lbnQoY2MuQnV0dG9uKTtcbiAgICAgICAgLy8gICAgIHZhciBzZWxlY3RfZ29sZCA9IHBhcnNlSW50KGJ0bi5ub2RlLm5hbWUpICogVHVpQmluZ0NvbmZpZy5MZXNzR29sZDtcbiAgICAgICAgLy8gICAgIHZhciBtYXggPSBjYy5sbC5wTWdyLm1haW5fcm9sZS5nb2xkO1xuICAgICAgICAvLyAgICAgaWYoIHNlbGVjdF9nb2xkIDw9IG1heCl7XG4gICAgICAgIC8vICAgICAgICAgYnV0dG9uLmludGVyYWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuX3NlbGVjdF9nb2xkID0gc2VsZWN0X2dvbGQ7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gNDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoIFwiQ2FudmFzL0dhbWVCZ0xheWVyL01KTGlzdC9ncm91cFwiICsgaSk7XG4gICAgICAgICAgICB0aGlzLl9tal9vbGRfcG9zW2ktMV0gPSBub2RlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZVNldEdhbWUoKTtcblxuICAgICAgICB0aGlzLnNjaGVkdWxlT25jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxVHVpQmluZ0luZm9cIiApO1xuICAgICAgICAgICAgIGNjLmxsLm5ldC5zZW5kKCBwLnBhY2soKSApOyBcbiAgICAgICAgIH0sIDAuNSk7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKCBcIkNhbnZhcy9HYW1lQmdMYXllci9Ub3BCZy9UaW1lckJnL1RpbWVyXCIgKVxuICAgICAgICB2YXIgdGltZXJfbGFiZWwgPSBub2RlLmdldENvbXBvbmVudCggY2MuTGFiZWwgKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLl90aW1lciA+IDApe1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fdGltZXIgPj0gMTApe1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLl90aW1lci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIjBcIiArIHRoaXMuX3RpbWVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVyX2xhYmVsLnN0cmluZyA9IFwiMDA6XCIrc3RyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyIC0tO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGltZXJfbGFiZWwuc3RyaW5nID0gXCIwMDowMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfSElERSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfU0hPVywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnYW1lLnJlU2V0R2FtZVwiKTtcbiAgICAgICAgICAgIHZhciBzY2VuZW5hbWUgPSBjYy5kaXJlY3Rvci5nZXRTY2VuZSgpLm5hbWU7XG4gICAgICAgICAgICBpZiggc2NlbmVuYW1lICE9IFwidHVpYmluZ3ZpZXdcIiApe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVTZXRHYW1lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9HYW1lQmdMYXllci9HTUxheWVyXCIpO1xuICAgICAgICBpZihjYy5sbC5wTWdyLm1haW5fcm9sZS5nbWxldmVsID4gMCl7XG4gICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9nbUxvZ2ljID0gbm9kZS5nZXRDb21wb25lbnQoIFwiT25HbUxheWVyTG9hZFwiICk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZVNldEdhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLmJnTGlzdCA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmcgPSB0aGlzLmJnTGlzdFtpXTtcbiAgICAgICAgICAgIGJnLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iaiA9IHttYWppYW5nMTpcImJnXCIsIG1hamlhbmcyOlwiYmdcIn07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYUppYW5nTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hamlhbmdub2RlID0gdGhpcy5tYUppYW5nTGlzdFtpXTtcbiAgICAgICAgICAgIHRoaXMuT3Blbk1hamlhbmcoIG1hamlhbmdub2RlLCBvYmogKVxuICAgICAgICAgICAgdmFyIHBvaW50YmcgPSBtYWppYW5nbm9kZS5nZXRDaGlsZEJ5TmFtZSggXCJQb2ludEJnXCIgKTtcbiAgICAgICAgICAgIHBvaW50YmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYmV0UG9vbExhYmVsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmJldFBvb2xMYWJlbFtpXVxuICAgICAgICAgICAgbGFiZWwuc3RyaW5nID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYUppYW5nTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1hamlhbmdub2RlID0gdGhpcy5tYUppYW5nTGlzdFtpXTtcbiAgICAgICAgICAgIG1hamlhbmdub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKCBcIkNhbnZhcy9HYW1lQmdMYXllci9NSkxpc3QvZ3JvdXBcIiArIGkpO1xuICAgICAgICAgICAgbm9kZS5zZXRQb3NpdGlvbiggdGhpcy5fbWpfb2xkX3Bvc1tpLTFdICk7XG4gICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBub2RlLnN0b3BBbGxBY3Rpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGUuc3RvcEFsbEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fbWpfbW92ZV9rZXkgPSAxO1xuICAgICAgICBpZiAodGhpcy5fZ21Mb2dpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9nbUxvZ2ljLm9uUmVzZXRBbGwoKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRCYW5rZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmFua2VyX2lkID0gMDtcbiAgICAgICAgdGhpcy5fYmFua2VyX25hbWUgPSAwO1xuICAgICAgICB0aGlzLmJhbmtlck5hbWVMYWJlbC5zdHJpbmcgPSBtc2djb2RlLlRVSUJJTkdfTk9fQkFOS0VSO1xuICAgICAgICB0aGlzLmJhbmtlckdvbGRMYWJlbC5zdHJpbmcgPSAwO1xuICAgICAgICB0aGlzLmJhbmtlclRpbWVzTGFiZWwuc3RyaW5nID0gXCIwL1wiICsgVHVpQmluZ0NvbmZpZy5CYW5rZXJNYXhUaW1lcztcblxuICAgICAgICB0aGlzLmJ0bkJlQmFua2VyLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idG5VbkJhbmtlci5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bkJhbmtlckZsYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYW5rZXJMYWJlbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ0bktlZXBCYW5rZXIubm9kZS5hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5iZXRQb29sTGFiZWwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuYmV0UG9vbExhYmVsW2ldXG4gICAgICAgICAgICBsYWJlbC5zdHJpbmcgPSAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uUXVldWVDaGFuZ2VkOiBmdW5jdGlvbiggYmFua2VyLCBsaXN0ICkge1xuICAgICAgICBpZiAoIGJhbmtlci5iYW5rZXJpZCAhPSAwICl7XG4gICAgICAgICAgICB0aGlzLl9iYW5rZXJfaWQgPSBiYW5rZXIuYmFua2VyaWQ7XG4gICAgICAgICAgICB0aGlzLl9iYW5rZXJfbmFtZSA9IGJhbmtlci5iYW5rZXJuYW1lO1xuICAgICAgICAgICAgdGhpcy5iYW5rZXJOYW1lTGFiZWwuc3RyaW5nID0gdGhpcy5fYmFua2VyX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvR2FtZUJnTGF5ZXIvQmFua2VyTGlzdC92aWV3L2NvbnRlbnRcIik7XG4gICAgICAgIG5vZGUucmVtb3ZlQWxsQ2hpbGRyZW4oKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaWQgPSBcIiArIGlkICsgXCI7bmFtZSA9IFwiKyBuYW1lKTtcbiAgICAgICAgdmFyIGZpbmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGxpc3RbaV1cbiAgICAgICAgICAgIHZhciBpdGVtID0gY2MuaW5zdGFudGlhdGUodGhpcy5pdGVtUHJlZm9yYik7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gaXRlbS5nZXRDb21wb25lbnQoXCJQcmVCYW5rZXJJdGVtXCIpO1xuICAgICAgICAgICAgc3ByaXRlLm9uQ2hhbmdlTmFtZSggMSwgaW5mby5wbGF5ZXJpZCwgaW5mby5wbGF5ZXJuYW1lLCBpbmZvLnR5cGUgKTtcbiAgICAgICAgICAgIGl0ZW0ueCA9IDA7XG4gICAgICAgICAgICBpdGVtLnkgPSAtIGkgKiA0MDtcbiAgICAgICAgICAgIG5vZGUuYWRkQ2hpbGQoIGl0ZW0gKVxuICAgICAgICAgICAgaWYoIGluZm8ucGxheWVyaWQgPT0gY2MubGwucE1nci5tYWluX3JvbGUuaWQgKXtcbiAgICAgICAgICAgICAgICBmaW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gbGlzdC5sZW5ndGggKiA0MDtcblxuICAgICAgICB2YXIgbGVhdmVidG4gPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyL0xlYXZlUXVldWVCdG5cIik7XG4gICAgICAgIGxlYXZlYnRuLmFjdGl2ZSA9IGZpbmQ7XG4gICAgICAgIHRoaXMuX2JlX2Jhbmtlcl9saXN0ID0gbGlzdDtcbiAgICB9LFxuXG4gICAgb25HYW1lU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2dhbWVfc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaChzdGF0ZSl7XG4gICAgICAgICAgICBjYXNlIFR1aUJpbmdDb25maWcuU3RhdGUuU3RvcDp7XG4gICAgICAgICAgICAgICAgdGhpcy5yZVNldEdhbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRCYW5rZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuVFVJQklOR19TVEFURV9TVE9QKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZUxhYmVsLnN0cmluZyA9IG1zZ2NvZGUuVFVJQklOR19TVEFURV9TVE9QO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gMDtcbiAgICAgICAgICAgIH1icmVhaztcbiAgICAgICAgICAgIGNhc2UgVHVpQmluZ0NvbmZpZy5TdGF0ZS5CZWdpbjp7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBUdWlCaW5nQ29uZmlnLlN0YXRlLkJlZ2luX0NoZWNrX0JlZ2luOntcbiAgICAgICAgICAgICAgICB0aGlzLnJlU2V0R2FtZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gVHVpQmluZ0NvbmZpZy5UaW1lLkJlZ2luO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWNlTGFiZWwuc3RyaW5nID0gbXNnY29kZS5UVUlCSU5HX1NUQVRFX0JFR0lOO1xuICAgICAgICAgICAgfWJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUdWlCaW5nQ29uZmlnLlN0YXRlLkJlZ2luX0NoZWNrX0tlZXA6e1xuICAgICAgICAgICAgICAgIC8vIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5UVUlCSU5HX1NUQVRFX0JFR0lOKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZUxhYmVsLnN0cmluZyA9IG1zZ2NvZGUuVFVJQklOR19TVEFURV9CRUdJTjtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IFR1aUJpbmdDb25maWcuVGltZS5CZWdpbl9rZWVwO1xuICAgICAgICAgICAgfWJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUdWlCaW5nQ29uZmlnLlN0YXRlLlJlYWR5OntcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZUxhYmVsLnN0cmluZyA9IG1zZ2NvZGUuVFVJQklOR19TVEFURV9SRUFEWTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IFR1aUJpbmdDb25maWcuVGltZS5CZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dtTG9naWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbUxvZ2ljLm9uRW5hYmxlQWxsKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9YnJlYWs7XG4gICAgICAgICAgICBjYXNlIFR1aUJpbmdDb25maWcuU3RhdGUuV2FpdE9wZW46e1xuICAgICAgICAgICAgICAgIC8vIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5UVUlCSU5HX1NUQVRFX1dBSVRPUEVOKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGljZUxhYmVsLnN0cmluZyA9IG1zZ2NvZGUuVFVJQklOR19TVEFURV9XQUlUT1BFTjtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IFR1aUJpbmdDb25maWcuVGltZS5XYWl0O1xuICAgICAgICAgICAgfWJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUdWlCaW5nQ29uZmlnLlN0YXRlLk9wZW5uaW5nOntcbiAgICAgICAgICAgICAgICAvLyBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuVFVJQklOR19TVEFURV9PUEVOTklORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2VMYWJlbC5zdHJpbmcgPSBtc2djb2RlLlRVSUJJTkdfU1RBVEVfT1BFTk5JTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBUdWlCaW5nQ29uZmlnLlRpbWUuT3BlbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ21Mb2dpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dtTG9naWMub25VbmFibGVBbGwoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1icmVhaztcbiAgICAgICAgICAgIGNhc2UgVHVpQmluZ0NvbmZpZy5TdGF0ZS5SZXdhcmQ6e1xuICAgICAgICAgICAgICAgIC8vIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5UVUlCSU5HX1NUQVRFX1JFV0FSRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpY2VMYWJlbC5zdHJpbmcgPSBtc2djb2RlLlRVSUJJTkdfU1RBVEVfUkVXQVJEO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gVHVpQmluZ0NvbmZpZy5UaW1lLlJld2FyZDsgXG4gICAgICAgICAgICB9YnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25QbGF5ZXJCZXQgOiBmdW5jdGlvbiAoIGlkLCBwb3MsIGdvbGQgKXtcbiAgICAgICAgdmFyIGJnc3RyID0gXCJcIjtcbiAgICAgICAgaWYgKHBvcyA9PSAxKSB7XG4gICAgICAgICAgICBiZ3N0ciA9IFwiQ2FudmFzL0dhbWVCZ0xheWVyL0dhbWVCZy9Tb3V0aEJnXCI7XG4gICAgICAgIH1lbHNlIGlmIChwb3MgPT0gMikge1xuICAgICAgICAgICAgYmdzdHIgPSBcIkNhbnZhcy9HYW1lQmdMYXllci9HYW1lQmcvU2t5QmdcIjtcbiAgICAgICAgfWVsc2UgaWYgKHBvcyA9PSAzKSB7XG4gICAgICAgICAgICBiZ3N0ciAgPSBcIkNhbnZhcy9HYW1lQmdMYXllci9HYW1lQmcvTm9ydGhCZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZ3N0ci5sZW5ndGggPD0gNSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgIGlmICggZ29sZCA8IDEwMDAwMCApe1xuICAgICAgICAgICAgbnVtID0gMTtcbiAgICAgICAgfWVsc2UgaWYgKGdvbGQgPj0gMTAwMDAwICYmIGdvbGQgPCAxMDAwMDAwKSB7XG4gICAgICAgICAgICBudW0gPSAyO1xuICAgICAgICB9ZWxzZSBpZiAoZ29sZCA+PSAxMDAwMDAwICkge1xuICAgICAgICAgICAgbnVtID0gMztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoIGJnc3RyICk7XG4gICAgICAgIHZhciBiZWdpbnBvcyA9IGNjLlZlYzIuWkVSTztcbiAgICAgICAgaWYoaWQgPT0gY2MubGwucE1nci5tYWluX3JvbGUuaWQpe1xuICAgICAgICAgICAgdmFyIGJub2RlID0gY2MuZmluZCggXCJDYW52YXMvR2FtZUJnTGF5ZXIvQnV0dHVtQmcvZ29sZGZsYWdcIiApO1xuICAgICAgICAgICAgdmFyIHdvcmxkX3BvcyA9IGJub2RlLmNvbnZlcnRUb1dvcmxkU3BhY2UoIGNjLlZlYzIuWkVSTyApO1xuICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuY29udmVydFRvTm9kZVNwYWNlKCB3b3JsZF9wb3MgKTtcbiAgICAgICAgICAgIGJlZ2lucG9zID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSpub2RlLndpZHRoKSAtIG5vZGUud2lkdGggLyAyO1xuICAgICAgICAgICAgeCA9IHg+MD94LTMwOngrMzA7XG4gICAgICAgICAgICB2YXIgeSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSpub2RlLmhlaWdodCkgLSBub2RlLmhlaWdodCAvIDI7XG4gICAgICAgICAgICB5ID0geT4wP3ktMzA6eSszMDtcbiAgICAgICAgICAgIHZhciBnb2xkID0gY2MuaW5zdGFudGlhdGUodGhpcy5nb2xkUHJlZmFiKTtcbiAgICAgICAgICAgIGlmIChiZWdpbnBvcy54ICE9IDApIHtcbiAgICAgICAgICAgICAgICBnb2xkLnggPSBiZWdpbnBvcy54O1xuICAgICAgICAgICAgICAgIGdvbGQueSA9IGJlZ2lucG9zLnk7ICAgIFxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZ29sZC54ID0geDtcbiAgICAgICAgICAgICAgICBnb2xkLnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZCggZ29sZCApO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGNjLm1vdmVUbyggMC41LCBjYy5wKHgseSkgKTtcbiAgICAgICAgICAgIGdvbGQucnVuQWN0aW9uKCBhY3Rpb24uZWFzaW5nKGNjLmVhc2VPdXQoMy4wKSkgKTtcbiAgICAgICAgfVxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheShcImRyb3BHb2xkXCIpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RHb2xkQnRuIDogZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSA1OyBpKyspe1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKCBcIkNhbnZhcy9HYW1lQmdMYXllci9CdXR0dW1CZy90b2dnbGVHcm91cC90b2dnbGVcIiArIGkpO1xuICAgICAgICAgICAgdmFyIHRvZ2dsZSA9IG5vZGUuZ2V0Q29tcG9uZW50KGNjLlRvZ2dsZSk7XG4gICAgICAgICAgICBpZihpID09IGtleSl7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLmlzQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0b2dnbGUuaXNDaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25BdXRvU2VsZWN0R29sZDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG1heCA9IGNjLmxsLnBNZ3IubWFpbl9yb2xlLmdvbGQ7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IodmFyIGkgPSB0aGlzLl9nb2xkX2xpc3QubGVuZ3RoIC0xOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgICB2YXIgc2VsZWN0X2dvbGQgPSB0aGlzLl9nb2xkX2xpc3RbaV07XG4gICAgICAgICAgICBpZiggc2VsZWN0X2dvbGQgPD0gdGhpcy5fY2FuX2JldF9nb2xkICl7XG4gICAgICAgICAgICAgICAgaWYoIHNlbGVjdF9nb2xkIDw9IG1heCApe1xuICAgICAgICAgICAgICAgICAgICBudW0gPSBpKzE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYobnVtID09IDApe1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RHb2xkQnRuKCAxICk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RfZ29sZCA9IHRoaXMuX2dvbGRfbGlzdFswXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEdvbGRCdG4oIG51bSApO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0X2dvbGQgPSB0aGlzLl9nb2xkX2xpc3RbbnVtLTFdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uQmV0R29sZCA6IGZ1bmN0aW9uKCBldmVudCwgcG9zICl7XG4gICAgICAgIGlmICggdGhpcy5fZ2FtZV9zdGF0ZSAhPSBUdWlCaW5nQ29uZmlnLlN0YXRlLlJlYWR5ICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heGdvbGQgPSBjYy5sbC5wTWdyLm1haW5fcm9sZS5nb2xkO1xuICAgICAgICBpZiAobWF4Z29sZCA8IFR1aUJpbmdDb25maWcuTGVzc0dvbGQpe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLkdPTERfTk9UX0VOT1VHSCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RfZ29sZCA9PTApIHtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5UVUlCSU5HX1NFTEVDVF9HT0xEKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLl9zZWxlY3RfZ29sZCA+IG1heGdvbGQgKXtcbiAgICAgICAgICAgIHRoaXMub25BdXRvU2VsZWN0R29sZCgpO1xuICAgICAgICAgICAgaWYoIHRoaXMuX3NlbGVjdF9nb2xkID4gbWF4Z29sZCApe1xuICAgICAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5HT0xEX05PVF9FTk9VR0gpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy5fc2VsZWN0X2dvbGQgPiB0aGlzLl9jYW5fYmV0X2dvbGQgKXtcbiAgICAgICAgICAgIHRoaXMub25BdXRvU2VsZWN0R29sZCgpO1xuICAgICAgICAgICAgaWYoIHRoaXMuX3NlbGVjdF9nb2xkID4gdGhpcy5fY2FuX2JldF9nb2xkICl7XG4gICAgICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLlRVSUJJTkdfTU9SRVRIQU5fQkFOS0VSKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcVR1aUJpbmdCZXRcIiApO1xuICAgICAgICBwLmxwYWNrLnBvcyA9IHBhcnNlSW50KHBvcyk7XG4gICAgICAgIHAubHBhY2suZ29sZCA9IHRoaXMuX3NlbGVjdF9nb2xkO1xuICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcbiAgICB9LFxuXG4gICAgb25TZWxlY3RHb2xkQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCwgZ29sZCApe1xuICAgICAgICB2YXIgbWF4ID0gY2MubGwucE1nci5tYWluX3JvbGUuZ29sZDtcbiAgICAgICAgdmFyIHNlbGVjdF9nb2xkID0gcGFyc2VJbnQoZ29sZCk7XG4gICAgICAgIGlmIChzZWxlY3RfZ29sZCA+IG1heCkge1xuICAgICAgICAgICAgdGhpcy5vbkF1dG9TZWxlY3RHb2xkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nb2xkQnRuTHNpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgdmFyIGJ0biA9IHRoaXMuZ29sZEJ0bkxzaXRbaV07XG4gICAgICAgIC8vICAgICB2YXIgYnV0dG9uID0gYnRuLmdldENvbXBvbmVudChjYy5CdXR0b24pO1xuICAgICAgICAvLyAgICAgYnV0dG9uLmludGVyYWN0YWJsZSA9IGJ0bi5ub2RlLm5hbWUgIT0gbm9kZS5uYW1lO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuX3NlbGVjdF9nb2xkID0gc2VsZWN0X2dvbGQ7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuXG4gICAgb25CZXRHb2xkQ291bnQ6IGZ1bmN0aW9uKCBnb2xkbGlzdCApe1xuICAgICAgICB2YXIgZ29sZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iZXRQb29sTGFiZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuYmV0UG9vbExhYmVsW2ldXG4gICAgICAgICAgICB2YXIgZyA9IGdvbGRsaXN0W2ldXG4gICAgICAgICAgICBsYWJlbC5zdHJpbmcgPSBnO1xuICAgICAgICAgICAgZ29sZCArPSBnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jYW5fYmV0X2dvbGQgPSB0aGlzLl9iYW5rZXJfZ29sZCAtIGdvbGQ7XG4gICAgfSxcbiAgICBEZWFsTWFqaWFuZ1BvcyA6IGZ1bmN0aW9uKCBub2RlLCBrZXkgKXtcbiAgICAgICAgdmFyIHRvX25vZGVfc3RyID0gXCJcIjtcbiAgICAgICAgc3dpdGNoKGtleSl7XG4gICAgICAgICAgICBjYXNlIDE6IHRvX25vZGVfc3RyID0gXCJDYW52YXMvR2FtZUJnTGF5ZXIvVG9wQmcvRGl6aHVNYWppYW5nQmdcIiA7YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IHRvX25vZGVfc3RyID0gXCJDYW52YXMvR2FtZUJnTGF5ZXIvR2FtZUJnL1NvdXRoTWFqaWFuZ0JnXCIgO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiB0b19ub2RlX3N0ciA9IFwiQ2FudmFzL0dhbWVCZ0xheWVyL0dhbWVCZy9Ta3lNYWppYW5nQmdcIiA7YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IHRvX25vZGVfc3RyID0gXCJDYW52YXMvR2FtZUJnTGF5ZXIvR2FtZUJnL05vcnRoTWFqaWFuZ0JnXCIgO2JyZWFrOyAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9fbm9kZSA9IGNjLmZpbmQoIHRvX25vZGVfc3RyICk7XG4gICAgICAgIHZhciB3b3JsZF90b3BvcyA9IHRvX25vZGUuY29udmVydFRvV29ybGRTcGFjZShjYy5WZWMyLlpFUk8pO1xuICAgICAgICB2YXIgbm9kZV90b3BvcyA9IG5vZGUucGFyZW50LmNvbnZlcnRUb05vZGVTcGFjZSggd29ybGRfdG9wb3MgKTtcbiAgICAgICAgdGhpcy5fbWpfbW92ZV9rZXkgKys7XG4gICAgICAgIHJldHVybiBub2RlX3RvcG9zO1xuICAgIH0sXG4gICAgT3Blbk1hamlhbmc6IGZ1bmN0aW9uKCBub2RlLCBvYmogKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbmdlc3ByaXRlID0gZnVuY3Rpb24oIHNwcml0ZV9ub2RlLCBzcHJpdGVfbmFtZSApe1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZV9ub2RlLmdldENvbXBvbmVudCggY2MuU3ByaXRlICk7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBzZWxmLk1hamlhbmdTcHJpdGVMaXN0LmdldFNwcml0ZUZyYW1lKCBzcHJpdGVfbmFtZSApO1xuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hamlhbmcxID0gbm9kZS5nZXRDaGlsZEJ5TmFtZSggXCJNYWppYW5nMVwiICk7XG4gICAgICAgIHZhciBtYWppYW5nMiA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoIFwiTWFqaWFuZzJcIiApO1xuICAgICAgICB2YXIgcG9pbnRiZyA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoIFwiUG9pbnRCZ1wiICk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbmFtZXNwciA9IFwiaW1nX21hamlhbmdfXCIgKyBvYmoubWFqaWFuZzFcbiAgICAgICAgY2hhbmdlc3ByaXRlKG1hamlhbmcxLCBuYW1lc3ByKVxuICAgICAgICBuYW1lc3ByID0gXCJpbWdfbWFqaWFuZ19cIiArIG9iai5tYWppYW5nMlxuICAgICAgICBjaGFuZ2VzcHJpdGUobWFqaWFuZzIsIG5hbWVzcHIpXG4gICAgICAgIGlmIChvYmoubWFqaWFuZzEgPT0gXCJiZ1wiKXtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBudW1zcHIgPSBwb2ludGJnLmdldENoaWxkQnlOYW1lKCBcIk51bVNwclwiICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIG9iai5tYWppYW5nMSA9PSBvYmoubWFqaWFuZzIgKXtcbiAgICAgICAgICAgIG5hbWVzcHIgPSBcImltZ19kb3VibGVfbnVtXCI7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmFyIG51bSA9IChvYmoubWFqaWFuZzErb2JqLm1hamlhbmcyKSUxMDtcbiAgICAgICAgICAgIG5hbWVzcHIgPSBcImltZ19cIisgbnVtICtcInBvaW50X251bVwiO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXNwcml0ZShudW1zcHIsIG5hbWVzcHIpO1xuICAgICAgICBmdW5jdGlvbiBzaG93bnVtKCl7XG4gICAgICAgICAgICBwb2ludGJnLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ydW5BY3Rpb24oIGNjLnNlcXVlbmNlKGNjLmRlbGF5VGltZSggMC41ICksIGNjLmNhbGxGdW5jKCBzaG93bnVtICkgKSAgKVxuICAgIH0sXG5cbiAgICAvLyBtYWppYW5ncyAwIGJhbmtlciAxIHNvdXRoIDIgc2t5IDMgbm9ydGgge21hamlhbmcxIG1hamlhbmcyfVxuICAgIG9uT3Blbk1hamlhbmc6IGZ1bmN0aW9uKCBtYWppYW5ncywgZGljZW51bTEsIGRpY2VudW0yICl7XG4gICAgICAgIC8vIOWFiOaSkumqsOWtkFxuICAgICAgICB2YXIgcmFuZG9tXzEgPSBkaWNlbnVtMTsgLy9NYXRoLmNlaWwoTWF0aC5yYW5kb20oKSo1ICsgMSk7XG4gICAgICAgIHZhciByYW5kb21fMiA9IGRpY2VudW0yOyAvL01hdGguY2VpbChNYXRoLnJhbmRvbSgpKjUgKyAxKTtcblxuICAgICAgICB0aGlzLmRpY2UuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuZGljZS5nZXRDb21wb25lbnQoIGNjLkFuaW1hdGlvbiApXG4gICAgICAgIHZhciBtYWppYW5nbGlzdCA9IHRoaXMubWFKaWFuZ0xpc3RcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGljZTEgPSBjYy5maW5kKCBcIi9DYW52YXMvR2FtZUJnTGF5ZXIvRGljZTFcIiApXG4gICAgICAgIHZhciBkaWNlMiA9IGNjLmZpbmQoIFwiL0NhbnZhcy9HYW1lQmdMYXllci9EaWNlMlwiIClcbiAgICAgICAgdmFyIGtleSA9IChyYW5kb21fMStyYW5kb21fMi0xKSU0KzE7IC8vIDF+NFxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgICBsaXN0W2ldID0gKGtleStpKT40P2tleStpLTQ6a2V5K2k7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpY2VhY3QgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5KFwidG91emlcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzdG9wYWN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGFjdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICBzZWxmLmRpY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2hvd2RpY2UgPSBmdW5jdGlvbihzcHJpdGVfbm9kZSwgc3ByaXRlX25hbWUpe1xuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVfbm9kZS5nZXRDb21wb25lbnQoIGNjLlNwcml0ZSApO1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHNlbGYuTWFqaWFuZ1Nwcml0ZUxpc3QuZ2V0U3ByaXRlRnJhbWUoIHNwcml0ZV9uYW1lICk7XG4gICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gZnJhbWU7XG4gICAgICAgICAgICAgICAgc3ByaXRlX25vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3dkaWNlKCBkaWNlMSwgXCJpbWdfZGljZV9cIiArIHJhbmRvbV8xICk7XG4gICAgICAgICAgICBzaG93ZGljZSggZGljZTIsIFwiaW1nX2RpY2VfXCIgKyByYW5kb21fMiApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoaWRlZGljZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkaWNlMS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRpY2UyLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBpZCA9IDA7XG4gICAgICAgICAgICB2YXIgbm9kZW1vdmV0byA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYoaWQgPiAzIHx8IGlkIDwgMCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1qX2tleSA9IGxpc3RbaWRdO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2MuZmluZCggXCJDYW52YXMvR2FtZUJnTGF5ZXIvTUpMaXN0L2dyb3VwXCIgKyBzZWxmLl9tal9tb3ZlX2tleSApO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYuRGVhbE1hamlhbmdQb3MoIG5vZGUsIG1qX2tleSApO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dtaigpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFqaWFuZ25vZGUgPSBzZWxmLm1hSmlhbmdMaXN0W21qX2tleS0xXTtcbiAgICAgICAgICAgICAgICAgICAgbWFqaWFuZ25vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGlkZWdyb3VwKCl7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUucnVuQWN0aW9uKGNjLnNlcXVlbmNlKGNjLm1vdmVUbygwLjUsIHBvcyksIGNjLmNhbGxGdW5jKGhpZGVncm91cCksIGNjLmNhbGxGdW5jKHNob3dtaikpKTtcbiAgICAgICAgICAgICAgICBpZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKFxuICAgICAgICAgICAgICAgIGNjLmNhbGxGdW5jKCBub2RlbW92ZXRvICksXG4gICAgICAgICAgICAgICAgY2MuZGVsYXlUaW1lKDAuNSksXG4gICAgICAgICAgICAgICAgY2MuY2FsbEZ1bmMoIG5vZGVtb3ZldG8gKSxcbiAgICAgICAgICAgICAgICBjYy5kZWxheVRpbWUoMC41KSxcbiAgICAgICAgICAgICAgICBjYy5jYWxsRnVuYyggbm9kZW1vdmV0byApLFxuICAgICAgICAgICAgICAgIGNjLmRlbGF5VGltZSgwLjUpLFxuICAgICAgICAgICAgICAgIGNjLmNhbGxGdW5jKCBub2RlbW92ZXRvICksXG4gICAgICAgICAgICAgICAgY2MuZGVsYXlUaW1lKDAuNSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZi5ub2RlLnJ1bkFjdGlvbiggY2Muc2VxdWVuY2UocXVldWUpIClcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbWFqaWFuZ2xpc3RbIGlkIF07XG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hamlhbmdzWyBpZCBdO1xuICAgICAgICAgICAgc2VsZi5PcGVuTWFqaWFuZyggbm9kZSwgbnVtcyApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuMSA9IGZ1bmN0aW9uKCl7b3BlbigwKTt9XG4gICAgICAgIHZhciBvcGVuMiA9IGZ1bmN0aW9uKCl7b3BlbigxKTt9XG4gICAgICAgIHZhciBvcGVuMyA9IGZ1bmN0aW9uKCl7b3BlbigyKTt9XG4gICAgICAgIHZhciBvcGVuNCA9IGZ1bmN0aW9uKCl7b3BlbigzKTt9XG5cbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLnB1c2goXG4gICAgICAgICAgICBjYy5jYWxsRnVuYyggZGljZWFjdCApLC8vMSBkaWNlIGFjdGlvbiBiZWdpbiBcbiAgICAgICAgICAgIGNjLmRlbGF5VGltZSgxLjUpLCAgICAgXG4gICAgICAgICAgICBjYy5jYWxsRnVuYyggc3RvcGFjdCApLCAvLzIgZGljZSBhY3Rpb24gc3RvcCwgc2hvdyBmaW5hbHkgbnVtYmVyXG4gICAgICAgICAgICBjYy5kZWxheVRpbWUoMSksXG4gICAgICAgICAgICBjYy5jYWxsRnVuYyggaGlkZWRpY2UgKSwgLy8zIGhpZGUgZGljZVxuICAgICAgICAgICAgY2MuZGVsYXlUaW1lKDAuNSksXG4gICAgICAgICAgICBjYy5jYWxsRnVuYyggbW92ZSApLCAgICAvL21vdmUgbWFqaWFuZ1xuICAgICAgICAgICAgY2MuZGVsYXlUaW1lKDIuNSksICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2MuY2FsbEZ1bmMoIG9wZW4xICksICAgLy8gb3BlbiBtYWppYW5nIG9uZSBieSBvbmVcbiAgICAgICAgICAgIGNjLmRlbGF5VGltZSggMSAgKSxcbiAgICAgICAgICAgIGNjLmNhbGxGdW5jKCBvcGVuMiApLFxuICAgICAgICAgICAgY2MuZGVsYXlUaW1lKCAxICApLFxuICAgICAgICAgICAgY2MuY2FsbEZ1bmMoIG9wZW4zICksXG4gICAgICAgICAgICBjYy5kZWxheVRpbWUoIDEgICksXG4gICAgICAgICAgICBjYy5jYWxsRnVuYyggb3BlbjQgKVxuICAgICAgICApO1xuICAgICAgICB2YXIgYWN0ID0gY2Muc2VxdWVuY2UocXVldWUpO1xuICAgICAgICB0aGlzLm5vZGUucnVuQWN0aW9uKGFjdCk7XG4gICAgfSxcblxuICAgIG9uQmFua2VySW5mbzogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgaWYgKCBvYmouaWQgPT0gMCApe1xuICAgICAgICAgICAgdGhpcy5pbml0QmFua2VyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmFua2VyX2lkID0gb2JqLmlkO1xuICAgICAgICB0aGlzLl9iYW5rZXJfbmFtZSA9IG9iai5uYW1lO1xuICAgICAgICB0aGlzLl9iYW5rZXJfdGltZXMgPSBvYmoudGltZXM7XG4gICAgICAgIHRoaXMuX2Jhbmtlcl9nb2xkID0gb2JqLmdvbGQ7XG4gICAgICAgIHRoaXMuYmFua2VyTmFtZUxhYmVsLnN0cmluZyA9IG9iai5uYW1lO1xuICAgICAgICB0aGlzLmJhbmtlckdvbGRMYWJlbC5zdHJpbmcgPSBvYmouZ29sZDtcbiAgICAgICAgdGhpcy5iYW5rZXJUaW1lc0xhYmVsLnN0cmluZyA9IG9iai50aW1lcyArIFwiL1wiICsgVHVpQmluZ0NvbmZpZy5CYW5rZXJNYXhUaW1lcztcblxuICAgICAgICBpZiAoIGNjLmxsLnBNZ3IubWFpbl9yb2xlLmlkID09IHRoaXMuX2Jhbmtlcl9pZCApe1xuICAgICAgICAgICAgaWYodGhpcy5fdW5CYW5rZXJGbGFnKXtcbiAgICAgICAgICAgICAgICB0aGlzLmJhbmtlckxhYmVsLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bkJlQmFua2VyLm5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5idG5VbkJhbmtlci5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnRuS2VlcEJhbmtlci5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5iYW5rZXJMYWJlbC5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnRuQmVCYW5rZXIubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ0blVuQmFua2VyLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ0bktlZXBCYW5rZXIubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuYnRuQmVCYW5rZXIubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5idG5VbkJhbmtlci5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5idG5LZWVwQmFua2VyLm5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl91bkJhbmtlckZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYmFua2VyTGFiZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW5fYmV0X2dvbGQgPSB0aGlzLl9iYW5rZXJfZ29sZFxuICAgIH0sXG4gICAgdGVzdEFkZEdvbGQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBhZGRnb2xkKCBzdHIgKXtcbiAgICAgICAgICAgIHZhciBub2RlID0gY2MuZmluZCggc3RyICk7XG4gICAgICAgICAgICB2YXIgbnVtID0gTWF0aC5jZWlsKCBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqMTApICsgMSk7XG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bTsgaSsrICl7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqbm9kZS53aWR0aCkgLSBub2RlLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB4ID0geD4wP3gtMzA6eCszMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSpub2RlLmhlaWdodCkgLSBub2RlLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHk+MD95LTMwOnkrMzA7XG4gICAgICAgICAgICAgICAgdmFyIGdvbGQgPSBjYy5pbnN0YW50aWF0ZShzZWxmLmdvbGRQcmVmYWIpO1xuICAgICAgICAgICAgICAgIGdvbGQueCA9IHg7XG4gICAgICAgICAgICAgICAgZ29sZC55ID0geTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZENoaWxkKCBnb2xkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3QgPSBbXCJDYW52YXMvR2FtZUJnTGF5ZXIvR2FtZUJnL1NvdXRoQmdcIixcIkNhbnZhcy9HYW1lQmdMYXllci9HYW1lQmcvU2t5QmdcIixcIkNhbnZhcy9HYW1lQmdMYXllci9HYW1lQmcvTm9ydGhCZ1wiXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhZGRnb2xkKGxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0ZXN0U2VuZFJld2FyZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFswLDEsMF07XG4gICAgICAgIHZhciBnb2xkID0gMTA7XG4gICAgICAgIHRoaXMub25TZW5kUmV3YXJkKCBsaXN0LCBnb2xkICk7XG4gICAgfSxcbiAgICBvblNlbmRSZXdhcmQgOiBmdW5jdGlvbihsaXN0LCBnb2xkbGlzdCkge1xuICAgICAgICB2YXIgYmFua2Vybm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvR2FtZUJnTGF5ZXIvVG9wQmcvRGl6aHVHb2xkXCIpO1xuICAgICAgICB2YXIgYmFua2VycG9zID0gYmFua2Vybm9kZS5jb252ZXJ0VG9Xb3JsZFNwYWNlKCBjYy5WZWMyLlpFUk8gKTtcbiAgICAgICAgdmFyIHBsYXllcm5vZGUgPSBjYy5maW5kKCBcIkNhbnZhcy9HYW1lQmdMYXllci9CdXR0dW1CZy9nb2xkZmxhZ1wiICk7XG4gICAgICAgIHZhciBwbGF5ZXJwb3MgPSBwbGF5ZXJub2RlLmNvbnZlcnRUb1dvcmxkU3BhY2UoIGNjLlZlYzIuWkVSTyApO1xuICAgICAgICB2YXIgZGF6aG9uZ25vZGUgPSBjYy5maW5kKCBcIkNhbnZhcy9HYW1lQmdMYXllci9BbGxQbGF5ZXJCdG5cIiApO1xuICAgICAgICB2YXIgZGF6aG9uZ3BvcyA9IGRhemhvbmdub2RlLmNvbnZlcnRUb1dvcmxkU3BhY2UoIGNjLlZlYzIuWkVSTyApO1xuICAgICAgICAvLyB0b3BvcyAwIGJhbmtlciAxIHNvdWNoIDIgc2t5IDMgbm9ydGggNCBwbGF5ZXJcbiAgICAgICAgZnVuY3Rpb24gbW92ZWdvbGQoIG5vZGUsIHRvcG9zLCBkZWxheSApe1xuICAgICAgICAgICAgdmFyIGVuZHBvcyA9IGNjLnAoMCwwKVxuICAgICAgICAgICAgaWYodG9wb3MgPT0gNCl7XG4gICAgICAgICAgICAgICAgZW5kcG9zID0gbm9kZS5wYXJlbnQuY29udmVydFRvTm9kZVNwYWNlKCBwbGF5ZXJwb3MgKTtcbiAgICAgICAgICAgIH1lbHNlIGlmKCB0b3BvcyA9PSA1KXtcbiAgICAgICAgICAgICAgICBlbmRwb3MgPSBub2RlLnBhcmVudC5jb252ZXJ0VG9Ob2RlU3BhY2UoIGRhemhvbmdwb3MgKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGVuZHBvcyA9IG5vZGUucGFyZW50LmNvbnZlcnRUb05vZGVTcGFjZSggYmFua2VycG9zICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGRlbGF5IHx8IDA7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gY2MubW92ZVRvKCAwLjUsIGVuZHBvcyApXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVub2RlKCl7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVGcm9tUGFyZW50KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucnVuQWN0aW9uKCBjYy5zZXF1ZW5jZSggY2MuZGVsYXlUaW1lKGQpLCBhY3Rpb24uZWFzaW5nKGNjLmVhc2VPdXQoMy4wKSApLCBjYy5jYWxsRnVuYyhyZW1vdmVub2RlKSApICk7XG4gICAgICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheShcImRyb3BDb2luXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGJhbmtlciB3aW5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYmFua2Vyd2luID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpc3dpbiA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGJnID0gc2VsZi5iZ0xpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gYmcuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYoaXN3aW4gPT0gMCl7Ly9iYW5rZXIgd2luXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWdvbGQoIGNoaWxkcmVuW2tdLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhbmVrZXJsb3NlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpc3dpbiA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGJnID0gc2VsZi5iZ0xpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gYmcuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYoaXN3aW4gIT0gMCl7Ly9iYW5rZXIgd2luXG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWdpbnBvcyA9IGJnLmNvbnZlcnRUb05vZGVTcGFjZSggYmFua2VycG9zICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbnVtOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKmJnLndpZHRoKSAtIGJnLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4PjA/eC0zMDp4KzMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqYmcuaGVpZ2h0KSAtIGJnLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geT4wP3ktMzA6eSszMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnb2xkID0gY2MuaW5zdGFudGlhdGUoc2VsZi5nb2xkUHJlZmFiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvbGQueCA9IGJlZ2lucG9zLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb2xkLnkgPSBiZWdpbnBvcy55O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmcuYWRkQ2hpbGQoIGdvbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBjYy5tb3ZlVG8oIDAuNSwgY2MucCh4LHkpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb2xkLnJ1bkFjdGlvbiggYWN0aW9uLmVhc2luZyhjYy5lYXNlT3V0KDMuMCkpICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoIG51bSA+IDAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5KFwiZHJvcENvaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYXllcndpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzd2luID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgYmcgPSBzZWxmLmJnTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBiZy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gTWF0aC5jZWlsKCBjaGlsZHJlbi5sZW5ndGggLyAyICk7XG4gICAgICAgICAgICAgICAgaWYoaXN3aW4gIT0gMCl7Ly9wbGF5ZXIgd2luXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ29sZGxpc3RbIGkgXSA8PSAwICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNoaWxkcmVuLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihrIDw9IG51bSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWdvbGQoY2hpbGRyZW5ba10sIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWdvbGQoY2hpbGRyZW5ba10sIDUsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnJ1bkFjdGlvbiggY2Muc2VxdWVuY2UoIFxuICAgICAgICAgICAgY2MuY2FsbEZ1bmMoIGJhbmtlcndpbiApLFxuICAgICAgICAgICAgY2MuZGVsYXlUaW1lKCAwLjggKSxcbiAgICAgICAgICAgIGNjLmNhbGxGdW5jKCBiYW5la2VybG9zZSApLFxuICAgICAgICAgICAgY2MuZGVsYXlUaW1lKCAwLjggKSxcbiAgICAgICAgICAgIGNjLmNhbGxGdW5jKCBwbGF5ZXJ3aW4gKSxcbiAgICAgICAgKSk7XG4gICAgfSxcblxuICAgIGNhbkJlQmFua2VyIDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKCBjYy5sbC5wTWdyLm1haW5fcm9sZS5pZCA9PSB0aGlzLl9iYW5rZXJfaWQgKXtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckNvZGUuVVJfQkFOS0VSO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYmVfYmFua2VyX2xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYmVfYmFua2VyX2xpc3RbaV1cbiAgICAgICAgICAgIGlmKCBjYy5sbC5wTWdyLm1haW5fcm9sZS5pZCA9PSBpbmZvLnBsYXllcmlkICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29kZS5IQVNfSU5fUVVFVUVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgb25TaG93QWxsUGxheWVyIDogZnVuY3Rpb24oIGxpc3QgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyL0FsbFBsYXllckxpc3QvcHZpZXcvcGNvbnRlbnRcIik7XG4gICAgICAgIG5vZGUucmVtb3ZlQWxsQ2hpbGRyZW4oKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gbGlzdFtpXVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYy5pbnN0YW50aWF0ZSh0aGlzLml0ZW1QcmVmb3JiKTtcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBpdGVtLmdldENvbXBvbmVudChcIlByZUJhbmtlckl0ZW1cIik7XG4gICAgICAgICAgICBzcHJpdGUub25DaGFuZ2VOYW1lKCAyLCBpbmZvLmlkLCBpbmZvLm5hbWUsIDEgKTtcbiAgICAgICAgICAgIGl0ZW0ueCA9IDA7XG4gICAgICAgICAgICBpdGVtLnkgPSAtIGkgKiA0MDtcbiAgICAgICAgICAgIG5vZGUuYWRkQ2hpbGQoIGl0ZW0gKVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gbGlzdC5sZW5ndGggKiA0MDtcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyL0FsbFBsYXllckxpc3QvZGV0YWlsXCIpO1xuICAgICAgICBub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBvblNob3dQbGF5ZXJEZXRhaWwgOiBmdW5jdGlvbiAoIGZyb20sIGlkLCBuYW1lICl7XG4gICAgICAgIGlmKGZyb20gPT0gMil7XG4gICAgICAgICAgICB2YXIgZGV0YWlsID0gY2MuZmluZCggXCJDYW52YXMvR2FtZUJnTGF5ZXIvQWxsUGxheWVyTGlzdC9kZXRhaWxcIiApO1xuICAgICAgICAgICAgaWYoZGV0YWlsLmFjdGl2ZSA9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgZGV0YWlsLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWRub2RlID0gZGV0YWlsLmdldENoaWxkQnlOYW1lKFwiSURcIik7XG4gICAgICAgICAgICB2YXIgaWRsYWJlbCA9IGlkbm9kZS5nZXRDb21wb25lbnQoIGNjLkxhYmVsICk7XG4gICAgICAgICAgICBpZiAoaWRsYWJlbC5zdHJpbmcgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICBpZGxhYmVsLnN0cmluZyA9IDA7XG4gICAgICAgICAgICAgICAgZGV0YWlsLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkbGFiZWwuc3RyaW5nID0gaWQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuYW1lbm9kZSA9IGRldGFpbC5nZXRDaGlsZEJ5TmFtZShcIk5hbWVcIik7XG4gICAgICAgICAgICB2YXIgbmFtZWxhYmVsID0gbmFtZW5vZGUuZ2V0Q29tcG9uZW50KCBjYy5MYWJlbCApO1xuICAgICAgICAgICAgbmFtZWxhYmVsLnN0cmluZyA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG4iLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkxhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIGRlZmF1bHRzLCBzZXQgdmlzdWFsbHkgd2hlbiBhdHRhY2hpbmcgdGhpcyBzY3JpcHQgdG8gdGhlIENhbnZhc1xuICAgICAgICB0ZXh0OiAnSGVsbG8sIFdvcmxkISdcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFiZWwuc3RyaW5nID0gdGhpcy50ZXh0O1xuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWVcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgfSxcbn0pO1xuIiwidmFyIExMRXZlbnQgPSBjYy5DbGFzcyh7XG4gICAgLy8gZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuICAgIHByb3BlcnRpZXM6IHtcblxuICAgIH0sXG4gICAgc3RhdGljczoge1xuICAgIFx0SW5kZXggOiAxMDAwLFxuICAgIFx0UmVnSW5kZXggOiAxMDAwLFxuICAgIFx0RXZlbnRRdWV1ZSA6IG5ldyBPYmplY3QsXG4gICAgXHRSZWdRdWV1ZSA6IG5ldyBPYmplY3QsXG5cbiAgICBcdGFkZEV2ZW50IDogZnVuY3Rpb24oIGZ1bmMgKXtcbiAgICBcdFx0aWYoIGZ1bmMgPT0gbnVsbCB8fCB0eXBlb2YoZnVuYykgIT0gXCJmdW5jdGlvblwiICl7XG4gICAgXHRcdFx0cmV0dXJuIDA7XG4gICAgXHRcdH1cbiAgICBcdFx0dGhpcy5JbmRleCArKztcbiAgICBcdFx0dGhpcy5FdmVudFF1ZXVlW3RoaXMuSW5kZXhdID0gZnVuYztcbiAgICBcdFx0cmV0dXJuIHRoaXMuSW5kZXg7XG4gICAgXHR9LFxuXG4gICAgXHRkZWxFdmVudCA6IGZ1bmN0aW9uKCBpZCApe1xuICAgIFx0XHR0aGlzLkV2ZW50UXVldWVbaWRdID0gbnVsbDtcbiAgICBcdH0sXG5cbiAgICBcdGRpc3BhdGNoRXZlbnQgOiBmdW5jdGlvbiggaWQsIG9iaiApe1xuICAgIFx0XHR2YXIgZnVuYyA9IHRoaXMuRXZlbnRRdWV1ZVtpZF07XG4gICAgXHRcdGlmKCB0eXBlb2YoZnVuYykgPT0gXCJmdW5jdGlvblwiICl7XG4gICAgXHRcdFx0ZnVuYyhvYmopO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuXG4gICAgXHRyZWdpc3RlciA6IGZ1bmN0aW9uKCBrZXksIG5vZGUsIGZ1bmMgKXtcbiAgICBcdFx0aWYoIGZ1bmMgPT0gbnVsbCB8fCB0eXBlb2YoZnVuYykgIT0gXCJmdW5jdGlvblwiICl7XG4gICAgXHRcdFx0cmV0dXJuO1xuICAgIFx0XHR9XG4gICAgXHRcdGlmICh0aGlzLlJlZ1F1ZXVlW2tleV0gPT0gbnVsbCl7XG4gICAgXHRcdFx0dGhpcy5SZWdRdWV1ZVtrZXldID0ge307XG4gICAgXHRcdH1cbiAgICBcdFx0dGhpcy5SZWdRdWV1ZVtrZXldW3RoaXMuUmVnSW5kZXhdID0gZnVuYztcbiAgICBcdFx0cmV0dXJuIHRoaXMuUmVnSW5kZXg7XG4gICAgXHR9LFxuICAgIFx0dW5yZWdpc3RlciA6IGZ1bmN0aW9uKCBrZXksIG5vZGUgKSB7XG4gICAgXHRcdHRoaXMuUmVnUXVldWVba2V5XVtub2RlXSA9IG51bGw7XG4gICAgXHR9LFxuXG4gICAgXHRkaXNwYXRjaFJlZ2lzdGVyIDogZnVuY3Rpb24oIGtleSApIHtcblxuICAgIFx0fSxcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTExFdmVudDsiLCJ2YXIgTE9BRElOR19ESUFMT0dfVEFHID0gOTA5ODc2O1xuXG52YXIgTG9hZGluZyA9IGNjLkNsYXNzKHtcblx0c3RhdGljczp7XG5cdFx0cGZhYiA6IG51bGwsXG5cdFx0aXNJbml0IDogZmFsc2UsXG5cdFx0aW5pdCA6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjYy5sb2FkZXIubG9hZFJlcyhcInByb2ZhYi9Mb2FkaW5nTGF5ZXJcIiwgZnVuY3Rpb24gKGVyciwgcHJlZmFiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wZmFiID0gcHJlZmFiO1xuICAgICAgICAgICAgICAgIHNlbGYuaXNJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXHRcdH0sXG5cblx0XHRhZGRMb2FkaW5nIDogZnVuY3Rpb24oIHQgKXtcblx0XHRcdGlmKCB0aGlzLmlzSW5pdCApe1xuXHRcdFx0XHR2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMucGZhYik7XG5cdFx0XHRcdHZhciBhY3QgPSBub2RlLmdldENvbXBvbmVudCggY2MuQW5pbWF0aW9uIClcblx0XHRcdFx0YWN0LnBsYXkoKVxuXHRcdFx0XHRjYy5kaXJlY3Rvci5nZXRTY2VuZSgpLmFkZENoaWxkKG5vZGUsIDk5OSwgTE9BRElOR19ESUFMT0dfVEFHKTtcblx0XHRcdFx0aWYgKHQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHQgPSAxMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZWxmLnJlbW92ZUxvYWRpbmcoKTt9LCB0KjEwMDApXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmVMb2FkaW5nIDogZnVuY3Rpb24oKXtcblx0XHRcdHZhciBub2RlID0gY2MuZGlyZWN0b3IuZ2V0U2NlbmUoKS5nZXRDaGlsZEJ5VGFnKExPQURJTkdfRElBTE9HX1RBRyk7XG5cdFx0XHRpZiggbm9kZSAhPSBudWxsICl7XG5cdFx0XHRcdGNjLmRpcmVjdG9yLmdldFNjZW5lKCkucmVtb3ZlQ2hpbGRCeVRhZyggTE9BRElOR19ESUFMT0dfVEFHICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRpbmc7IiwiLy9McGFja2FnZS5qc1xudmFyIEJ5dGVCdWZmZXIgPSByZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKTtcbnZhciBMcGFja2FnZSA9IGNjLkNsYXNzKHtcblx0Ly8gZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXHRuYW1lOiBcIkxwYWNrYWdlXCIsXG5cdHByb3BlcnRpZXM6IHtcblx0XHRfaGVhZCA6IFwiXCIsXG5cdFx0X3RoZWFkIDogXCJcIixcblx0XHRfYnVpbGRlciA6IG51bGwsXG5cdH0sXG5cdHN0YXRpY3M6IHtcblx0XHRscGFjayA6IG51bGwsXG5cdFx0bXNnIDogbnVsbCxcblx0fSxcblx0Y3RvciA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoZWFkID0gYXJndW1lbnRzWzBdO1xuXHRcdHRoaXMuX2hlYWQgPSBoZWFkO1xuXHRcdHRoaXMuX3RoZWFkID0gXCJ0dXRvcmlhbC5cIiArIGhlYWQ7XG5cdFx0dGhpcy5fYnVpbGRlciA9IGNjLmxsLnBiLmJ1aWxkKHRoaXMuX3RoZWFkKTtcblx0XHR0aGlzLmxwYWNrID0gbmV3IHRoaXMuX2J1aWxkZXIoKTtcblx0fSxcblxuXHRwYWNrIDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXQgPSBuZXcgQnl0ZUJ1ZmZlcigpO1xuXHRcdHJldC53cml0ZVNob3J0KCB0aGlzLl9oZWFkLmxlbmd0aCApO1xuXHRcdHJldC53cml0ZVN0cmluZyggdGhpcy5faGVhZCApO1xuXHRcdHJldC5hcHBlbmQoIHRoaXMubHBhY2suZW5jb2RlKCkgKTtcblx0XHRyZXQuZmxpcCgpO1xuXHRcdHJldHVybiByZXQudG9CdWZmZXIoKTtcblx0fSxcblxuXHR1bnBhY2sgOiBmdW5jdGlvbihidWZmZXIpIHtcblx0XHRpZihidWZmZXIgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5tc2cgPSB0aGlzLl9idWlsZGVyLmRlY29kZShidWZmZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tc2c7XG5cdH0sXG59KTtcbm1vZHVsZS5leHBvcnRzID0gTHBhY2thZ2U7IiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwidmFyIEJ5dGVCdWZmZXIgPSByZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKTtcblxudmFyIFNvY2tldFN0YXRlID0ge1xuICAgIFVuSW5pdCA6IDAsXG4gICAgTGlua2luZyA6IDEsXG4gICAgTGlua2VkIDogMixcbiAgICBDbG9zZSA6IDMsXG59XG5cbnZhciBsd2Vic29ja2V0ID0gY2MuQ2xhc3Moe1xuICAgIC8vIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBuYW1lIDogXCJsd2Vic29ja2V0XCIsXG4gICAgc3RhdGljczoge1xuICAgICAgICBpcCA6IFwiXCIsXG4gICAgICAgIHBvcnQgOiAwLFxuICAgICAgICByZWFkZXIgOiBudWxsLFxuICAgICAgICBzb2NrZXQgOiBudWxsLFxuICAgICAgICBzdGF0ZSA6IFNvY2tldFN0YXRlLlVuSW5pdCxcbiAgICAgICAgbXNnZGlzcGF0Y2ggOiBudWxsLFxuICAgICAgICBxdWV1ZSA6IG51bGwsXG4gICAgICAgIHdvcmtpbmcgOiBmYWxzZSxcblxuICAgICAgICBpbml0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZGVuZFwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCggZGF0YSApXG4gICAgICAgICAgICAgICAgYnVmZmVyLmZsaXAoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLnJlYWRTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkID0gYnVmZmVyLnJlYWRTdHJpbmcoIGxlbiApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2UgdGV4dCBtc2c6IFwiICsgaGVhZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tc2dkaXNwYXRjaC5kaXNwYXRjaCggaGVhZCwgYnVmZmVyLnRvQnVmZmVyKCkgKVxuICAgICAgICAgICAgICAgIC8vIHNlbGYud29ya2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tZXNzYWdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoIFwib25lcnJvclwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8vIHNlbGYud29ya2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tZXNzYWdlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdGhpcy5tc2dkaXNwYXRjaCA9IHJlcXVpcmUoXCJtc2dkaXNwYXRjaFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZG9tZXNzYWdlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYoIHRoaXMucmVhZGVyLnJlYWR5U3RhdGUgIT0gMSApe1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5xdWV1ZS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6ZnVuY3Rpb24oaXAsIHBvcnQsIGZuQ29ubmVjdCwgZm5FcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pcCA9IGlwO1xuICAgICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgIHZhciB3cyA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vJyt0aGlzLmlwKyc6Jyt0aGlzLnBvcnQrJy93cycpO1xuICAgICAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kIFRleHQgV1Mgd2FzIG9wZW5lZC5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFNvY2tldFN0YXRlLkxpbmtlZDtcbiAgICAgICAgICAgICAgICBpZiggZm5Db25uZWN0ICl7XG4gICAgICAgICAgICAgICAgICAgIGZuQ29ubmVjdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzcG9uc2UgdGV4dCBtc2c6IFwiICsgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5xdWV1ZS5wdXNoKCBldmVudC5kYXRhICk7XG4gICAgICAgICAgICAgICAgaWYoc2VsZi5xdWV1ZS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kb21lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VuZCBUZXh0IGZpcmVkIGFuIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBTb2NrZXRTdGF0ZS5DbG9zZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cy5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXZWJTb2NrZXQgaW5zdGFuY2UgY2xvc2VkLlwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXRlID0gU29ja2V0U3RhdGUuQ2xvc2U7XG4gICAgICAgICAgICAgICAgaWYoZm5FcnJvcil7XG4gICAgICAgICAgICAgICAgICAgIGZuRXJyb3IoKVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB3cztcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZCA6IGZ1bmN0aW9uKGJ1ZmZlcil7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGJ1ZmZlcik7XG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGx3ZWJzb2NrZXQ7IiwidmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxuXG52YXIgTXNnYm94ID0gY2MuQ2xhc3Moe1xuICAgIC8vIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgYmcgOiBudWxsLFxuICAgICAgICBhZGRNc2cgOiBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLmJnID09PSBudWxsICl7XG4gICAgICAgICAgICAgICAgdGhpcy5iZyA9IGNjLmZpbmQoXCJNc2dCb3hMYXllclwiKTtcbiAgICAgICAgICAgICAgICBjYy5nYW1lLmFkZFBlcnNpc3RSb290Tm9kZSh0aGlzLmJnKTtcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5iZyA9PT0gbnVsbCApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIHR5cGVvZiggbXNnICkgPT0gXCJudW1iZXJcIiApe1xuICAgICAgICAgICAgICAgIG1zZyA9IG1zZ2NvZGVbIG1zZyBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1zZ25vZGUgPSBuZXcgY2MuTm9kZSgpO1xuICAgICAgICAgICAgbXNnbm9kZS5jb2xvciA9IGNjLmNvbG9yKDAsIDI1NSwgNjgsIDI1NSk7XG4gICAgICAgICAgICB2YXIgbXNnbGFiZWwgPSBtc2dub2RlLmFkZENvbXBvbmVudChjYy5MYWJlbCk7XG4gICAgICAgICAgICBtc2dsYWJlbC5zdHJpbmcgPSBtc2c7XG4gICAgICAgICAgICBtc2dsYWJlbC5mb250U2l6ZSA9IDIwO1xuICAgICAgICAgICAgbXNnbm9kZS5zZXRQb3NpdGlvbiggMCwgLTUwICk7XG4gICAgICAgICAgICBtc2dub2RlLnBhcmVudCA9IHRoaXMuYmc7XG4gICAgICAgICAgICB2YXIgZGVsbGFiZWwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIG1zZ25vZGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfTsgIFxuICAgICAgICAgICAgdmFyIGFjdDEgPSBjYy5tb3ZlQnkoMSwgY2MucCgwLCAxMDApKTtcbiAgICAgICAgICAgIHZhciBhY3QyMSA9IGNjLmRlbGF5VGltZSgwLjUpO1xuICAgICAgICAgICAgdmFyIGFjdDIyID0gY2MuZmFkZU91dCgwLjUpO1xuICAgICAgICAgICAgdmFyIGFjdDIzID0gY2MuY2FsbEZ1bmMoIGRlbGxhYmVsIClcbiAgICAgICAgICAgIHZhciBhY3QyID0gY2Muc2VxdWVuY2UoYWN0MjEsIGFjdDIyLCBhY3QyMyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1zZ25vZGUucnVuQWN0aW9uKGFjdDEpO1xuICAgICAgICAgICAgbXNnbm9kZS5ydW5BY3Rpb24oYWN0Mik7XG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBNc2dib3g7IiwidmFyIEVycm9yQ29kZSA9IHJlcXVpcmUoXCJlcnJvcmNvZGVcIilcblxudmFyIG1zZ2NvZGUgPSB7fVxubXNnY29kZVsgRXJyb3JDb2RlLkFDQ09VTlRfUkVQRUFUIF0gPSBcIui0puWPt+mHjeWkjVwiLFxubXNnY29kZVsgRXJyb3JDb2RlLkRCU0VSVklDRV9FUlJPUiBdID0gXCLmlbDmja7plJnor69cIixcblxubXNnY29kZVsgRXJyb3JDb2RlLk5PX0FDQ09VTlQgXSA9IFwi6LSm5Y+35LiN5a2Y5ZyoXCIsXG5tc2djb2RlWyBFcnJvckNvZGUuUEFTU1dPUkRfRVJST1IgXSA9IFwi5a+G56CB6ZSZ6K+vXCIsXG5tc2djb2RlWyBFcnJvckNvZGUuSEFTX09OTElORSBdID0gXCLlt7Lnu4/lnKjnur/vvIzor7fnqI3lkI7ph43or5VcIixcbm1zZ2NvZGVbIEVycm9yQ29kZS5BQ0NPVU5UX1NFQUwgXSA9IFwi6LSm5Y+36KKr56aB55So77yM6Kej56aB5pel5pyf5Li6PGJyLz48Y29sb3I9I0ZGMDAwMD48c2l6ZSA9IDI1PlwiLFxuXG5tc2djb2RlWyBFcnJvckNvZGUuUk9PTV9OT1RfRk9VTkQgXSA9IFwi5pyq5om+5Yiw6K+l5oi/6Ze0XCIsXG5tc2djb2RlWyBFcnJvckNvZGUuUk9PTV9GVUxMIF0gPSBcIuaIv+mXtOW3sua7oVwiLFxuXG5tc2djb2RlWyBFcnJvckNvZGUuR09MRF9OT1RfRU5PVUdIIF0gPSBcIumHkeW4geS4jei2s1wiLFxubXNnY29kZVsgRXJyb3JDb2RlLkJBTktFUl9OT19CRVQgXSA9IFwi5bqE5a625LiN6IO95LiL5rOoXCIsXG5tc2djb2RlWyBFcnJvckNvZGUuTk9UX0lOX1FVRVVFIF0gPSBcIuS4jeWcqOS4iuW6hOmYn+WIl+S4rVwiLFxubXNnY29kZVsgRXJyb3JDb2RlLk5PVF9CQU5LRVIgXSA9IFwi5L2g5LiN5piv5bqE5a62XCIsXG5tc2djb2RlWyBFcnJvckNvZGUuVVJfQkFOS0VSIF0gPSBcIuS9oOW3sue7j+aYr+W6hOWutlwiLFxubXNnY29kZVsgRXJyb3JDb2RlLkhBU19JTl9RVUVVRSBdID0gXCLkvaDlt7Lnu4/lnKjpmJ/liJdcIixcbm1zZ2NvZGVbIEVycm9yQ29kZS5UVUlCSU5HX1JPT01DTE9TRSBdID0gXCLmiL/pl7Tlt7LlhbPpl61cIixcblxubXNnY29kZVsgRXJyb3JDb2RlLlBFUk1JU1NJT05fREVOSUVEIF0gPSBcIuadg+mZkOS4jei2s1wiLFxubXNnY29kZVsgRXJyb3JDb2RlLkxPR1RZUEVfRVJST1IgXSA9IFwi5pel5b+X57G75Z6L6ZSZ6K+vXCIsXG5tc2djb2RlWyBFcnJvckNvZGUuTk9fVVNFUl9JRCBdID0gXCLnlKjmiLdJROS4jeWtmOWcqFwiLFxubXNnY29kZVsgRXJyb3JDb2RlLk5PVF9PTkxJTkUgXSA9IFwi55So5oi35LiN5Zyo57q/77yM5peg5rOV5pON5L2cXCIsXG5cbi8vIOi0puWPt+eKtuaAgVxubXNnY29kZS5BQ0NPVU5UX1RPT19MT05HID0gXCLotKblj7fmiJblr4bnoIHplb/luqbplJnor6/vvIzor7fovpPlhaU2fjEy5L2N5a2X56ymXCIsXG5tc2djb2RlLlBBU1NXT1JEX05PVF9TQU1FID0gXCLkuKTmrKHovpPlhaXnmoTlr4bnoIHkuI3nm7jlkIxcIixcbm1zZ2NvZGUuQUNDT1VOVF9QSE9ORV9FUlJPUiA9IFwi6K+36L6T5YWl5q2j56Gu55qE5omL5py65Y+3XCIsXG5cbm1zZ2NvZGUuTkVUV09SS19SRUxJTksgPSBcIue9kee7nOW3suaWreW8gO+8jOeCueWHu+mHjei/nlwiLFxubXNnY29kZS5ORVRXT1JLX1JFTE9HSU4gPVwi572R57uc5bey5pat5byA77yM6K+36YeN5paw55m75b2VXCIsXG5tc2djb2RlLk5FVFdPUktfVU5DT05ORUNUID0gXCLml6Dms5Xov57mjqXliLDmnI3liqHlmahcIixcbm1zZ2NvZGUuTkVUV09SS19PVEhFUl9MT0dJTiA9IFwi6LSm5Y+35Zyo5YW25LuW5Zyw5pa555m76ZmGXCIsXG5cbm1zZ2NvZGUuR09MRF9OT1RfRU5PVUdIID0gXCLph5HluIHkuI3otrNcIixcbi8v5o6o6aW8IOeKtuaAgVxubXNnY29kZS5UVUlCSU5HX05PX0JBTktFUiA9IFwi5pqC5peg5bqE5a62XCJcbm1zZ2NvZGUuVFVJQklOR19TVEFURV9TVE9QID0gXCLmmoLml6DluoTlrrbvvIznrYnlvoXnjqnlrrbkuIrluoRcIixcbm1zZ2NvZGUuVFVJQklOR19TVEFURV9CRUdJTiA9IFwi5LyR5oGv5LiA5LiL77yM5ri45oiP6ams5LiK5byA5aeLXCIsXG5tc2djb2RlLlRVSUJJTkdfU1RBVEVfUkVBRFkgPSBcIuWPr+S7peS4i+azqOS6hu+8jOW/q+aKleazqOWQp1wiLFxubXNnY29kZS5UVUlCSU5HX1NUQVRFX1dBSVRPUEVOID0gXCLkuIvms6jnu5PmnZ8g562J5b6F5byA54mMXCIsXG5tc2djb2RlLlRVSUJJTkdfU1RBVEVfT1BFTk5JTkcgPSBcIuato+WcqOW8gOeJjFwiLFxubXNnY29kZS5UVUlCSU5HX1NUQVRFX1JFV0FSRCA9IFwi5Y+R6YCB5aWW5YqxXCIsXG5cbi8v5o6o6aW85o+Q56S6XG5tc2djb2RlLlRVSUJJTkdfU0VMRUNUX0dPTEQgPSBcIuivt+WFiOmAieaLqemHkeW4gVwiLFxubXNnY29kZS5UVUlCSU5HX01PUkVUSEFOX0JBTktFUiA9IFwi5bey6LaF6L+H5oq85rOo5LiK6ZmQXCIsXG5tc2djb2RlLlRVSUJJTkdfR09MRF9OT1RfRU5PVUdIID0gXCLph5HluIHkuI3otrPku6Xlv6vpgJ/kuIrluoRcIixcbm1zZ2NvZGUuVFVJQklOR19HT0xEX0JBTktFUl9MRVNTID0gXCLph5HluIHkvY7kuo7mnIDkvY7kuIrluoTpnIDmsYJcIixcbm1zZ2NvZGUuVFVJQklOR19HT0xEX0JBTktFUl9OT1RfRU5PVUdIID0gXCLph5HluIHkuI3otrNcIixcblxubXNnY29kZS5UVUlCSU5HX0tFRVBfQkFOS0VSID0gXCLmmK/lkKbnu6fnu63lnZDluoTvvJ9cIixcbm1zZ2NvZGUuVFVJQklOR19CQU5LRVJfQkVHSU4gPSBcIuimgeW8gOWni+a4uOaIj+S5iO+8n1wiLFxubXNnY29kZS5UVUlCSU5HX0JBTktFUl9UWVBFID0gXCI8Y29sb3I9I0ZGRkZGRj7opoHlv6vpgJ/kuIrluoTkuYjvvJ88L2M+PGJyLz48Y29sb3I9I0ZGQUQwMD48c2l6ZSA9IDIwPu+8iOW/q+mAn+S4iuW6hOmcgOimgTIw5LiH6YeR5biB77yJPC9jb2xvcj48L3NpemU+XCIsXG5tc2djb2RlLlRVSUJJTkdfQVNLX1VOQkFOS0VSID0gXCLnoa7orqTkuIvluoTkuYjvvJ88YnIvPjxjb2xvcj0jRkYwMDAwPjxzaXplID0gMjU+5LiL5bqE5ZCO6ZyA6KaB6YeN5paw5o6S6Zif5LiK5bqEPC9jb2xvcj48L3NpemU+XCIsXG5cbm1zZ2NvZGUuR01fQ0FMTF9HTSA9IFwi6K+36IGU57O7R01cIixcbm1zZ2NvZGUuR01fUEFZTUVOVF9PSyA9IFwi5YWF5YC85oiQ5YqfXCIsXG5cbm1zZ2NvZGUuQ09NTU9OX0VSUk9SX0lEID0gXCLor7fovpPlhaXmraPnoa7nmoTnjqnlrrZpZFwiLFxubXNnY29kZS5DT01NT05fRVJST1JfR09MRCA9IFwi6K+36L6T5YWl5q2j56Gu55qE6YeR5biB5pWwXCIsXG5tc2djb2RlLkNPTU1PTl9FUlJPUl9VU0VSID0gXCLml6Dms5Xmn6Xor6LliLDor6XnjqnlrrZcIixcblxubXNnY29kZS5UUkFOU1RGRVJfU1VCTUlUXzEgPSBcIuaUtuasvuS6ujo8Y29sb3I9I0ZGMDAwMD5cIixcbm1zZ2NvZGUuVFJBTlNURkVSX1NVQk1JVF8yID0gXCI8L2NvbG9yPjxici8+5pS25qy+6YeR6aKdOjxjb2xvcj0jRkYwMDAwPlwiLFxubXNnY29kZS5UUkFOU1RGRVJfU1VCTUlUXzMgPSBcIjwvY29sb3I+PHNpemUgPSAyOT48YnIvPjxici8+PGNvbG9yPSNGRkZGRkY+56Gu6K6k6L2s6LSm5LmI77yfPC9zaXplPjwvY29sb3I+XCIsXG5tc2djb2RlLlRSQU5TVEZFUl9OT1RJQ0VfMSA9IFwi5pS25Yiw5p2l6IeqPGNvbG9yPSMwMEZGMDA+XCIsXG5tc2djb2RlLlRSQU5TVEZFUl9OT1RJQ0VfMiA9IFwiPC9jb2xvcj7nmoQ8Y29sb3I9I0ZGMDAwMD5cIixcbm1zZ2NvZGUuVFJBTlNURkVSX05PVElDRV8zID0gXCLph5HluIE8L2NvbG9yPlwiLFxubXNnY29kZS5UUkFOU1RGRVJfQ09NUExFVEUgPSBcIuS6pOaYk+WujOaIkFwiLFxubXNnY29kZS5UUkFOU1RGRVJfRVJST1JfR09MRCA9IFwi6L2s6LSm6Iez5bCR6KaBNTAwMDAw6YeR5biBXCIsXG5cbm1zZ2NvZGUuRU5EX0NPTE9SID0gXCI8L2NvbG9yPlwiLFxubXNnY29kZS5FTkRfU0laRSA9IFwiPC9zaXplPlwiLFxuXG5tb2R1bGUuZXhwb3J0cyA9IG1zZ2NvZGU7IiwidmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxuXG52YXIgTm90aWNlQm94ID0gY2MuQ2xhc3Moe1xuICAgIC8vIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICB9LFxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgcGZhYiA6IG51bGwsXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNjLmxvYWRlci5sb2FkUmVzKFwicHJvZmFiL05vdGljZVwiLCBmdW5jdGlvbiAoZXJyLCBwcmVmYWIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBmYWIgPSBwcmVmYWI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTXNnIDogZnVuY3Rpb24odHlwZSwgbXNnLCBva2Z1bmMsIGNhbmNlbGZ1bmMsIHRhZyl7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMucGZhYik7XG5cbiAgICAgICAgICAgIHZhciBtc2dub2RlID0gbm9kZS5nZXRDaGlsZEJ5TmFtZShcIk5vdGljZUJnXCIpLmdldENoaWxkQnlOYW1lKFwiTm90aWNlTGFiZWxcIik7XG4gICAgICAgICAgICB2YXIgbXNnbGFiZWwgPSBtc2dub2RlLmdldENvbXBvbmVudChjYy5SaWNoVGV4dCk7XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2YoIG1zZyApID09IFwibnVtYmVyXCIgKXtcbiAgICAgICAgICAgICAgICBtc2cgPSBtc2djb2RlWyBtc2cgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbXNnbGFiZWwuc3RyaW5nID0gbXNnO1xuXG4gICAgICAgICAgICB2YXIgb25EZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBva2J0biA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJOb3RpY2VCZ1wiKS5nZXRDaGlsZEJ5TmFtZShcIk9rQnRuXCIpO1xuICAgICAgICAgICAgdmFyIG9rY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAob2tmdW5jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2tmdW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICAgICAgICAgICAgICBvbkRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBva2J0bi5vbignY2xpY2snLCBva2NhbGxiYWNrKTtcblxuICAgICAgICAgICAgdmFyIGNhbmNlbGJ0biA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJOb3RpY2VCZ1wiKS5nZXRDaGlsZEJ5TmFtZShcIkNhbmNlbEJ0blwiKTtcbiAgICAgICAgICAgIHZhciBjYW5jZWxjYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYoY2FuY2VsZnVuYyAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZnVuYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgb25EZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsYnRuLm9uKCdjbGljaycsIGNhbmNlbGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgaWYoIHR5cGUgPT0gMiApe1xuICAgICAgICAgICAgICAgIGNhbmNlbGJ0bi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBva2J0bi54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLmdldFNjZW5lKCkuYWRkQ2hpbGQobm9kZSw5OSx0YWcpO1xuXG4gICAgICAgICAgICBub2RlLnNldFRpbWVPdXQgPSBmdW5jdGlvbiggdCApe1xuICAgICAgICAgICAgICAgIG5vZGUucnVuQWN0aW9uKCBjYy5zZXF1ZW5jZShjYy5kZWxheVRpbWUoIHQgKSwgY2MuY2FsbEZ1bmMoIG9uRGVzdHJveSApICkgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVNc2cgOiBmdW5jdGlvbih0YWcpe1xuICAgICAgICAgICAgY2MuZGlyZWN0b3IuZ2V0U2NlbmUoKS5yZW1vdmVDaGlsZEJ5VGFnKCB0YWcgKVxuICAgICAgICB9LFxuICAgIH0sXG59KTtcbm1vZHVsZS5leHBvcnRzID0gTm90aWNlQm94OyIsInZhciBUdWlCaW5nQ29uZmlnID0gcmVxdWlyZShcIlR1aUJpbmdDb25maWdcIilcbnZhciBwYWNrZXQgPSByZXF1aXJlKCAnTHBhY2thZ2UnIClcblxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgYmFyIDogY2MuUHJvZ3Jlc3NCYXIsXG4gICAgICAgIGlucHV0IDogY2MuRWRpdEJveCxcbiAgICAgICAgY2hlY2tib3ggOiBjYy5Ub2dnbGUsXG4gICAgICAgIGZhc3R0aXBzIDogY2MuTGFiZWwsXG5cbiAgICAgICAgX2lzX2tlZXAgOiBmYWxzZSxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgXG4gICAgfSxcblxuICAgIGluaXRLZWVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja2JveC5pbnRlcmFjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mYXN0dGlwcy5ub2RlLmNvbG9yID0gbmV3IGNjLkNvbG9yKDE0MCwgMTQwLCAxNDApO1xuICAgICAgICB0aGlzLl9pc19rZWVwID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY2xvc2VmdW5jID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25EaXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnJ1bkFjdGlvbiggY2Muc2VxdWVuY2UoY2MuZGVsYXlUaW1lKCBUdWlCaW5nQ29uZmlnLlRpbWUuQmVnaW5fa2VlcCApLCBjYy5jYWxsRnVuYyggY2xvc2VmdW5jICkgKSAgKVxuICAgIH0sXG5cbiAgICBvblNsaWRlQ2hhbmdlZCA6IGZ1bmN0aW9uIChzbGlkZXIsIGN1c3RvbUV2ZW50RGF0YSApe1xuICAgICAgICB2YXIgc2l6ZSA9IHNsaWRlci5wcm9ncmVzcztcbiAgICAgICAgdGhpcy5iYXIucHJvZ3Jlc3MgPSBzaXplO1xuXG4gICAgICAgIHZhciBtYXhnb2xkID0gY2MubGwucE1nci5tYWluX3JvbGUuZ29sZDtcbiAgICAgICAgdmFyIG5lZWQgPSBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkO1xuICAgICAgICBpZiggdGhpcy5jaGVja2JveC5pc0NoZWNrZWQgKXtcbiAgICAgICAgICAgIG5lZWQgPSBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkICsgVHVpQmluZ0NvbmZpZy5GYXN0QmFua2VyR29sZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2dvbGQgPSBtYXhnb2xkIC0gbmVlZDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuaW5wdXQuc3RyaW5nID0gVHVpQmluZ0NvbmZpZy5CYW5rZXJMZXNzR29sZCArIE1hdGguY2VpbChzZ29sZCpzaXplKTtcbiAgICB9LFxuXG4gICAgb25DaGVja0JveENsaWNrZWQgOiBmdW5jdGlvbih0b2dnbGUsIGN1c3RvbUV2ZW50RGF0YSkge1xuICAgICAgICBpZiggdG9nZ2xlLmlzQ2hlY2tlZCApe1xuICAgICAgICAgICAgdmFyIG1heGdvbGQgPSBjYy5sbC5wTWdyLm1haW5fcm9sZS5nb2xkO1xuICAgICAgICAgICAgaWYoIG1heGdvbGQgPCBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkICsgVHVpQmluZ0NvbmZpZy5GYXN0QmFua2VyR29sZCApe1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5pc0NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuVFVJQklOR19HT0xEX05PVF9FTk9VR0gpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdmFyIGdvbGQgPSBOdW1iZXIodGhpcy5pbnB1dC5zdHJpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBtYXhnb2xkIC0gKFR1aUJpbmdDb25maWcuQmFua2VyTGVzc0dvbGQgKyBUdWlCaW5nQ29uZmlnLkZhc3RCYW5rZXJHb2xkKTtcbiAgICAgICAgICAgICAgICBpZiggZ29sZCA+IG1heCApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnN0cmluZyA9IFR1aUJpbmdDb25maWcuQmFua2VyTGVzc0dvbGQgKyBtYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuXG4gICAgb25Pa0NsaWNrZWQgOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYmFua2VydHlwZSA9IDE7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94LmlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgYmFua2VydHlwZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBnb2xkID0gTnVtYmVyKHRoaXMuaW5wdXQuc3RyaW5nKTtcbiAgICAgICAgaWYgKGdvbGQgPCBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkKSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuVFVJQklOR19HT0xEX05PVF9FTk9VR0gpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lZWQgPSBnb2xkO1xuICAgICAgICBpZiggdGhpcy5jaGVja2JveC5pc0NoZWNrZWQgKXtcbiAgICAgICAgICAgIG5lZWQgPSBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkICsgVHVpQmluZ0NvbmZpZy5GYXN0QmFua2VyR29sZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4Z29sZCA9IGNjLmxsLnBNZ3IubWFpbl9yb2xlLmdvbGQ7XG4gICAgICAgIGlmKCBtYXhnb2xkIDwgbmVlZCApe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLlRVSUJJTkdfR09MRF9CQU5LRVJfTk9UX0VOT1VHSCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLl9pc19rZWVwICl7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxS2VlcEJhbmtlclwiICk7XG4gICAgICAgICAgICBwLmxwYWNrLmlza2VlcCA9IDA7XG4gICAgICAgICAgICBwLmxwYWNrLmdvbGQgPSBnb2xkO1xuICAgICAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUJlQmFua2VyXCIgKTtcbiAgICAgICAgICAgIHAubHBhY2sudHlwZSA9IGJhbmtlcnR5cGU7XG4gICAgICAgICAgICBwLmxwYWNrLmdvbGQgPSBOdW1iZXIoIHRoaXMuaW5wdXQuc3RyaW5nICk7XG4gICAgICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTsgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICAgICAgdGhpcy5vbkRpc3Ryb3koKTtcbiAgICB9LFxuICAgIG9uQ2FuY2VsQ2xpY2tlZCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiggdGhpcy5faXNfa2VlcCApe1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUtlZXBCYW5rZXJcIiApO1xuICAgICAgICAgICAgcC5scGFjay5pc2tlZXAgPSAxO1xuICAgICAgICAgICAgcC5scGFjay5nb2xkID0gMDtcbiAgICAgICAgICAgIGNjLmxsLm5ldC5zZW5kKCBwLnBhY2soKSApO1xuICAgICAgICB9XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICAgICAgdGhpcy5vbkRpc3Ryb3koKTtcbiAgICB9LFxuXG4gICAgb25EaXN0cm95OmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubm9kZS5kZXN0cm95KCk7XG4gICAgfSxcbn0pO1xuIiwidmFyIHBhY2tldCA9IHJlcXVpcmUoICdMcGFja2FnZScgKVxudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxudmFyIFR1aUJpbmdDb25maWcgPSByZXF1aXJlKFwiVHVpQmluZ0NvbmZpZ1wiKVxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBOYW1lTGFiZWw6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5MYWJlbCxcbiAgICAgICAgfSxcbiAgICAgICAgR29sZExhYmVsOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdHlwZTogY2MuTGFiZWwsXG4gICAgICAgIH0sXG5cbiAgICAgICAgQmFua2VyQnRucyA6IFtjYy5CdXR0b25dLFxuICAgICAgICBiYW5rZXJMYWJlbCA6IGNjLkxhYmVsLCBcbiAgICAgICAgYmFua2VyRGlhbG9nIDogY2MuUHJlZmFiLFxuXG4gICAgICAgIF9sb2dpYyA6IG51bGwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlICYmIGNjLnN5cy5pc01vYmlsZSl7XG4gICAgICAgICAgICB2YXIgY3ZzID0gY2MuZmluZChcIkNhbnZhc1wiKS5nZXRDb21wb25lbnQoY2MuQ2FudmFzKTtcbiAgICAgICAgICAgIGN2cy5maXRIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgY3ZzLmZpdFdpZHRoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNjLmxsLnBNZ3IubWFpbl9yb2xlICE9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuTmFtZUxhYmVsLnN0cmluZyA9IGNjLmxsLnBNZ3IubWFpbl9yb2xlLm5hbWUgKyBcIiBbXCIgKyBjYy5sbC5wTWdyLm1haW5fcm9sZS5pZCArIFwiXVwiO1xuICAgICAgICAgICAgdGhpcy5Hb2xkTGFiZWwuc3RyaW5nID0gY2MubGwucE1nci5tYWluX3JvbGUuZ29sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5Hb2xkTGFiZWwubm9kZTtcblxuICAgICAgICBjYy5sbC5wTWdyLm1haW5fcm9sZS5yZWdpc3RlcihcIkdvbGRDaGFuZ2VcIiwgIG5vZGUsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgIHZhciBnb2xkID0gZXZlbnQuZ2V0VXNlckRhdGEoKSAgICAgXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBub2RlLmdldENvbXBvbmVudChjYy5MYWJlbCk7XG4gICAgICAgICAgICBsYWJlbC5zdHJpbmcgPSBnb2xkO1xuICAgICAgICB9KVxuICAgICAgICB2YXIgZXZlbnQgPSByZXF1aXJlKFwiTExFdmVudFwiKTtcbiAgICAgICAgZXZlbnRcblxuICAgICAgICB0aGlzLl9sb2dpYyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoIFwiR2FtZUxvZ2ljXCIgKVxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheUJHTShcImJnQmV0XCIpO1xuICAgICAgICBjYy5sbC5sb2FkaW5nLnJlbW92ZUxvYWRpbmcoKTtcbiAgICB9LFxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG5cbiAgICBvbkJhY2tDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUxlYXZlUm9vbVwiICk7XG4gICAgICAgIGNjLmxsLm5ldC5zZW5kKCBwLnBhY2soKSApO1xuXG4gICAgICAgIGNjLmxsLnNTY2VuZU1nci5vbkNoYW5nZVNjZW5lKFwibWFpbnZpZXdcIik7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQmVCYW5rZXJDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2xvZ2ljLmNhbkJlQmFua2VyKCk7XG4gICAgICAgIGlmKCByZXMgIT0gMCl7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKHJlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoY2MubGwucE1nci5tYWluX3JvbGUuZ29sZCA8IFR1aUJpbmdDb25maWcuQmFua2VyTGVzc0dvbGQpe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyggbXNnY29kZS5HT0xEX05PVF9FTk9VR0ggKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlhbG9nID0gY2MuaW5zdGFudGlhdGUodGhpcy5iYW5rZXJEaWFsb2cpOyAgXG4gICAgICAgIHZhciBiZyA9IGNjLmZpbmQoIFwiQ2FudmFzXCIgKTtcbiAgICAgICAgZGlhbG9nLnBhcmVudCA9IGJnO1xuXG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuXG4gICAgb25TaG93S2VlcEJhbmtlciA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGNjLmxsLnBNZ3IubWFpbl9yb2xlLmdvbGQgPCBUdWlCaW5nQ29uZmlnLkJhbmtlckxlc3NHb2xkKXtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFLZWVwQmFua2VyXCIgKTtcbiAgICAgICAgICAgIHAubHBhY2suaXNrZWVwID0gMTtcbiAgICAgICAgICAgIHAubHBhY2suZ29sZCA9IDA7XG4gICAgICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2coIG1zZ2NvZGUuR09MRF9OT1RfRU5PVUdIICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBiZyA9IGNjLmZpbmQoIFwiQ2FudmFzXCIgKTtcbiAgICAgICAgdmFyIHRtcCA9IGJnLmdldENoaWxkQnlOYW1lKCBcIkJlQmFua2VyRGlhbG9nXCIgKTtcbiAgICAgICAgaWYoIHRtcCA9PSBudWxsICl7XG4gICAgICAgICAgICB2YXIgZGlhbG9nID0gY2MuaW5zdGFudGlhdGUodGhpcy5iYW5rZXJEaWFsb2cpO1xuICAgICAgICAgICAgdmFyIGxvZ2ljID0gZGlhbG9nLmdldENvbXBvbmVudCggXCJPbkJhbmtlckxheWVyTG9hZFwiICk7XG4gICAgICAgICAgICBsb2dpYy5pbml0S2VlcCgpO1xuICAgICAgICAgICAgZGlhbG9nLnBhcmVudCA9IGJnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVuU2hvd0tlZXBCYW5rZXIgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJnID0gY2MuZmluZCggXCJDYW52YXNcIiApO1xuICAgICAgICB2YXIgdG1wID0gYmcuZ2V0Q2hpbGRCeU5hbWUoIFwiQmVCYW5rZXJEaWFsb2dcIiApO1xuICAgICAgICBpZiggdG1wICE9IG51bGwgKXtcbiAgICAgICAgICAgIHRtcC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25GYXN0QmVCYW5rZXJDbGlja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUJlQmFua2VyXCIgKTtcbiAgICAgICAgcC5scGFjay50eXBlID0gMjtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuXG4gICAgb25BZGRHb2xkQnRuQ2xpY2tlZDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUFkZEdvbGRcIiApO1xuICAgICAgICAvLyBwLmxwYWNrLmlkID0gY2MubGwucE1nci5tYWluX3JvbGUuaWQ7XG4gICAgICAgIC8vIHAubHBhY2suZ29sZCA9IDEwMDAwMDtcbiAgICAgICAgLy8gcC5scGFjay5sb2d0eXBlID0gOTAxO1xuICAgICAgICAvLyBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTsgXG4gICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2coIG1zZ2NvZGUuR01fQ0FMTF9HTSApO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7IFxuICAgIH0sXG5cbiAgICBvblVuQmFua2VyQnRuQ2xpY2sgOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIG9rY2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcVR1aUJpbmdVbmJhbmtlclwiICk7XG4gICAgICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTsgIFxuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5jZWxjYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvL2RvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgICAgIGNjLmxsLm5vdGljZS5hZGRNc2coMSxtc2djb2RlLlRVSUJJTkdfQVNLX1VOQkFOS0VSLCBva2NhbGxiYWNrLCBjYW5jZWxjYWxsYmFjaywgOTk4KTtcbiAgICB9LFxuXG4gICAgb25MZWF2ZVF1ZXVlQnRuQ2xpY2sgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcVR1aWJpbmdMZWF2ZVF1ZXVlXCIgKTtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7ICBcbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpO1xuICAgIH0sXG5cbiAgICBvbkFsbFBsYXllckNsaWNrIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyL0FsbFBsYXllckxpc3RcIik7XG4gICAgICAgIG5vZGUuYWN0aXZlID0gIW5vZGUuYWN0aXZlO1xuICAgICAgICBpZiAobm9kZS5hY3RpdmUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2MuZmluZChcInB2aWV3L3Bjb250ZW50XCIsIG5vZGUpO1xuICAgICAgICAgICAgY2hpbGQucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFUdWlCaW5nQWxsUGxheWVyXCIgKTtcbiAgICAgICAgICAgIGNjLmxsLm5ldC5zZW5kKCBwLnBhY2soKSApOyAgXG4gICAgICAgIH1cblxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcblxuICAgIG9uS2VlcEJhbmtlckJ0bkNsaWNrIDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoY2MubGwucE1nci5tYWluX3JvbGUuZ29sZCA8IFR1aUJpbmdDb25maWcuQmFua2VyTGVzc0dvbGQpe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyggbXNnY29kZS5HT0xEX05PVF9FTk9VR0ggKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGJnID0gY2MuZmluZCggXCJDYW52YXNcIiApO1xuICAgICAgICB2YXIgdG1wID0gYmcuZ2V0Q2hpbGRCeU5hbWUoIFwiQmVCYW5rZXJEaWFsb2dcIiApO1xuICAgICAgICBpZiggdG1wID09IG51bGwgKXtcbiAgICAgICAgICAgIHZhciBkaWFsb2cgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLmJhbmtlckRpYWxvZyk7XG4gICAgICAgICAgICB2YXIgbG9naWMgPSBkaWFsb2cuZ2V0Q29tcG9uZW50KCBcIk9uQmFua2VyTGF5ZXJMb2FkXCIgKTtcbiAgICAgICAgICAgIGxvZ2ljLmluaXRLZWVwKCk7XG4gICAgICAgICAgICBkaWFsb2cucGFyZW50ID0gYmc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvd1VuQmFua2VyVGlwcyA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuYmFua2VyTGFiZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5CYW5rZXJCdG5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgYnRuID0gdGhpcy5CYW5rZXJCdG5zW2ldO1xuICAgICAgICAgICAgYnRuLm5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9naWMuX3VuQmFua2VyRmxhZyA9IHRydWU7XG4gICAgfSxcbn0pO1xuIiwidmFyIHBhY2tldCA9IHJlcXVpcmUoIFwiTHBhY2thZ2VcIiApXG52YXIgbXNnY29kZSA9IHJlcXVpcmUoICdNc2djb2RlJyApXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBOYW1lTGFiZWwgOiBjYy5FZGl0Qm94LFxuICAgICAgICBHb2xkTGFiZWwgOiBjYy5FZGl0Qm94LFxuICAgICAgICBMb2dCdG5MaXN0IDogW2NjLkJ1dHRvbl0sXG4gICAgICAgIF9sb2dUeXBlIDogMCxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLkxvZ0J0bkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBidG4gPSB0aGlzLkxvZ0J0bkxpc3RbaV07XG4gICAgICAgICAgICBpZiggaSA9PSAwICl7XG4gICAgICAgICAgICAgICAgYnRuLmludGVyYWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ1R5cGUgPSAxO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYnRuLmludGVyYWN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Hb2xkQnRuQ2xpY2tlZCA6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKXtcbiAgICAgICAgdmFyIGN1ciA9IE51bWJlcih0aGlzLkdvbGRMYWJlbC5zdHJpbmcpIHx8IDA7XG4gICAgICAgIHZhciBhZGQgPSBOdW1iZXIoIGRhdGEgKSB8fCAwO1xuICAgICAgICB0aGlzLkdvbGRMYWJlbC5zdHJpbmcgPSBjdXIgKyBhZGQ7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTsgXG4gICAgfSxcblxuICAgIG9uTG9nQnRuQ2xpY2tlZCA6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSApe1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTG9nQnRuTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ0biA9IHRoaXMuTG9nQnRuTGlzdFtpXTtcbiAgICAgICAgICAgIGlmKCBpKzEgPT0gZGF0YSApe1xuICAgICAgICAgICAgICAgIGJ0bi5pbnRlcmFjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dUeXBlID0gTnVtYmVyKGRhdGEpfHwxO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYnRuLmludGVyYWN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpOyBcbiAgICB9LFxuXG4gICAgb25DbGVhbkJ0bkNsaWNrZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuR29sZExhYmVsLnN0cmluZyA9IDA7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTsgXG4gICAgfSxcblxuICAgIG9uT2tCdG5DbGlja2VkIDogZnVuY3Rpb24oIGV2ZW50ICl7XG4gICAgICAgIHZhciBuYW1lID0gTnVtYmVyKHRoaXMuTmFtZUxhYmVsLnN0cmluZyk7XG4gICAgICAgIGlmIChuYW1lPD0wKSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuQ09NTU9OX0VSUk9SX0lEKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ29sZCA9IE51bWJlciggdGhpcy5Hb2xkTGFiZWwuc3RyaW5nICk7XG4gICAgICAgIGlmKCBnb2xkIDw9IDAgKXtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5DT01NT05fRVJST1JfR09MRCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxQWRkR29sZFwiICk7XG4gICAgICAgIHAubHBhY2suaWQgPSBuYW1lO1xuICAgICAgICBwLmxwYWNrLmdvbGQgPSBnb2xkO1xuICAgICAgICBwLmxwYWNrLmxvZ3R5cGUgPSB0aGlzLl9sb2dUeXBlO1xuICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTsgXG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTsgXG4gICAgICAgIGNjLmxsLmxvYWRpbmcuYWRkTG9hZGluZygzKTtcbiAgICAgICAgdGhpcy5vbkxheWVyRGVzdHJveSgpO1xuICAgIH0sXG5cbiAgICBvbkxheWVyRGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKTtcbiAgICB9LFxufSk7XG4iLCJ2YXIgcGFja2V0ID0gcmVxdWlyZSggJ0xwYWNrYWdlJyApXG52YXIgVHVpQmluZ0NvbmZpZyA9IHJlcXVpcmUoXCJUdWlCaW5nQ29uZmlnXCIpXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBUb2dnbGVMaXN0IDogWyBjYy5Ub2dnbGUgXSxcbiAgICAgICAgX2xvZ2ljIDogbnVsbCxcbiAgICAgICAgX2dtUHJlZmFiIDogY2MuUHJlZmFiLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJnbGF5ZXIgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyXCIpXG4gICAgICAgIHRoaXMuX2xvZ2ljID0gYmdsYXllci5nZXRDb21wb25lbnQoXCJHYW1lTG9naWNcIik7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoXCJwcm9mYWIvR01BZGRHb2xkTGF5ZXJcIiwgZnVuY3Rpb24gKGVyciwgcHJlZmFiKSB7XG4gICAgICAgICAgICBzZWxmLl9nbVByZWZhYiA9IHByZWZhYjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKCBcIkFkZEdvbGRcIiwgdGhpcy5ub2RlICk7XG4gICAgICAgIGlmKGNjLmxsLnBNZ3IubWFpbl9yb2xlLmdtbGV2ZWwgPj0gMSl7XG4gICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gY2MuZmluZCggXCJDb250cm9sTGF5ZXJcIiwgdGhpcy5ub2RlICk7XG4gICAgICAgIGlmKGNjLmxsLnBNZ3IubWFpbl9yb2xlLmdtbGV2ZWwgPj0gMil7XG4gICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgbm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblVuYWJsZUFsbCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLlRvZ2dsZUxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciB0b2dnbGUgPSB0aGlzLlRvZ2dsZUxpc3RbaV07XG4gICAgICAgICAgICB0b2dnbGUuaW50ZXJhY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25FbmFibGVBbGwgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuVG9nZ2xlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHRvZ2dsZSA9IHRoaXMuVG9nZ2xlTGlzdFtpXTtcbiAgICAgICAgICAgIHRvZ2dsZS5pbnRlcmFjdGFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uUmVzZXRBbGwgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuVG9nZ2xlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHRvZ2dsZSA9IHRoaXMuVG9nZ2xlTGlzdFtpXTtcbiAgICAgICAgICAgIHRvZ2dsZS5pc0NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblNlbmRHOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEgKXtcbiAgICAgICAgdmFyIG51bSA9IE51bWJlcihkYXRhKTtcbiAgICAgICAgdmFyIHBvcyA9IE1hdGguY2VpbCggbnVtIC8gMiApIDtcbiAgICAgICAgdmFyIHdpbiA9IChudW0rMSkgJSAyICsgMTtcbiAgICAgICAgdmFyIHRvZ2dsZSA9IGV2ZW50O1xuICAgICAgICBpZiAodG9nZ2xlLmlzQ2hlY2tlZCl7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy5fbG9naWMuX2dhbWVfc3RhdGUgPT0gVHVpQmluZ0NvbmZpZy5TdGF0ZS5SZWFkeSB8fCBcbiAgICAgICAgICAgIHRoaXMuX2xvZ2ljLl9nYW1lX3N0YXRlID09IFR1aUJpbmdDb25maWcuU3RhdGUuV2FpdE9wZW4gKXtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFTZW5kV2luXCIgKTtcbiAgICAgICAgICAgIHAubHBhY2sucG9zID0gcG9zO1xuICAgICAgICAgICAgcC5scGFjay53aW4gPSB3aW47XG4gICAgICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25HbUFkZEdvbGRDbGlja2VkOiBmdW5jdGlvbihldmVudCwgZGF0YSl7XG4gICAgICAgIGlmKCB0aGlzLl9nbVByZWZhYiA9PSBudWxsICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLl9nbVByZWZhYik7XG4gICAgICAgIHZhciBiZyA9IGNjLmZpbmQoIFwiQ2FudmFzXCIgKVxuICAgICAgICBub2RlLnBhcmVudCA9IGJnO1xuICAgIH0sXG59KTtcbiIsInZhciBQcm90b0J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZlwiKVxudmFyIGV0YyA9IHJlcXVpcmUoXCJldGNcIik7XG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBsb2FkaW5nQmFyOiBjYy5Qcm9ncmVzc0JhcixcbiAgICAgICAgdGlwczogY2MuTGFiZWwsXG5cbiAgICAgICAgX2lzTG9hZGluZyA6IGZhbHNlLFxuICAgICAgICBfc3RhdGVTdHI6XCJcIixcbiAgICAgICAgX2xvYWRrZXkgOiAwLFxuICAgICAgICBfbG9hZGluZ0xpc3Q6W2NjLlN0cmluZ10sXG4gICAgICAgIF9uYW1lTGlzdCA6IFtcIlwiXSxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcbiAgICAgICAgICAgIHZhciBjdnMgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkNhbnZhcyk7XG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2MuZ2FtZS5jb25maWdbJ215dmVyc2lvbiddPSBldGMudmVyc2lvbjtcbiAgICAgICAgY2MuZ2FtZS5jb25maWdbJ25vQ2FjaGUnXT10cnVlO1xuICAgICAgICAvLyB0aGlzLmxvYWRpbmdCYXIudG90YWxMZW5ndGggPSB0aGlzLmxvYWRpbmdCYXIubm9kZS53aWR0aDtcblxuICAgICAgICBjYy5sbCA9IHt9O1xuICAgICAgICB0aGlzLnRpcHMuc3RyaW5nID0gXCLmraPlnKjliJ3lp4vljJYuLi5cIjtcbiAgICAgICAgLy8g5Yid5aeL5YyW572R57ucXG4gICAgICAgIGNjLmxsLm5ldCA9IHJlcXVpcmUoXCJMd2Vic29ja2V0XCIpO1xuICAgICAgICBjYy5sbC5uZXQuaW5pdCgpO1xuICAgICAgICAvLyDliJ3lp4vljJbljY/orq5cbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXMoXCJnYW1lYm94XCIsIGZ1bmN0aW9uIChlcnIsIGFycil7XG4gICAgICAgICAgICBjYy5sbC5wYiA9IFByb3RvQnVmLnByb3RvRnJvbVN0cmluZyhhcnIpOyBcbiAgICAgICAgfSk7XG4gICAgICAgIC8v5Yid5aeL5YyW6YCa55So55WM6Z2iXG4gICAgICAgIGNjLmxsLm1zZ2JveCA9IHJlcXVpcmUoXCJNc2dib3hcIik7XG4gICAgICAgIGNjLmxsLm5vdGljZSA9IHJlcXVpcmUoXCJOb3RpY2VcIik7XG4gICAgICAgIGNjLmxsLm5vdGljZS5pbml0KCk7XG4gICAgICAgIC8v5Yid5aeL5YyWbG9hZGluZ+eVjOmdolxuICAgICAgICBjYy5sbC5sb2FkaW5nID0gcmVxdWlyZShcIkxvYWRpbmdEaWFsb2dcIik7XG4gICAgICAgIGNjLmxsLmxvYWRpbmcuaW5pdCgpO1xuICAgICAgICAvL+WIneWni+WMliDnjqnlrrbnrqHnkIblmahcbiAgICAgICAgY2MubGwucE1nciA9IHJlcXVpcmUoXCJQbGF5ZXJNYW5hZ2VyXCIpO1xuICAgICAgICBjYy5sbC5wTWdyLmluaXQoKTtcbiAgICAgICAgLy/liJ3lp4vljJYg5Zy65pmv566h55CG5ZmoXG4gICAgICAgIGNjLmxsLnNTY2VuZU1nciA9IHJlcXVpcmUoXCJTY2VuZU1hbmFnZXJcIik7XG4gICAgICAgIC8v5Yid5aeL5YyWIOmfs+aViOeuoeeQhuWZqFxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IgPSByZXF1aXJlKFwiQXVkaW9NYW5hZ2VyXCIpO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IuaW5pdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8g5Yqg6L296LWE5rqQXG4gICAgICAgIHRoaXMuX2xvYWRpbmdMaXN0ID0gW1wiZXJndW90b3VcIixcImxvZ2luXCIsXCJtYWluXCIsXCJwcm9mYWJcIixcInJlc19jb21tb25cIixcInNvdW5kXCJdO1xuICAgICAgICB0aGlzLl9uYW1lTGlzdCA9IFtcIuW/heimgVwiLFwi6YeN6KaBXCIsXCLmuLjmiI9cIixcIueVjOmdolwiLFwiVUlcIixcIumAmueUqFwiLFwi5YW25LuWXCJdO1xuICAgICAgICB0aGlzLm9uTG9hZE5leHQoKTtcbiAgICB9LFxuXG4gICAgb25Mb2FkQ29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlU3RyID0gXCLlh4blpIfnmbvpmYZcIjtcbiAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwibG9naW52aWV3XCIpO1xuICAgICAgICBjYy5sb2FkZXIub25Db21wbGV0ZSA9IG51bGw7XG4gICAgfSxcblxuICAgIG9uTG9hZE5leHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHRoaXMuX2xvYWRrZXkgPj0gdGhpcy5fbG9hZGluZ0xpc3QubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX25hbWVMaXN0WyB0aGlzLl9sb2Fka2V5IF07XG4gICAgICAgICAgICB2YXIgZGlyID0gdGhpcy5fbG9hZGluZ0xpc3RbIHRoaXMuX2xvYWRrZXkgXTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQcmVsb2FkaW5nKCBuYW1lLCBkaXIgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2Fka2V5ID0gdGhpcy5fbG9hZGtleSArIDE7XG4gICAgfSxcblxuICAgIHN0YXJ0UHJlbG9hZGluZzpmdW5jdGlvbihuYW1lICwgZGlyKXtcbiAgICAgICAgdGhpcy5fc3RhdGVTdHIgPSBcIuato+WcqOWKoOi9vVwiK25hbWUrXCLotYTmupDvvIzor7fnqI3lgJlcIjtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgY2MubG9hZGVyLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoIGNvbXBsZXRlZENvdW50LCB0b3RhbENvdW50LCAgaXRlbSApe1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJjb21wbGV0ZWRDb3VudDpcIiArIGNvbXBsZXRlZENvdW50ICsgXCIsdG90YWxDb3VudDpcIiArIHRvdGFsQ291bnQgKTtcbiAgICAgICAgICAgIGlmKHNlbGYuX2lzTG9hZGluZyl7XG4gICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MgPSBjb21wbGV0ZWRDb3VudC90b3RhbENvdW50O1xuICAgICAgICAgICAgICAgIHNlbGYubG9hZGluZ0Jhci5wcm9ncmVzcyA9IHNlbGYuX3Byb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2MubG9hZGVyLmxvYWRSZXNEaXIoZGlyLCBmdW5jdGlvbiAoZXJyLCBhc3NldHMpIHtcbiAgICAgICAgICAgIHNlbGYub25Mb2FkTmV4dCgpO1xuICAgICAgICB9KTsgICAgICBcbiAgICB9LFxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdGVTdHIubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwcy5zdHJpbmcgPSB0aGlzLl9zdGF0ZVN0ciArICcgJztcbiAgICAgICAgaWYodGhpcy5faXNMb2FkaW5nKXtcbiAgICAgICAgICAgIHRoaXMudGlwcy5zdHJpbmcgKz0gTWF0aC5mbG9vcih0aGlzLl9wcm9ncmVzcyAqIDEwMCkgKyBcIiVcIjsgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdmFyIHQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAlIDQ7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdDsgKysgaSl7XG4gICAgICAgICAgICAgICAgdGhpcy50aXBzLnN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIE9uTG9naW5MYXllckxvYWQuanNcbnZhciBtc2djb2RlID0gcmVxdWlyZSggJ01zZ2NvZGUnIClcbnZhciBwYWNrZXQgPSByZXF1aXJlKCAnTHBhY2thZ2UnIClcblxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHByZWZhYk5vcm1hbFJlZ2lzdGVyOntcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5QcmVmYWIsXG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlZmFiUGhvbmVSZWdpc3RlciA6IGNjLlByZWZhYixcblxuICAgICAgICBhY2NvdW50Qm94IDoge1xuICAgICAgICBcdGRlZmF1bHQgOiBudWxsLFxuICAgICAgICBcdHR5cGU6IGNjLkVkaXRCb3gsXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFzc3dvcmRCb3ggOiB7XG4gICAgICAgIFx0ZGVmYXVsdCA6IG51bGwsXG4gICAgICAgIFx0dHlwZTogY2MuRWRpdEJveCxcbiAgICAgICAgfSxcblxuICAgICAgICByZW1lbWJlckNoZWNrQm94IDogY2MuVG9nZ2xlLFxuICAgICAgICBcbiAgICAgICAgX2xvZ2luX3R5cGUgOiAwLFxuICAgIH0sXG4gICAgb25Mb2FkOmZ1bmN0aW9uKCkge1xuICAgIFx0dmFyIGFjY291bnQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY291bnQnKTtcbiAgICBcdHZhciBwYXNzd29yZCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGFzc3dvcmQnKTtcbiAgICBcdGlmIChhY2NvdW50ICE9IG51bGwgJiYgYWNjb3VudCAhPSBcIlwiKXtcbiAgICBcdFx0dGhpcy5hY2NvdW50Qm94LnN0cmluZyA9IGFjY291bnQ7XG4gICAgXHRcdHRoaXMucGFzc3dvcmRCb3guc3RyaW5nID0gcGFzc3dvcmQ7XG4gICAgXHR9XG4gICAgfSxcbiAgICBvbk5vcm1hbFJlZ2lzdGVyQ2xpY2s6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5wcmVmYWJOb3JtYWxSZWdpc3RlcjtcbiAgICAgICAgaWYoIHRoaXMuX2xvZ2luX3R5cGUgPT0gMiApe1xuICAgICAgICAgICAgLy8g5omL5py655m76ZmG5rOo5YaMXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMucHJlZmFiUGhvbmVSZWdpc3RlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmcgPSBjYy5maW5kKFwiQ2FudmFzL0JnTGF5ZXJcIik7XG4gICAgICAgIGxldCByZWdpc3RlcmxheWVyID0gY2MuaW5zdGFudGlhdGUoaW5zdGFuY2UpOyAgXG4gICAgICAgIHJlZ2lzdGVybGF5ZXIucGFyZW50ID0gYmc7XG4gICAgICAgIHJlZ2lzdGVybGF5ZXIuc2V0UG9zaXRpb24oMCwwKTtcbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpO1xuICAgIH0sXG5cbiAgICBvbkRpc3Ryb3k6ZnVuY3Rpb24oKXtcbiAgICBcdHRoaXMubm9kZS5kZXN0cm95KCk7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuXG4gICAgb25Mb2dpbkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICBcdHZhciBhY2NvdW50ID0gdGhpcy5hY2NvdW50Qm94LnN0cmluZztcbiAgICBcdHZhciBwYXNzd29yZCA9IHRoaXMucGFzc3dvcmRCb3guc3RyaW5nO1xuICAgIFx0aWYgKGFjY291bnQubGVuZ3RoID4gMTIgfHwgYWNjb3VudC5sZW5ndGggPCA2KXtcbiAgICBcdFx0Y2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLkFDQ09VTlRfVE9PX0xPTkcpO1xuICAgIFx0XHRyZXR1cm47XG4gICAgXHR9XG4gICAgXHRpZiAodGhpcy5yZW1lbWJlckNoZWNrQm94LmlzQ2hlY2tlZCkge1xuICAgIFx0XHRjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjY291bnQnLCBhY2NvdW50KTtcbiAgICBcdFx0Y2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwYXNzd29yZCcsIHBhc3N3b3JkKTtcbiAgICBcdH1cbiAgICBcdHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFsb2dpblwiICk7XG4gICAgICAgIHAubHBhY2suYWNjb3VudCA9IGFjY291bnQ7XG4gICAgICAgIHAubHBhY2sucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG5cbiAgICAgICAgY2MubGwubG9hZGluZy5hZGRMb2FkaW5nKDUpO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcbn0pOyIsIlxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSAmJiBjYy5zeXMuaXNNb2JpbGUpe1xuICAgICAgICAgICAgdmFyIGN2cyA9IGNjLmZpbmQoXCJDYW52YXNcIikuZ2V0Q29tcG9uZW50KGNjLkNhbnZhcyk7XG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb250ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImFhYWFhYWFhYWFhYWFhYWFhYWFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2MubGwubm90aWNlLmFkZE1zZyAoMixcIue7p+e7rTEx5ri45oiP5LmI77yfXCIsY2FsbGJhY2spXG4gICAgfSxcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxufSk7XG4iLCJ2YXIgZXRjID0gcmVxdWlyZShcImV0Y1wiKVxudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuICAgIFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcHJlZmFiTm9ybWFsTG9naW46e1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLlByZWZhYixcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbW1vbi5jb25uZWN0KCk7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcbiAgICAgICAgICAgIHZhciBjdnMgPSBjYy5maW5kKFwiQ2FudmFzXCIpLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBjdnMuZml0V2lkdGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9rZnVuYyA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3JmdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBzY2VuZW5hbWUgPSBjYy5kaXJlY3Rvci5nZXRTY2VuZSgpLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYoIHNjZW5lbmFtZSA9PSBcImxvYWRpbmd2aWV3XCIgfHwgc2NlbmVuYW1lID09IFwibG9naW52aWV3XCIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNjLmxsLnNTY2VuZU1nci5vbkNoYW5nZVNjZW5lKFwibG9naW52aWV3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2MubGwubm90aWNlLmFkZE1zZyAoMixtc2djb2RlLk5FVFdPUktfVU5DT05ORUNULGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICAgIGNjLmxsLm5ldC5jb25uZWN0KCBldGMuaXAsIGV0Yy5wb3J0LCBva2Z1bmMsIGVycm9yZnVuYyApO1xuXG5cbiAgICAgICAgdmFyIHNpemUgPSBjYy5sbC5zQXVkaW9NZ3IuZ2V0U2l6ZSgpXG4gICAgICAgIHZhciBub2RlID0gY2MuZmluZCggXCJDYW52YXMvQmdMYXllci9TZXR0aW5nQnRuXCIgKVxuICAgICAgICB2YXIgY2xvc2VpbWcgPSBub2RlLmdldENoaWxkQnlOYW1lKCBcIkNsb3NlXCIgKTtcbiAgICAgICAgY2xvc2VpbWcuYWN0aXZlID0gc2l6ZSA9PSAwO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheUJHTShcImJnbVwiKTsgXG4gICAgfSxcblxuICAgIG9uTm9ybWFsTG9naW5DbGljazpmdW5jdGlvbihldmVudCwgZGF0YSl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNob3dMb2dpbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgYmcgPSBjYy5maW5kKFwiQ2FudmFzL0JnTGF5ZXJcIik7XG4gICAgICAgICAgICB2YXIgY3JlYXRsYXllciA9IGNjLmluc3RhbnRpYXRlKHNlbGYucHJlZmFiTm9ybWFsTG9naW4pOyAgXG4gICAgICAgICAgICB2YXIgbG9naWMgPSBjcmVhdGxheWVyLmdldENvbXBvbmVudCggXCJPbkxvZ2luTGF5ZXJMb2FkXCIgKTtcbiAgICAgICAgICAgIGxvZ2ljLl9sb2dpbl90eXBlID0gTnVtYmVyKGRhdGEpIHx8IDA7XG4gICAgICAgICAgICBjcmVhdGxheWVyLnBhcmVudCA9IGJnO1xuICAgICAgICAgICAgY3JlYXRsYXllci5zZXRQb3NpdGlvbigwLDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICggY2MubGwubmV0LnN0YXRlID09IDIgKSB7XG4gICAgICAgICAgICBzaG93TG9naW4oKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBva2Z1bmMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBzaG93TG9naW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZnVuYyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGNjLmxsLm5vdGljZS5hZGRNc2coMixtc2djb2RlLk5FVFdPUktfVU5DT05ORUNULG51bGwpICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2MubGwubmV0LmNvbm5lY3QoIGV0Yy5pcCwgZXRjLnBvcnQsIG9rZnVuYywgZXJyb3JmdW5jICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYy5sbC5ub3RpY2UuYWRkTXNnKDIsbXNnY29kZS5ORVRXT1JLX1VOQ09OTkVDVCxjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcblxuICAgIG9uU2V0dGluZ0NsaWNrIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBjbG9zZWltZyA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoIFwiQ2xvc2VcIiApO1xuICAgICAgICBjbG9zZWltZy5hY3RpdmUgPSAhY2xvc2VpbWcuYWN0aXZlO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3Iuc2V0U2l6ZSggY2xvc2VpbWcuYWN0aXZlPzA6MSApO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcbn0pOyIsInZhciBwYWNrZXQgPSByZXF1aXJlKCAnTHBhY2thZ2UnIClcblxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgXG4gICAgICAgIE5hbWVMYWJlbDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkxhYmVsLFxuICAgICAgICB9LFxuICAgICAgICBHb2xkTGFiZWw6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5MYWJlbCxcbiAgICAgICAgfSxcblxuICAgICAgICBUcmFkZVByZWZhYiA6IGNjLlByZWZhYixcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcbiAgICAgICAgICAgIHZhciBjdnMgPSBjYy5maW5kKFwiQ2FudmFzXCIpLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBjdnMuZml0V2lkdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKGNjLmxsLnBNZ3IubWFpbl9yb2xlICE9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuTmFtZUxhYmVsLnN0cmluZyA9IGNjLmxsLnBNZ3IubWFpbl9yb2xlLm5hbWUgKyBcIiBbXCIgKyBjYy5sbC5wTWdyLm1haW5fcm9sZS5pZCArIFwiXVwiO1xuICAgICAgICAgICAgdGhpcy5Hb2xkTGFiZWwuc3RyaW5nID0gY2MubGwucE1nci5tYWluX3JvbGUuZ29sZDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNjLmxsLnBNZ3IubWFpbl9yb2xlLnJlZ2lzdGVyKFwiR29sZENoYW5nZVwiLCAgdGhpcy5Hb2xkTGFiZWwubm9kZSwgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgIHZhciBnb2xkID0gZXZlbnQuZ2V0VXNlckRhdGEoKSAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICAgICAgICAgIHNlbGYuR29sZExhYmVsLnN0cmluZyA9IGdvbGQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemUgPSBjYy5sbC5zQXVkaW9NZ3IuZ2V0U2l6ZSgpXG4gICAgICAgIHZhciBub2RlID0gY2MuZmluZCggXCJDYW52YXMvTWFpbkJnTGF5ZXIvTWFpbkJnL1NldHRpbmdCdG5cIiApXG4gICAgICAgIHZhciBjbG9zZWltZyA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoIFwiQ2xvc2VcIiApO1xuICAgICAgICBjbG9zZWltZy5hY3RpdmUgPSBzaXplID09IDA7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5QkdNKFwiYmdSYWNlXCIpO1xuICAgIH0sXG5cbiAgICBvbkdhbWVCdG5DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxRW50ZXJSb29tXCIgKTtcbiAgICAgICAgcC5scGFjay5yb29taWQgPSA5OTtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgICAgIGNjLmxsLmxvYWRpbmcuYWRkTG9hZGluZygyMCk7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTtcbiAgICB9LFxuICAgIG9uU2V0dGluZ0NsaWNrIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBjbG9zZWltZyA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoIFwiQ2xvc2VcIiApO1xuICAgICAgICBjbG9zZWltZy5hY3RpdmUgPSAhY2xvc2VpbWcuYWN0aXZlO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3Iuc2V0U2l6ZSggY2xvc2VpbWcuYWN0aXZlPzA6MSApO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcblxuICAgIG9uVHJhZGVCdG5DbGljayA6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdmFyIHRyYWRlbGF5ZXIgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLlRyYWRlUHJlZmFiKTtcbiAgICAgICAgdmFyIGJnID0gY2MuZmluZCggXCIvQ2FudmFzL01haW5CZ0xheWVyXCIgKTtcbiAgICAgICAgdHJhZGVsYXllci5wYXJlbnQgPSBiZztcbiAgICB9LFxufSk7XG4iLCJ2YXIgcGFja2V0ID0gcmVxdWlyZSggJ0xwYWNrYWdlJyApO1xudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBhY2NvdW50Qm94IDoge1xuICAgICAgICAgICAgZGVmYXVsdCA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5FZGl0Qm94LFxuICAgICAgICB9LFxuXG4gICAgICAgIENoZWNrQm94IDoge1xuICAgICAgICAgICAgZGVmYXVsdCA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5FZGl0Qm94LFxuICAgICAgICB9LFxuXG4gICAgICAgIHBhc3N3b3JkQm94IDoge1xuICAgICAgICAgICAgZGVmYXVsdCA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5FZGl0Qm94LFxuICAgICAgICB9LFxuXG4gICAgICAgIENoZWNrQnRuIDogY2MuQnV0dG9uLFxuICAgICAgICBDaGVja0xhYmVsIDogY2MuTGFiZWwsIFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MubGwucGhvbmVfY2hlY2tfdGltZSA9PSAwIHx8IGNjLmxsLnBob25lX2NoZWNrX3RpbWUgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgbGVmdHRpbWUgPSBNYXRoLmNlaWwoIHRpbWVzdGFtcCAvIDEwMDAgKSAtIGNjLmxsLnBob25lX2NoZWNrX3RpbWU7XG4gICAgICAgIGlmICggbGVmdHRpbWUgPCAzMCl7XG4gICAgICAgICAgICB0aGlzLnNob3dUaW1lciggbGVmdHRpbWUgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0cm4gPSAvXigtKT9cXGQrKFxcLlxcZCspPyQvO1xuICAgICAgICBpZiAocGF0cm4uZXhlYyh2YWx1ZSkgPT0gbnVsbCB8fCB2YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uUmVnaXN0ZXJDbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWNjb3VudCA9IHRoaXMuYWNjb3VudEJveC5zdHJpbmc7XG4gICAgICAgIHZhciBjaGVja251bSA9IHRoaXMuQ2hlY2tCb3guc3RyaW5nO1xuICAgICAgICB2YXIgcGFzc3dvcmQgPSB0aGlzLnBhc3N3b3JkQm94LnN0cmluZztcblxuICAgICAgICBpZiAoYWNjb3VudC5sZW5ndGggIT0gMTEgKSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuQUNDT1VOVF9QSE9ORV9FUlJPUik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoICEgdGhpcy5pc051bWJlciggYWNjb3VudCApICl7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuQUNDT1VOVF9QSE9ORV9FUlJPUik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrbnVtLmxlbmd0aCAhPSA2KSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuUEFTU1dPUkRfTk9UX1NBTUUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFSZWdpc3RlclBob25lXCIgKTtcbiAgICAgICAgcC5scGFjay5waG9uZW51bSA9IGFjY291bnQ7XG4gICAgICAgIHAubHBhY2sucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgcC5scGFjay5jaGVja251bSA9IGNoZWNrbnVtO1xuICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcblxuICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjY291bnQnLCBhY2NvdW50KTtcbiAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwYXNzd29yZCcsIHBhc3N3b3JkKTtcbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpO1xuICAgIH0sXG4gICAgc2hvd1RpbWVyIDogZnVuY3Rpb24oIHRpbWUgKSB7XG4gICAgICAgIHZhciB0aW1lID0gdGltZSB8fCAzMDtcbiAgICAgICAgdGhpcy5DaGVja0J0bi5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLkNoZWNrTGFiZWwubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5DaGVja0xhYmVsLnN0cmluZyA9IHRpbWUgKyBcIiBzXCI7XG4gICAgICAgICAgICB0aW1lIC0tIDtcbiAgICAgICAgICAgIGlmKCB0aW1lID09IDAgKXtcbiAgICAgICAgICAgICAgICB0aGlzLkNoZWNrQnRuLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLkNoZWNrTGFiZWwubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMSwgdGltZSwgMClcbiAgICB9LFxuICAgIG9uQ2hlY2tCdG5DbGlja2VkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY2NvdW50ID0gdGhpcy5hY2NvdW50Qm94LnN0cmluZztcbiAgICAgICAgaWYgKGFjY291bnQubGVuZ3RoICE9IDExKSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuQUNDT1VOVF9QSE9ORV9FUlJPUik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCAhIHRoaXMuaXNOdW1iZXIoIGFjY291bnQgKSApe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLkFDQ09VTlRfUEhPTkVfRVJST1IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFTZW5kQ2hlY2tcIiApO1xuICAgICAgICBwLmxwYWNrLnBob25lbnVtID0gYWNjb3VudDtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgICAgIHRoaXMuc2hvd1RpbWVyKCk7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY2MubGwucGhvbmVfY2hlY2tfdGltZSA9IE1hdGguY2VpbCggdGltZXN0YW1wIC8gMTAwMCApO1xuICAgIH0sXG5cbiAgICBvbkRpc3Ryb3k6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpO1xuICAgIH0sXG59KTtcbiIsInZhciBwYWNrZXQgPSByZXF1aXJlKCAnTHBhY2thZ2UnICk7XG52YXIgbXNnY29kZSA9IHJlcXVpcmUoICdNc2djb2RlJyApXG5cbmNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGFjY291bnRCb3ggOiB7XG4gICAgICAgICAgICBkZWZhdWx0IDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkVkaXRCb3gsXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFzc3dvcmRCb3ggOiB7XG4gICAgICAgICAgICBkZWZhdWx0IDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkVkaXRCb3gsXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFzc3dvcmRCb3gyIDoge1xuICAgICAgICAgICAgZGVmYXVsdCA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5FZGl0Qm94LFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxuICAgIG9uUmVnaXN0ZXJDbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWNjb3VudCA9IHRoaXMuYWNjb3VudEJveC5zdHJpbmc7XG4gICAgICAgIHZhciBwYXNzd29yZCA9IHRoaXMucGFzc3dvcmRCb3guc3RyaW5nO1xuICAgICAgICB2YXIgcGFzc3dvcmQyID0gdGhpcy5wYXNzd29yZEJveDIuc3RyaW5nO1xuXG4gICAgICAgIGlmIChhY2NvdW50Lmxlbmd0aCA+IDEyIHx8IGFjY291bnQubGVuZ3RoIDwgNiB8fFxuICAgICAgICAgICAgcGFzc3dvcmQubGVuZ3RoID4gMTIgfHwgcGFzc3dvcmQubGVuZ3RoIDwgNiApIHtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5BQ0NPVU5UX1RPT19MT05HKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFzc3dvcmQgIT0gcGFzc3dvcmQyKSB7XG4gICAgICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKG1zZ2NvZGUuUEFTU1dPUkRfTk9UX1NBTUUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFSZWdpc3RlclwiICk7XG4gICAgICAgIHAubHBhY2suYWNjb3VudCA9IGFjY291bnQ7XG4gICAgICAgIHAubHBhY2sucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWNjb3VudCcsIGFjY291bnQpO1xuICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Bhc3N3b3JkJywgcGFzc3dvcmQpO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcblxuICAgIG9uRGlzdHJveTpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7XG4gICAgfSxcbn0pO1xuIiwidmFyIHBhY2tldCA9IHJlcXVpcmUoICdMcGFja2FnZScgKVxudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBJRExhYmVsIDogY2MuRWRpdEJveCxcbiAgICAgICAgR29sZExhYmVsIDogY2MuRWRpdEJveCxcbiAgICAgICAgTmFtZUxhYmVsIDogY2MuTGFiZWwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIG9uR29sZEJ0bkNsaWNrZWQgOiBmdW5jdGlvbihldmVudCwgZGF0YSl7XG4gICAgICAgIHZhciBjdXIgPSBOdW1iZXIodGhpcy5Hb2xkTGFiZWwuc3RyaW5nKSB8fCAwO1xuICAgICAgICB2YXIgYWRkID0gTnVtYmVyKCBkYXRhICkgfHwgMDtcbiAgICAgICAgdGhpcy5Hb2xkTGFiZWwuc3RyaW5nID0gY3VyICsgYWRkO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7IFxuICAgIH0sXG5cbiAgICBvbkNsZWFuQnRuQ2xpY2tlZDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5Hb2xkTGFiZWwuc3RyaW5nID0gMDtcbiAgICAgICAgY2MubGwuc0F1ZGlvTWdyLnBsYXlOb3JtYWxCdG5DbGljaygpOyBcbiAgICB9LFxuXG4gICAgb25OYW1lRWRpdEVuZCA6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSApe1xuICAgICAgICB2YXIgaWQgPSBOdW1iZXIoIHRoaXMuSURMYWJlbC5zdHJpbmcgKTtcbiAgICAgICAgaWYoIGlkID4gMCApe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gcmVxdWlyZShcIkxMRXZlbnRcIik7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbmFtZWNhbGxiYWNrID0gZnVuY3Rpb24oIG9iaiApe1xuICAgICAgICAgICAgICAgIGlmKCBOdW1iZXIoc2VsZi5JRExhYmVsLnN0cmluZykgPT0gb2JqLmlkICl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuTmFtZUxhYmVsLnN0cmluZyA9IG9iai5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50LmFkZEV2ZW50KG5hbWVjYWxsYmFjayk7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxQ2hlY2tOYW1lXCIgKTtcbiAgICAgICAgICAgIHAubHBhY2suaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHAubHBhY2suaWQgPSBpZDtcbiAgICAgICAgICAgIGNjLmxsLm5ldC5zZW5kKCBwLnBhY2soKSApOyBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbk9rQnRuQ2xpY2tlZCA6IGZ1bmN0aW9uKCBldmVudCApe1xuICAgICAgICB2YXIgaWQgPSBOdW1iZXIodGhpcy5JRExhYmVsLnN0cmluZyk7XG5cbiAgICAgICAgaWYgKGlkIDw9IDApIHtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5DT01NT05fRVJST1JfSUQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnb2xkID0gTnVtYmVyKCB0aGlzLkdvbGRMYWJlbC5zdHJpbmcgKTtcbiAgICAgICAgaWYoIGdvbGQgPCA1MDAwMDAgKXtcbiAgICAgICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cobXNnY29kZS5UUkFOU1RGRVJfRVJST1JfR09MRCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5OYW1lTGFiZWwuc3RyaW5nO1xuICAgICAgICBpZiggbmFtZS5sZW5ndGggPD0gMCApe1xuICAgICAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhtc2djb2RlLm1zZ2NvZGUuQ09NTU9OX0VSUk9SX1VTRVIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBva2NhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFUcmFkZUdvbGRcIiApO1xuICAgICAgICAgICAgcC5scGFjay50b2lkID0gaWQ7XG4gICAgICAgICAgICBwLmxwYWNrLmdvbGQgPSBnb2xkO1xuICAgICAgICAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7IFxuICAgICAgICB9XG4gICAgICAgIHZhciBzdHIgPSBtc2djb2RlLlRSQU5TVEZFUl9TVUJNSVRfMSArIG5hbWUgKyBtc2djb2RlLlRSQU5TVEZFUl9TVUJNSVRfMiArIGdvbGQgKyBtc2djb2RlLlRSQU5TVEZFUl9TVUJNSVRfMztcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5sbC5ub3RpY2UuYWRkTXNnKDEsIHN0ciwgb2tjYWxsYmFjaywgbnVsbCk7XG4gICAgICAgIGNjLmxsLnNBdWRpb01nci5wbGF5Tm9ybWFsQnRuQ2xpY2soKTsgXG4gICAgfSxcblxuICAgIG9uTGF5ZXJEZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpO1xuICAgICAgICBjYy5sbC5zQXVkaW9NZ3IucGxheU5vcm1hbEJ0bkNsaWNrKCk7IFxuICAgIH0sXG59KTtcbiIsIi8vIFBsYXllck1hbmFnZXIuanNcblxudmFyIHBNZ3IgPSBjYy5DbGFzcyh7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBfcm9sZV9saXN0IDogbnVsbCxcbiAgICB9LFxuICAgIHN0YXRpY3MgOiB7XG4gICAgICAgIG1haW5fcm9sZSA6IG51bGwsXG4gICAgICAgIGluaXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcm9sZV9saXN0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFBsYXllcjogZnVuY3Rpb24oIHJvbGUgKXtcbiAgICAgICAgICAgIHRoaXMuX3JvbGVfbGlzdFsgcm9sZS5pZCBdID0gcm9sZTtcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcE1ncjsiLCJ2YXIgcCA9IGNjLkNsYXNzKHtcblx0cHJvcGVydGllczoge1xuXHRcdG5hbWUgOiBcIlwiLFxuXHRcdGlkIDogMCxcblx0XHRzdGF0ZSA6IDAsLy8gMOacqueZu+mZhu+8jCA+MCDlt7LnmbvlvZUgIDEg5Zyo5aSn5Y6FIDIg5Zyo5oi/6Ze0IDMg5Zyo5ri45oiP5LitXG5cdFx0cm9vbSA6IDAsXG5cdFx0Z29sZCA6IDAsXG5cdFx0Z21sZXZlbDowLFxuXHRcdF9saXN0IDogbnVsbCxcblx0XHRfZmlyc3RDaG9vc2UgOiBudWxsLFxuXHR9LFxuXG5cdGN0b3IgOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuX2ZpcnN0Q2hvb3NlID0gbmV3IGNjLkV2ZW50LkV2ZW50Q3VzdG9tKFwiR29sZENoYW5nZVwiLCBmYWxzZSk7XG5cdFx0dGhpcy5fbGlzdCA9IHt9O1xuXHR9LFxuXG5cdGxvZ2luIDogZnVuY3Rpb24oIG9iaiApe1xuXHRcdHRoaXMubmFtZSA9IG9iai5uYW1lO1xuXHRcdHRoaXMuaWQgPSBvYmouaWQ7XG5cdFx0dGhpcy5nb2xkID0gb2JqLmdvbGQ7XG5cdFx0dGhpcy5zdGF0ZSA9IDE7XG5cdFx0dGhpcy5yb29tID0gMDtcblx0XHR0aGlzLmdtbGV2ZWwgPSBvYmouZ207XG5cdFx0XG5cdFx0Y2MubGwucE1nci5tYWluX3JvbGUgPSB0aGlzO1xuICAgICAgICBjYy5sbC5zU2NlbmVNZ3Iub25DaGFuZ2VTY2VuZShcIm1haW52aWV3XCIpO1xuXHR9LFxuXG5cdHJlZ2lzdGVyIDogZnVuY3Rpb24oIGV2ZW50LCBub2RlLCBmdW5jICkge1xuXHRcdGlmKCB0aGlzLl9saXN0W2V2ZW50XSA9PSBudWxsICl7XG5cdFx0XHR0aGlzLl9saXN0W2V2ZW50XSA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLl9saXN0W2V2ZW50XVt0aGlzLl9saXN0W2V2ZW50XS5sZW5ndGhdID0gbm9kZTtcblx0XHRub2RlLm9uKGV2ZW50LCBmdW5jKVxuXHR9LFxuXG5cdG9uR29sZENoYW5nZWQgOiBmdW5jdGlvbiggZ29sZCApe1xuXHRcdHRoaXMuZ29sZCA9IGdvbGQ7XG5cdFx0dGhpcy5fZmlyc3RDaG9vc2Uuc2V0VXNlckRhdGEodGhpcy5nb2xkKTtcblx0XHRpZih0aGlzLl9saXN0W1wiR29sZENoYW5nZVwiXSAhPSBudWxsICYmIHRoaXMuX2xpc3RbXCJHb2xkQ2hhbmdlXCJdLmxlbmd0aCA+IDApe1xuXHRcdFx0dmFyIG5vZGVsaXN0ID0gdGhpcy5fbGlzdFtcIkdvbGRDaGFuZ2VcIl07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBub2RlID0gbm9kZWxpc3RbaV07XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0bm9kZS5kaXNwYXRjaEV2ZW50KHRoaXMuX2ZpcnN0Q2hvb3NlKSBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcDsiLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfUGxheWVyTmFtZSA6IG51bGwsXG4gICAgICAgIF9JRDowLFxuICAgICAgICBfVHlwZTowLFxuICAgICAgICBfRnJvbSA6IDAsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG5cbiAgICBvbkNoYW5nZU5hbWU6IGZ1bmN0aW9uKCBmcm9tLCBpZCwgbmFtZSwgdHlwZSApIHtcbiAgICAgICAgdGhpcy5fSUQgPSBpZDtcbiAgICAgICAgdGhpcy5fUGxheWVyTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX1R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9Gcm9tID0gZnJvbTtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICBsYWJlbC5zdHJpbmcgPSBuYW1lXG4gICAgICAgIGlmKHR5cGUgPT0gMSl7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY29sb3IgPSBuZXcgY2MuQ29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgIH1lbHNlIGlmKHR5cGUgPT0gMil7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY29sb3IgPSBuZXcgY2MuQ29sb3IoMjU1LCAxNjUsIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uTmFtZUNsaWNrZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiZyA9IGNjLmZpbmQoIFwiQ2FudmFzL0dhbWVCZ0xheWVyXCIgKTtcbiAgICAgICAgdmFyIGxvZ2ljID0gYmcuZ2V0Q29tcG9uZW50KCBcIkdhbWVMb2dpY1wiICk7XG4gICAgICAgIGxvZ2ljLm9uU2hvd1BsYXllckRldGFpbCggdGhpcy5fRnJvbSwgdGhpcy5fSUQsIHRoaXMuX1BsYXllck5hbWUgKVxuICAgIH0sXG59KTtcbiIsIi8vIFNjZW5lTWFuYWdlci5qc1xudmFyIFNjZW5lTWdyID0gY2MuQ2xhc3Moe1xuXHRzdGF0aWNzOntcblx0XHRvbkNoYW5nZVNjZW5lOiBmdW5jdGlvbihzY2VuZSl7XG5cdFx0XHQvLyBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoc2NlbmUpO1xuXHRcdFx0Y2MuZGlyZWN0b3IucHJlbG9hZFNjZW5lKHNjZW5lLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgLy8gY2MubG9nKCdOZXh0IHNjZW5lIHByZWxvYWRlZCcpO1xuXHRcdFx0ICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShzY2VuZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lTWdyOyIsIi8vU2V0dGluZ1ZpZXdMb2FkLmpzXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgIFx0X2NsaWNrZWQgOiBmYWxzZSxcbiAgICBcdGJhciA6IGNjLlByb2dyZXNzQmFyLFxuICAgIFx0YnRuU291bmQgOiBjYy5CdXR0b24sXG4gICAgXHRTcHJpdGVMaXN0IDogY2MuU3ByaXRlQXRsYXMsXG4gICAgfSxcblxuICAgIG9uTG9hZDpmdW5jdGlvbigpe1xuICAgIFx0dmFyIHNpemUgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NvdW5kU2l6ZScpO1xuICAgIFx0aWYoc2l6ZSA+IDApe1xuICAgIFx0XHR0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgXHR9ZWxzZXtcbiAgICBcdFx0dGhpcy5fY2xpY2tlZCA9IHRydWU7XG4gICAgXHR9XG4gICAgXHR0aGlzLm9uQXVkaW9DbGljayggbnVsbCwgdGhpcy5fY2xpY2tlZCApO1xuICAgIH0sXG5cbiAgICBvbkF1ZGlvU2V0dGluZyA6IGZ1bmN0aW9uKCBzbGlkZXIsIGN1c3RvbUV2ZW50RGF0YSApe1xuICAgIFx0dmFyIHNpemUgPSBzbGlkZXIucHJvZ3Jlc3M7XG4gICAgXHR0aGlzLmJhci5wcm9ncmVzcyA9IHNpemU7XG4gICAgXHRjYy5sbC5zQXVkaW9NZ3Iuc2V0U2l6ZSggc2l6ZSApO1xuICAgIH0sXG5cbiAgICBvbkF1ZGlvQ2xpY2sgOiBmdW5jdGlvbiggZSwgZm9yY2UgKXtcbiAgICBcdGlmKCBmb3JjZSAhPSBudWxsICl7XG4gICAgXHRcdHRoaXMuX2NsaWNrZWQgPSBmb3JjZTtcbiAgICBcdH1lbHNle1xuICAgIFx0XHR0aGlzLl9jbGlja2VkID0gIXRoaXMuX2NsaWNrZWQ7XG4gICAgXHR9XG5cbiAgICBcdGlmKCB0aGlzLl9jbGlja2VkICl7XG4gICAgXHRcdHRoaXMuYnRuU291bmQubm9ybWFsU3ByaXRlID0gdGhpcy5TcHJpdGVMaXN0LmdldFNwcml0ZUZyYW1lKCBcImJ0bl9zb3VuZF8yXCIgKTtcbiAgICBcdFx0Y2MubGwuc0F1ZGlvTWdyLnNldFNpemUoIDAgKTtcbiAgICBcdFx0XG4gICAgXHR9ZWxzZXtcbiAgICBcdFx0dGhpcy5idG5Tb3VuZC5ub3JtYWxTcHJpdGUgPSB0aGlzLlNwcml0ZUxpc3QuZ2V0U3ByaXRlRnJhbWUoIFwiYnRuX3NvdW5kXzFcIiApO1xuICAgIFx0XHRjYy5sbC5zQXVkaW9NZ3Iuc2V0U2l6ZSggMSApO1xuICAgIFx0fVxuICAgIH0sXG5cbiAgICBvbkRpc3Ryb3k6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5ub2RlLmRlc3Ryb3koKTtcbiAgICB9LFxufSk7IiwiLy9TZXR0aW5nVmlldy5qc1xudmFyIHNldHRpbmcgPSBjYy5DbGFzcyh7XG5cdHByb3BlcnRpZXM6IHtcblx0XHRwZmFiIDogbnVsbCxcblx0fSxcblx0c3RhdGljczp7XG5cdFx0c2hvd1NldHRpbmcgOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIG5vZGUgPSBjYy5pbnN0YW50aWF0ZSh0aGlzLnBmYWIpO1xuXHRcdFx0Y2MuZGlyZWN0b3IuZ2V0U2NlbmUoKS5hZGRDaGlsZChub2RlKTtcblx0XHR9LFxuXHRcdGluaXQgOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Y2MubG9hZGVyLmxvYWRSZXMoXCJwcm9mYWIvU2V0dGluZ0xheWVyXCIsIGZ1bmN0aW9uIChlcnIsIHByZWZhYikge1xuXHRcdFx0ICAgIHNlbGYucGZhYiA9IHByZWZhYjtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXR0aW5nOyIsInZhciBUdWlCaW5nQ29uZmlnID0ge1xuXHRTdGF0ZTp7XG5cdFx0U3RvcCA6IDAsIC8vIOacquWIneWni+WMllxuXHRcdEJlZ2luIDogMSwgLy8g5paw5ri45oiP5byA5aeLXG5cdFx0QmVnaW5fQ2hlY2tfQmVnaW4gOiAyLCAvLyDor6Lpl67mmK/lkKblvIDlp4vmuLjmiI9cblx0XHRCZWdpbl9DaGVja19LZWVwIDogMywgLy8g6K+i6Zeu5piv5ZCm57ut5bqEXG5cdFx0UmVhZHkgOiA0LCAvLyDlh4blpIflpb3lj6/ku6Xmirzms6hcblx0XHRXYWl0T3BlbiA6IDUsIC8vIOetieW+heW8gOeJjFxuXHRcdE9wZW5uaW5nIDogNiwgLy8g5byA54mM6Zi25q61XG5cdFx0UmV3YXJkIDogNywgLy8g5Y+R5pS+5aWW5YqxXG5cdH0sXG5cdFRpbWUgOiB7XG5cdFx0Ly8gV0FJVF9CRUdJTiA9IDUsIC0tIOetieW+heW8gOWni+a4uOaIj+aXtumXtFxuXHRcdC8vIFdBSVRfS0VFUCA9IDE1LCAtLSDnrYnlvoXnu63luoTml7bpl7Rcblx0XHQvLyBXQUlUX0JFVCA9IDEwLCAtLSDnrYnlvoXmirzms6jml7bpl7Rcblx0XHQvLyBXQUlUX09QRU4gPSAxMCwgLS0g5byA54mM5bGV56S65pe26Ze0XG5cdFx0Ly8gV0FJVF9SRVdBUkQgPSAyLCAtLSDlpZblirHlj5HpgIHml7bpl7Rcblx0XHRCZWdpbiA6IDUsXG5cdFx0QmVnaW5fa2VlcCA6IDMwLFxuXHRcdEJldCA6IDE1LFxuXHRcdFdhaXQgOiAzLFxuXHRcdE9wZW4gOiAxMCxcblx0XHRSZXdhcmQgOiA4LFxuXHR9LFxuXG5cdEJhbmtlck1heFRpbWVzIDogMjUgLCAvLyDmnIDpq5jkuIrluoTmrKHmlbBcblx0TGVzc0dvbGQgOiAxMDAwMCwgLy/mnIDkvY7ph5HluIFcblx0QmFua2VyTGVzc0dvbGQgOiAyMDAwMDAsIC8vIOS4iuW6hOacgOS9jumHkeW4gVxuXHRGYXN0QmFua2VyR29sZCA6IDIwMDAwMCwgLy8g5b+r6YCf5LiK5bqE57y057qz6YeRXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHVpQmluZ0NvbmZpZzsiLCIvKlxuIENvcHlyaWdodCAyMDEzLTIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cbiBcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiBcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiBcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuIFxuLyoqXG4gKiBAbGljZW5zZSBieXRlYnVmZmVyLmpzIChjKSAyMDE1IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gKiBCYWNraW5nIGJ1ZmZlcjogQXJyYXlCdWZmZXIsIEFjY2Vzc29yOiBVaW50OEFycmF5XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2J5dGVidWZmZXIuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuIFxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbXCJhbWRcIl0pXG4gICAgICAgIGRlZmluZShbXCJsb25nXCJdLCBmYWN0b3J5KTtcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxuICAgICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBMb25nOyB0cnkgeyBMb25nID0gcmVxdWlyZShcImxvbmdcIik7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShMb25nKTtcbiAgICAgICAgfSkoKTtcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiQnl0ZUJ1ZmZlclwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkxvbmdcIl0pO1xuIFxufSkodGhpcywgZnVuY3Rpb24oTG9uZykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuIFxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnl0ZUJ1ZmZlci5cbiAgICAgKiBAY2xhc3MgVGhlIHN3aXNzIGFybXkga25pZmUgZm9yIGJpbmFyeSBkYXRhIGluIEphdmFTY3JpcHQuXG4gICAgICogQGV4cG9ydHMgQnl0ZUJ1ZmZlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY2FwYWNpdHkgSW5pdGlhbCBjYXBhY2l0eS4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWX0uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICB2YXIgQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgY2FwYWNpdHkgPSBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFk7XG4gICAgICAgIGlmICh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU47XG4gICAgICAgIGlmICh0eXBlb2Ygbm9Bc3NlcnQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlQ7XG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gY2FwYWNpdHkgfCAwO1xuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eVwiKTtcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xuICAgICAgICAgICAgbm9Bc3NlcnQgPSAhIW5vQXNzZXJ0O1xuICAgICAgICB9XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWNraW5nIEFycmF5QnVmZmVyLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5QnVmZmVyfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGNhcGFjaXR5ID09PSAwID8gRU1QVFlfQlVGRkVSIDogbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVpbnQ4QXJyYXkgdXRpbGl6ZWQgdG8gbWFuaXB1bGF0ZSB0aGUgYmFja2luZyBidWZmZXIuIEJlY29tZXMgYG51bGxgIGlmIHRoZSBiYWNraW5nIGJ1ZmZlciBoYXMgYSBjYXBhY2l0eSBvZiBgMGAuXG4gICAgICAgICAqIEB0eXBlIHs/VWludDhBcnJheX1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gY2FwYWNpdHkgPT09IDAgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQWJzb2x1dGUgcmVhZC93cml0ZSBvZmZzZXQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2ZsaXBcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2NsZWFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrZWQgb2Zmc2V0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFic29sdXRlIGxpbWl0IG9mIHRoZSBjb250YWluZWQgZGF0YS4gU2V0IHRvIHRoZSBiYWNraW5nIGJ1ZmZlcidzIGNhcGFjaXR5IHVwb24gYWxsb2NhdGlvbi5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjZmxpcFxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjY2xlYXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGltaXQgPSBjYXBhY2l0eTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgYmlnIGVuZGlhbi5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLCBkZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub0Fzc2VydCA9IG5vQXNzZXJ0O1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogQnl0ZUJ1ZmZlciB2ZXJzaW9uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuVkVSU0lPTiA9IFwiNS4wLjFcIjtcbiBcbiAgICAvKipcbiAgICAgKiBMaXR0bGUgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGB0cnVlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOID0gdHJ1ZTtcbiBcbiAgICAvKipcbiAgICAgKiBCaWcgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGBmYWxzZWAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuQklHX0VORElBTiA9IGZhbHNlO1xuIFxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW5pdGlhbCBjYXBhY2l0eSBvZiBgMTZgLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSA9IDE2O1xuIFxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZW5kaWFuZXNzIG9mIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW4uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU4gPSBCeXRlQnVmZmVyLkJJR19FTkRJQU47XG4gXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBubyBhc3NlcnRpb25zIGZsYWcgb2YgYGZhbHNlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUID0gZmFsc2U7XG4gXG4gICAgLyoqXG4gICAgICogQSBgTG9uZ2AgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuIE1heSBiZSBgbnVsbGAgaWYgTG9uZy5qcyBoYXMgbm90IGJlZW4gbG9hZGVkXG4gICAgICogIGFuZCBpbnQ2NCBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICogQHR5cGUgez9Mb25nfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbG9uZy5qc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLkxvbmcgPSBMb25nIHx8IG51bGw7XG4gXG4gICAgLyoqXG4gICAgICogQGFsaWFzIEJ5dGVCdWZmZXIucHJvdG90eXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIEJ5dGVCdWZmZXJQcm90b3R5cGUgPSBCeXRlQnVmZmVyLnByb3RvdHlwZTtcbiBcbiAgICAvKipcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnl0ZUJ1ZmZlciBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5fX2lzQnl0ZUJ1ZmZlcl9fO1xuIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlQnVmZmVyUHJvdG90eXBlLCBcIl9faXNCeXRlQnVmZmVyX19cIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiBcbiAgICAvLyBoZWxwZXJzXG4gXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheUJ1ZmZlcn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgRU1QVFlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xuIFxuICAgIC8qKlxuICAgICAqIFN0cmluZy5mcm9tQ2hhckNvZGUgcmVmZXJlbmNlIGZvciBjb21waWxlLXRpbWUgcmVuYW1pbmcuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKC4uLm51bWJlcik6c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzb3VyY2UgZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZyB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gU291cmNlIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmVcbiAgICAgKiAgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYXJndW1lbnQgaXMgaW52YWxpZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZ1NvdXJjZShzKSB7XG4gICAgICAgIHZhciBpPTA7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBpIDwgcy5sZW5ndGggPyBzLmNoYXJDb2RlQXQoaSsrKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZXN0aW5hdGlvbiBmdW5jdGlvbiBmb3IgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcj0pOnVuZGVmaW5lZHxzdHJpbmd9IERlc3RpbmF0aW9uIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBjaGFyIGNvZGUuXG4gICAgICogIFJldHVybnMgdGhlIGZpbmFsIHN0cmluZyB3aGVuIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cy5cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdEZXN0aW5hdGlvbigpIHtcbiAgICAgICAgdmFyIGNzID0gW10sIHBzID0gW107IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcy5qb2luKCcnKStzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcyk7XG4gICAgICAgICAgICBpZiAoY3MubGVuZ3RoICsgYXJndW1lbnRzLmxlbmd0aCA+IDEwMjQpXG4gICAgICAgICAgICAgICAgcHMucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcykpLFxuICAgICAgICAgICAgICAgICAgICBjcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjY2Vzc29yIHR5cGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgVWludDhBcnJheWAgcmVzcGVjdGl2ZWx5IGBEYXRhVmlld2AgaW4gdGhlIGJyb3dzZXIgKGNsYXNzZXMpXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuYWNjZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgQnl0ZUJ1ZmZlciBiYWNrZWQgYnkgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNhcGFjaXR5IEluaXRpYWwgY2FwYWNpdHkuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFl9LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIEJ5dGVCdWZmZXJzIGludG8gb25lLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nPn0gYnVmZmVycyBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJzYCBjb250YWlucyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIixcbiAgICAgKiAgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIgZm9yIHRoZSByZXN1bHRpbmcgQnl0ZUJ1ZmZlci4gRGVmYXVsdHNcbiAgICAgKiAgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcyBmb3IgdGhlIHJlc3VsdGluZyBCeXRlQnVmZmVyLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENvbmNhdGVuYXRlZCBCeXRlQnVmZmVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24oYnVmZmVycywgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gbGl0dGxlRW5kaWFuO1xuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwYWNpdHkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTAsIGs9YnVmZmVycy5sZW5ndGgsIGxlbmd0aDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyc1tpXSkpXG4gICAgICAgICAgICAgICAgYnVmZmVyc1tpXSA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXJzW2ldLCBlbmNvZGluZyk7XG4gICAgICAgICAgICBsZW5ndGggPSBidWZmZXJzW2ldLmxpbWl0IC0gYnVmZmVyc1tpXS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkgY2FwYWNpdHkgKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXBhY2l0eSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxuICAgICAgICAgICAgYmk7XG4gICAgICAgIGk9MDsgd2hpbGUgKGk8aykge1xuICAgICAgICAgICAgYmkgPSBidWZmZXJzW2krK107XG4gICAgICAgICAgICBsZW5ndGggPSBiaS5saW1pdCAtIGJpLm9mZnNldDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gMCkgY29udGludWU7XG4gICAgICAgICAgICBiYi52aWV3LnNldChiaS52aWV3LnN1YmFycmF5KGJpLm9mZnNldCwgYmkubGltaXQpLCBiYi5vZmZzZXQpO1xuICAgICAgICAgICAgYmIub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBiYi5saW1pdCA9IGJiLm9mZnNldDtcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGEgQnl0ZUJ1ZmZlci5cbiAgICAgKiBAcGFyYW0geyp9IGJiIEJ5dGVCdWZmZXIgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgaXQgaXMgYSBCeXRlQnVmZmVyLCBvdGhlcndpc2UgYGZhbHNlYFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJiKSB7XG4gICAgICAgIHJldHVybiAoYmIgJiYgYmJbXCJfX2lzQnl0ZUJ1ZmZlcl9fXCJdKSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJhY2tpbmcgYnVmZmVyIHR5cGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgQXJyYXlCdWZmZXJgIGluIHRoZSBicm93c2VyIChjbGFzc2VzKVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLnR5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBidWZmZXIgb3IgYSBzdHJpbmcuIFNldHMgdGhlIGFsbG9jYXRlZCBCeXRlQnVmZmVyJ3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSB0byBgMGAgYW5kIGl0c1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlIGxlbmd0aCBvZiB0aGUgd3JhcHBlZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ3whQXJyYXkuPG51bWJlcj59IGJ1ZmZlciBBbnl0aGluZyB0aGF0IGNhbiBiZSB3cmFwcGVkXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0b1xuICAgICAqICBcInV0ZjhcIilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBBIEJ5dGVCdWZmZXIgd3JhcHBpbmcgYGJ1ZmZlcmBcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci53cmFwID0gZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9Bc3NlcnQgPSBsaXR0bGVFbmRpYW47XG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CYXNlNjQoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUhleChidWZmZXIsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tVVRGOChidWZmZXIsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21EZWJ1ZyhidWZmZXIsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIgPT09IG51bGwgfHwgdHlwZW9mIGJ1ZmZlciAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICAgICAgdmFyIGJiO1xuICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgYmIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLmNsb25lLmNhbGwoYnVmZmVyKTtcbiAgICAgICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuIGJiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IC8vIEV4dHJhY3QgQXJyYXlCdWZmZXIgZnJvbSBVaW50OEFycmF5XG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7IC8vIEF2b2lkIHJlZmVyZW5jZXMgdG8gbW9yZSB0aGFuIG9uZSBFTVBUWV9CVUZGRVJcbiAgICAgICAgICAgICAgICBiYi5idWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJ1ZmZlci5ieXRlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsgLy8gUmV1c2UgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYmIuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gYnVmZmVyLmJ5dGVMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJ1ZmZlcikgPT09IFwiW29iamVjdCBBcnJheV1cIikgeyAvLyBDcmVhdGUgZnJvbSBvY3RldHNcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoYnVmZmVyLmxlbmd0aCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XG4gICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YnVmZmVyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJiLnZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7IC8vIE90aGVyd2lzZSBmYWlsXG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgYXJyYXkgYXMgYSBiaXRzZXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxib29sZWFuPn0gdmFsdWUgQXJyYXkgb2YgYm9vbGVhbnMgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJpdFNldCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIEJpdFNldDogTm90IGFuIGFycmF5XCIpO1xuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICB9XG4gXG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXG4gICAgICAgICAgYml0cyA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxuICAgICAgICAgIGJpdCA9IDAsXG4gICAgICAgICAgaztcbiBcbiAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoYml0cyxvZmZzZXQpO1xuIFxuICAgICAgd2hpbGUoYnl0ZXMtLSkge1xuICAgICAgICBrID0gKCEhdmFsdWVbYml0KytdICYgMSkgfFxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDEpIHxcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAyKSB8XG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMykgfFxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDQpIHxcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA1KSB8XG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNikgfFxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDcpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcbiAgICAgIH1cbiBcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcbiAgICAgICAgdmFyIG0gPSAwOyBrID0gMDtcbiAgICAgICAgd2hpbGUoYml0IDwgYml0cykgayA9IGsgfCAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgKG0rKykpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcbiAgICAgIH1cbiBcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQml0U2V0IGFzIGFuIGFycmF5IG9mIGJvb2xlYW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJpdFNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuIFxuICAgICAgdmFyIHJldCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCksXG4gICAgICAgICAgYml0cyA9IHJldC52YWx1ZSxcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxuICAgICAgICAgIGJpdCA9IDAsXG4gICAgICAgICAgdmFsdWUgPSBbXSxcbiAgICAgICAgICBrO1xuIFxuICAgICAgb2Zmc2V0ICs9IHJldC5sZW5ndGg7XG4gXG4gICAgICB3aGlsZShieXRlcy0tKSB7XG4gICAgICAgIGsgPSB0aGlzLnJlYWRCeXRlKG9mZnNldCsrKTtcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDEpO1xuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMik7XG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA0KTtcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDgpO1xuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgxMCk7XG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDIwKTtcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4NDApO1xuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg4MCk7XG4gICAgICB9XG4gXG4gICAgICBpZihiaXQgPCBiaXRzKSB7XG4gICAgICAgIHZhciBtID0gMDtcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xuICAgICAgICB3aGlsZShiaXQgPCBiaXRzKSB2YWx1ZVtiaXQrK10gPSAhISgoayA+PiAobSsrKSkgJiAxKTtcbiAgICAgIH1cbiBcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIitsZW5ndGgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGF5bG9hZCBvZiBieXRlcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNhcHBlbmR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gd3JpdGUuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJ5dGVzID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5hcHBlbmQ7XG4gXG4gICAgLy8gdHlwZXMvaW50cy9pbnQ4XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkwICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDh9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJ5dGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50ODtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52aWV3W29mZnNldF07XG4gICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMHg4MCkgdmFsdWUgPSAtKDB4RkYgLSB2YWx1ZSArIDEpOyAvLyBDYXN0IHRvIHNpZ25lZFxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDh9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCeXRlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ODtcbiBcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHZhciBjYXBhY2l0eTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ4fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50OCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50ODtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52aWV3W29mZnNldF07XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50OH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQ4ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDg7XG4gXG4gICAgLy8gdHlwZXMvaW50cy9pbnQxNlxuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAmIDB4MDBGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXRdICAgPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICB2YWx1ZSAmIDB4MDBGRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQxNn0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQxNjtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODAwMCkgPT09IDB4ODAwMCkgdmFsdWUgPSAtKDB4RkZGRiAtIHZhbHVlICsgMSk7IC8vIENhc3QgdG8gc2lnbmVkXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MTZ9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdmFyIGNhcGFjaXR5MyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkzICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkzIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDI7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICYgMHgwMEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gIHZhbHVlICYgMHgwMEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDE2fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQxNiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTY7XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDIgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisyK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MTZ9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50MTYgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTY7XG4gXG4gICAgLy8gdHlwZXMvaW50cy9pbnQzMlxuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5NCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk0ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk0IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50MzJ9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzI7XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSB8PSAwOyAvLyBDYXN0IHRvIHNpZ25lZFxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDMyfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzI7XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk1KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDMyfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQzMjtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MzJ9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyO1xuIFxuICAgIC8vIHR5cGVzL2ludHMvaW50NjRcbiBcbiAgICBpZiAoTG9uZykge1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk2KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTYgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXG4gICAgICAgICAgICAgICAgaGkgPSB2YWx1ZS5oaWdoO1xuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50NjR9LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvID0gMCxcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50NjR9LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQ7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHk3ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NyA6IG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgICAgIHZhciBsbyA9IHZhbHVlLmxvdyxcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ2NH0uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDY0O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvID0gMCxcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ2NH0uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQ7XG4gXG4gICAgfSAvLyBMb25nXG4gXG4gXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0MzJcbiBcbiAgICAvKlxuICAgICBpZWVlNzU0IC0gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG4gXG4gICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuIFxuICAgICBDb3B5cmlnaHQgKGMpIEZlcm9zcyBBYm91a2hhZGlqZWhcbiBcbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgICBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAgIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICAgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiBcbiAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAgICAgYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAgICAgVEhFIFNPRlRXQVJFLlxuICAgICovXG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSUVFRTc1NCBmbG9hdCBmcm9tIGEgYnl0ZSBhcnJheS5cbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWVlZTc1NF9yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICAgICAgdmFyIGUsIG0sXG4gICAgICAgICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgICAgICAgbkJpdHMgPSAtNyxcbiAgICAgICAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgICAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcbiBcbiAgICAgICAgaSArPSBkO1xuIFxuICAgICAgICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgICAgICAgcyA+Pj0gKC1uQml0cyk7XG4gICAgICAgIG5CaXRzICs9IGVMZW47XG4gICAgICAgIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG4gXG4gICAgICAgIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICAgICAgICBlID4+PSAoLW5CaXRzKTtcbiAgICAgICAgbkJpdHMgKz0gbUxlbjtcbiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cbiBcbiAgICAgICAgaWYgKGUgPT09IDApIHtcbiAgICAgICAgICAgIGUgPSAxIC0gZUJpYXM7XG4gICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgICAgIGUgPSBlIC0gZUJpYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJRUVFNzU0IGZsb2F0IHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlc1xuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGllZWU3NTRfd3JpdGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICAgICAgdmFyIGUsIG0sIGMsXG4gICAgICAgICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICAgICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuIFxuICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcbiBcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICAgICAgICAgIGUgPSBlTWF4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgICAgICAgICAgIGUtLTtcbiAgICAgICAgICAgICAgICBjICo9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgICAgICAgICAgIGUrKztcbiAgICAgICAgICAgICAgICBjIC89IDI7XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICAgICAgICBlID0gZU1heDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICAgICAgICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgICAgICAgICAgIGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gXG4gICAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG4gXG4gICAgICAgIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gICAgICAgIGVMZW4gKz0gbUxlbjtcbiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuIFxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG4gICAgfVxuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDMyYml0IGZsb2F0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk4KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5OCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5OCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZWVlNzU0X3dyaXRlKHRoaXMudmlldywgdmFsdWUsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDMyYml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlRmxvYXQzMn0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0MzI7XG4gXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSAzMmJpdCBmbG9hdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gaWVlZTc1NF9yZWFkKHRoaXMudmlldywgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEZsb2F0MzJ9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMjtcbiBcbiAgICAvLyB0eXBlcy9mbG9hdHMvZmxvYXQ2NFxuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHZhciBjYXBhY2l0eTkgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk5KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5OSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5OSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICBpZWVlNzU0X3dyaXRlKHRoaXMudmlldywgdmFsdWUsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlRmxvYXQ2NH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZURvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgNjRiaXQgZmxvYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDY0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWREb3VibGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0O1xuIFxuIFxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50MzJcbiBcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDMyX0JZVEVTID0gNTtcbiBcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGVuY29kZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyByZXF1aXJlZC4gQ2FwcGVkIHRvIHtAbGluayBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFU31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgICAgICBpZiAodmFsdWUgPCAxIDw8IDcgKSByZXR1cm4gMTtcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDE0KSByZXR1cm4gMjtcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDIxKSByZXR1cm4gMztcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDI4KSByZXR1cm4gNDtcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDMyYml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBTaWduZWQgMzJiaXQgaW50ZWdlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIDMyYml0IGludGVnZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGUzMiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICgoKG4gfD0gMCkgPDwgMSkgXiAobiA+PiAzMSkpID4+PiAwOyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgemlnemFnIGVuY29kZWQgc2lnbmVkIDMyYml0IGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCAzMmJpdCBpbnRlZ2VyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAoKG4gPj4+IDEpIF4gLShuICYgMSkpIHwgMDsgLy8gLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKSxcbiAgICAgICAgICAgIGI7XG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgd2hpbGUgKHZhbHVlID49IDB4ODApIHtcbiAgICAgICAgICAgIGIgPSAodmFsdWUgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gNztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gdmFsdWU7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHppZy16YWcgZW5jb2RlZCAoc2lnbmVkKSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMlppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSwgb2Zmc2V0KTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcnwhe3ZhbHVlOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWRcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50LiBIYXMgYSBwcm9wZXJ0eSBgdHJ1bmNhdGVkID0gdHJ1ZWAgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIGF2YWlsYWJsZVxuICAgICAqICB0byBmdWxseSBkZWNvZGUgdGhlIHZhcmludC5cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IDAgPj4+IDAsXG4gICAgICAgICAgICBiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQgJiYgb2Zmc2V0ID4gdGhpcy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIlRydW5jYXRlZFwiKTtcbiAgICAgICAgICAgICAgICBlcnJbJ3RydW5jYXRlZCddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTtcbiAgICAgICAgICAgIGlmIChjIDwgNSlcbiAgICAgICAgICAgICAgICB2YWx1ZSB8PSAoYiAmIDB4N2YpIDw8ICg3KmMpO1xuICAgICAgICAgICAgKytjO1xuICAgICAgICB9IHdoaWxlICgoYiAmIDB4ODApICE9PSAwKTtcbiAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZSxcbiAgICAgICAgICAgIFwibGVuZ3RoXCI6IGNcbiAgICAgICAgfTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXG4gICAgICogIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQzMlppZ1phZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdmFsW1widmFsdWVcIl0gPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTMyKHZhbFtcInZhbHVlXCJdKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG4gXG4gICAgLy8gdHlwZXMvdmFyaW50cy92YXJpbnQ2NFxuIFxuICAgIGlmIChMb25nKSB7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVMgPSAxMDtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIGVuY29kZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVN9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXG4gICAgICAgICAgICB2YXIgcGFydDAgPSB2YWx1ZS50b0ludCgpID4+PiAwLFxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxuICAgICAgICAgICAgICAgIHBhcnQyID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHBhcnQyID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydDEgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDAgPCAxIDw8IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQwIDwgMSA8PCA3ID8gMSA6IDI7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgMjEgPyAzIDogNDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDEgPCAxIDw8IDE0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxIDwgMSA8PCA3ID8gNSA6IDY7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MSA8IDEgPDwgMjEgPyA3IDogODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDIgPCAxIDw8IDcgPyA5IDogMTA7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBaaWd6YWcgZW5jb2RlcyBhIHNpZ25lZCA2NGJpdCBpbnRlZ2VyIHNvIHRoYXQgaXQgY2FuIGJlIGVmZmVjdGl2ZWx5IHVzZWQgd2l0aCB2YXJpbnQgZW5jb2RpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBTaWduZWQgbG9uZ1xuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmdcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2hpZnRMZWZ0KDEpLnhvcih2YWx1ZS5zaGlmdFJpZ2h0KDYzKSkudG9VbnNpZ25lZCgpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIHppZ3phZyBlbmNvZGVkIHNpZ25lZCA2NGJpdCBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcn0gdmFsdWUgVW5zaWduZWQgemlnemFnIGVuY29kZWQgbG9uZyBvciBKYXZhU2NyaXB0IG51bWJlclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgxKS54b3IodmFsdWUuYW5kKExvbmcuT05FKS50b1NpZ25lZCgpLm5lZ2F0ZSgpKS50b1NpZ25lZCgpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfExvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xuICAgICAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpLFxuICAgICAgICAgICAgICAgIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKSA+Pj4gMCxcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKSA+Pj4gMDtcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5MTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTEpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTEgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTExIDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSBzaXplO1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogdGhpcy52aWV3W29mZnNldCs5XSA9IChwYXJ0MiA+Pj4gIDcpICYgMHgwMTtcbiAgICAgICAgICAgICAgICBjYXNlIDkgOiB0aGlzLnZpZXdbb2Zmc2V0KzhdID0gc2l6ZSAhPT0gOSA/IChwYXJ0MiAgICAgICApIHwgMHg4MCA6IChwYXJ0MiAgICAgICApICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDggOiB0aGlzLnZpZXdbb2Zmc2V0KzddID0gc2l6ZSAhPT0gOCA/IChwYXJ0MSA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMjEpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDcgOiB0aGlzLnZpZXdbb2Zmc2V0KzZdID0gc2l6ZSAhPT0gNyA/IChwYXJ0MSA+Pj4gMTQpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMTQpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDYgOiB0aGlzLnZpZXdbb2Zmc2V0KzVdID0gc2l6ZSAhPT0gNiA/IChwYXJ0MSA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gIDcpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDUgOiB0aGlzLnZpZXdbb2Zmc2V0KzRdID0gc2l6ZSAhPT0gNSA/IChwYXJ0MSAgICAgICApIHwgMHg4MCA6IChwYXJ0MSAgICAgICApICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDQgOiB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gc2l6ZSAhPT0gNCA/IChwYXJ0MCA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gMjEpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDMgOiB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gc2l6ZSAhPT0gMyA/IChwYXJ0MCA+Pj4gMTQpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gMTQpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDIgOiB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gc2l6ZSAhPT0gMiA/IChwYXJ0MCA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gIDcpICYgMHg3RjtcbiAgICAgICAgICAgICAgICBjYXNlIDEgOiB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gc2l6ZSAhPT0gMSA/IChwYXJ0MCAgICAgICApIHwgMHg4MCA6IChwYXJ0MCAgICAgICApICYgMHg3RjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgemlnLXphZyBlbmNvZGVkIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NFppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSksIG9mZnNldCk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICAgICAqICByZWFkIGlmIG9taXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYXJ0MCA9IDAsXG4gICAgICAgICAgICAgICAgcGFydDEgPSAwLFxuICAgICAgICAgICAgICAgIHBhcnQyID0gMCxcbiAgICAgICAgICAgICAgICBiICA9IDA7XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgID0gKGIgJiAweDdGKSAgICAgIDsgaWYgKCBiICYgMHg4MCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgfD0gKGIgJiAweDdGKSA8PCAyMTsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxICA9IChiICYgMHg3RikgICAgICA7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDEgfD0gKGIgJiAweDdGKSA8PCAxNDsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgMjE7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDIgfD0gKGIgJiAweDdGKSA8PCAgNzsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCdWZmZXIgb3ZlcnJ1blwiKTsgfX19fX19fX19fVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gTG9uZy5mcm9tQml0cyhwYXJ0MCB8IChwYXJ0MSA8PCAyOCksIChwYXJ0MSA+Pj4gNCkgfCAocGFydDIpIDw8IDI0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0LXN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICAgICAqICByZWFkIGlmIG9taXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDY0WmlnWmFnID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50NjQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsWyd2YWx1ZSddIGluc3RhbmNlb2YgTG9uZylcbiAgICAgICAgICAgICAgICB2YWxbXCJ2YWx1ZVwiXSA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbCA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gXG4gICAgfSAvLyBMb25nXG4gXG4gXG4gICAgLy8gdHlwZXMvc3RyaW5ncy9jc3RyaW5nXG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgTlVMTC10ZXJtaW5hdGVkIFVURjggZW5jb2RlZCBzdHJpbmcuIEZvciB0aGlzIHRvIHdvcmsgdGhlIHNwZWNpZmllZCBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgTlVMTFxuICAgICAqICBjaGFyYWN0ZXJzIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xuICAgICAqICBjb250YWluZWQgaW4gYHN0cmAgKyAxIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVDU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyLCBzbzpcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xuICAgICAgICBvZmZzZXQgKz0gaysxO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTIgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEyIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGsrMTtcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSAwO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzdHJpbmcgcmVhZCBtdXN0IG5vdCBjb250YWluIGFueSBOVUxMIGNoYXJhY3RlcnNcbiAgICAgKiAgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRDU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICAgICAgdGVtcDtcbiAgICAgICAgLy8gVVRGOCBzdHJpbmdzIGRvIG5vdCBjb250YWluIHplcm8gYnl0ZXMgaW4gYmV0d2VlbiBleGNlcHQgZm9yIHRoZSB6ZXJvIGNoYXJhY3RlciBpdHNlbGYsIHNvOlxuICAgICAgICB2YXIgc2QsIGIgPSAtMTtcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gdGhpcy5saW1pdClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA8IFwiK3RoaXMubGltaXQpO1xuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107XG4gICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IG51bGwgOiBiO1xuICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gc2QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogc2QoKSxcbiAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBvZmZzZXQgLSBzdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gXG4gICAgLy8gdHlwZXMvc3RyaW5ncy9pc3RyaW5nXG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gICAgICogQGV4cG9zZVxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUlTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICAgICAgaztcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xuICAgICAgICBvZmZzZXQgKz0gNCtrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEzKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEzIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQraztcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBzdGFydCArIDQgKyBrKVxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCs0K2spKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSVN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5yZWFkVVRGOFN0cmluZyhsZW4sIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUywgb2Zmc2V0ICs9IDQpO1xuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcbiAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuIFxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdXRmOHN0cmluZ1xuIFxuICAgIC8qKlxuICAgICAqIE1ldHJpY3MgcmVwcmVzZW50aW5nIG51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnMuIEV2YWx1YXRlcyB0byBgY2AuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTID0gJ2MnO1xuIFxuICAgIC8qKlxuICAgICAqIE1ldHJpY3MgcmVwcmVzZW50aW5nIG51bWJlciBvZiBieXRlcy4gRXZhbHVhdGVzIHRvIGBiYC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMgPSAnYic7XG4gXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVVRGOFN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xuICAgICAgICBvZmZzZXQgKz0gaztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE0ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBrO1xuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVVRGOFN0cmluZ30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc7XG4gXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggY2hhcmFjdGVycyBvZiBhIHN0cmluZy4gSmF2YVNjcmlwdCBpdHNlbGYgdXNlcyBVVEYtMTYsIHNvIHRoYXQgYSBzdHJpbmcnc1xuICAgICAqICBgbGVuZ3RoYCBwcm9wZXJ0eSBkb2VzIG5vdCByZWZsZWN0IGl0cyBhY3R1YWwgVVRGOCBzaXplIGlmIGl0IGNvbnRhaW5zIGNvZGUgcG9pbnRzIGxhcmdlciB0aGFuIDB4RkZGRi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOENoYXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVswXTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlc30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggYnl0ZXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVTdHJpbmcgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcztcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG1ldHJpY3MgTWV0cmljcyBzcGVjaWZ5aW5nIHdoYXQgYGxlbmd0aGAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlN9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoLCBtZXRyaWNzLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWV0cmljcztcbiAgICAgICAgICAgIG1ldHJpY3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0cmljcyA9PT0gJ3VuZGVmaW5lZCcpIG1ldHJpY3MgPSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlM7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICAgICAgc2Q7XG4gICAgICAgIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMpIHsgLy8gVGhlIHNhbWUgZm9yIG5vZGUgYW5kIHRoZSBicm93c2VyXG4gICAgICAgICAgICBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW5ndGggJiYgb2Zmc2V0IDwgdGhpcy5saW1pdCA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbihjcCkge1xuICAgICAgICAgICAgICAgICsraTsgdXRmeC5VVEY4dG9VVEYxNihjcCwgc2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIraStcIiA9PSBcIitsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IHNkKCksXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IG9mZnNldCAtIHN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrbGVuZ3RoK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gb2Zmc2V0ICsgbGVuZ3RoO1xuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0IDwgayA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCksIHRoaXMubm9Bc3NlcnQpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaylcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIitrKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogc2QoKSxcbiAgICAgICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldCAtIHN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRyaWNzOiBcIittZXRyaWNzKTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVURjhTdHJpbmd9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWV0cmljcyBNZXRyaWNzIHNwZWNpZnlpbmcgd2hhdCBgbmAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlN9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTdHJpbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nO1xuIFxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdnN0cmluZ1xuIFxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gICAgICogQGV4cG9zZVxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICAgICAgaywgbDtcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xuICAgICAgICBsID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihrKTtcbiAgICAgICAgb2Zmc2V0ICs9IGwraztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsK2s7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoaywgb2Zmc2V0KTtcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0K2srbClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiID09IFwiKyhvZmZzZXQraytsKSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBleHBvc2VcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVlN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnJlYWRVVEY4U3RyaW5nKGxlblsndmFsdWUnXSwgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTLCBvZmZzZXQgKz0gbGVuWydsZW5ndGgnXSk7XG4gICAgICAgIG9mZnNldCArPSBzdHJbJ2xlbmd0aCddO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHN0clsnc3RyaW5nJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdzdHJpbmcnOiBzdHJbJ3N0cmluZyddLFxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gXG4gXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBzb21lIGRhdGEgdG8gdGhpcyBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWhpbmQgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGFwcGVuZGVkXG4gICAgICogIGRhdGEncyBsZW5ndGguXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfSBzb3VyY2UgRGF0YSB0byBhcHBlbmQuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIGFwcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDwwMSAwMj4wMy5hcHBlbmQoPDA0IDA1PilgIHdpbGwgcmVzdWx0IGluIGA8MDEgMDIgMDQgMDU+LCAwNCAwNXxgXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDwwMSAwMj4wMy5hcHBlbmQoMDQgMDU+LCAxKWAgd2lsbCByZXN1bHQgaW4gYDwwMSAwND4wNSwgMDQgMDV8YFxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSlcbiAgICAgICAgICAgIHNvdXJjZSA9IEJ5dGVCdWZmZXIud3JhcChzb3VyY2UsIGVuY29kaW5nKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gYXBwZW5kXG4gICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHZhciBjYXBhY2l0eTE2ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTYpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTYgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnZpZXcuc2V0KHNvdXJjZS52aWV3LnN1YmFycmF5KHNvdXJjZS5vZmZzZXQsIHNvdXJjZS5saW1pdCksIG9mZnNldCk7XG4gICAgICAgIHNvdXJjZS5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYXQgYW5kIGFmdGVyIHRoZVxuICAgICAgICBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZSBsZW5ndGggb2YgdGhpcyBCeXRlQnVmZmVyJ3MgZGF0YS5cbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI2FwcGVuZFxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kKHRoaXMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhc3NlcnRpb25zIG9mIGFyZ3VtZW50IHR5cGVzIGFuZCBvZmZzZXRzLiBBc3NlcnRpb25zIGFyZSBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IHlvdSBjYW4gb3B0IHRvXG4gICAgICogIGRpc2FibGUgdGhlbSBpZiB5b3VyIGNvZGUgYWxyZWFkeSBtYWtlcyBzdXJlIHRoYXQgZXZlcnl0aGluZyBpcyB2YWxpZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzc2VydCBgdHJ1ZWAgdG8gZW5hYmxlIGFzc2VydGlvbnMsIG90aGVyd2lzZSBgZmFsc2VgXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24oYXNzZXJ0KSB7XG4gICAgICAgIHRoaXMubm9Bc3NlcnQgPSAhYXNzZXJ0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNhcGFjaXR5IG9mIHRoaXMgQnl0ZUJ1ZmZlcidzIGJhY2tpbmcgYnVmZmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENhcGFjaXR5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNhcGFjaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoaXMgQnl0ZUJ1ZmZlcidzIG9mZnNldHMgYnkgc2V0dGluZyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IHRvIGAwYCBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIHRoZVxuICAgICAqICBiYWNraW5nIGJ1ZmZlcidzIGNhcGFjaXR5LiBEaXNjYXJkcyB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9LlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5saW1pdCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGlzIEJ5dGVCdWZmZXIsIHByZXNldCB3aXRoIHRoaXMgQnl0ZUJ1ZmZlcidzIHZhbHVlcyBmb3Ige0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSxcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvcHkgV2hldGhlciB0byBjb3B5IHRoZSBiYWNraW5nIGJ1ZmZlciBvciB0byByZXR1cm4gYW5vdGhlciB2aWV3IG9uIHRoZSBzYW1lLCBkZWZhdWx0cyB0byBgZmFsc2VgXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDbG9uZWQgaW5zdGFuY2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNvcHkpIHtcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgYmIuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgYmIudmlldyA9IG5ldyBVaW50OEFycmF5KGJiLmJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYi5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgICAgIGJiLnZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgYmIub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xuICAgICAgICBiYi5saW1pdCA9IHRoaXMubGltaXQ7XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIENvbXBhY3RzIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSBiYWNrZWQgYnkgYSB7QGxpbmsgQnl0ZUJ1ZmZlciNidWZmZXJ9IG9mIGl0cyBjb250ZW50cycgbGVuZ3RoLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzXG4gICAgICogIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBXaWxsIHNldCBgb2Zmc2V0ID0gMGAgYW5kIGBsaW1pdCA9IGNhcGFjaXR5YCBhbmRcbiAgICAgKiAgYWRhcHQge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSB0byB0aGUgc2FtZSByZWxhdGl2ZSBwb3NpdGlvbiBpZiBzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gc3RhcnQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbiA9PT0gMCAmJiBlbmQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gQWxyZWFkeSBjb21wYWN0ZWRcbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIGJlZ2luO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEVNUFRZX0JVRkZFUjtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuKTtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGltaXQgPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ29weVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xuICAgICAgICB2YXIgY2FwYWNpdHkgPSBlbmQgLSBiZWdpbixcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcbiAgICAgICAgYmIubGltaXQgPSBjYXBhY2l0eTtcbiAgICAgICAgaWYgKGJiLm1hcmtlZE9mZnNldCA+PSAwKSBiYi5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XG4gICAgICAgIHRoaXMuY29weVRvKGJiLCAwLCBiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHRhcmdldE9mZnNldCBPZmZzZXQgdG8gY29weSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHRoZSB0YXJnZXQncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XG4gICAgICogIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgY29waWVkIGlmIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VPZmZzZXQgT2Zmc2V0IHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlXG4gICAgICogIG51bWJlciBvZiBieXRlcyBjb3BpZWQgaWYgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHNvdXJjZUxpbWl0IE9mZnNldCB0byBlbmQgY29weWluZyBmcm9tLCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldE9mZnNldCwgc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUsXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZTtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQ6IE5vdCBhIEJ5dGVCdWZmZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gKHRhcmdldFJlbGF0aXZlID0gdHlwZW9mIHRhcmdldE9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpID8gdGFyZ2V0Lm9mZnNldCA6IHRhcmdldE9mZnNldCB8IDA7XG4gICAgICAgIHNvdXJjZU9mZnNldCA9IChyZWxhdGl2ZSA9IHR5cGVvZiBzb3VyY2VPZmZzZXQgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMub2Zmc2V0IDogc291cmNlT2Zmc2V0IHwgMDtcbiAgICAgICAgc291cmNlTGltaXQgPSB0eXBlb2Ygc291cmNlTGltaXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5saW1pdCA6IHNvdXJjZUxpbWl0IHwgMDtcbiBcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldCA8IDAgfHwgdGFyZ2V0T2Zmc2V0ID4gdGFyZ2V0LmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgdGFyZ2V0IHJhbmdlOiAwIDw9IFwiK3RhcmdldE9mZnNldCtcIiA8PSBcIit0YXJnZXQuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoc291cmNlT2Zmc2V0IDwgMCB8fCBzb3VyY2VMaW1pdCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrc291cmNlT2Zmc2V0K1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuIFxuICAgICAgICB2YXIgbGVuID0gc291cmNlTGltaXQgLSBzb3VyY2VPZmZzZXQ7XG4gICAgICAgIGlmIChsZW4gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0OyAvLyBOb3RoaW5nIHRvIGNvcHlcbiBcbiAgICAgICAgdGFyZ2V0LmVuc3VyZUNhcGFjaXR5KHRhcmdldE9mZnNldCArIGxlbik7XG4gXG4gICAgICAgIHRhcmdldC52aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCksIHRhcmdldE9mZnNldCk7XG4gXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICAgICAgICBpZiAodGFyZ2V0UmVsYXRpdmUpIHRhcmdldC5vZmZzZXQgKz0gbGVuO1xuIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhhdCB0aGlzIEJ5dGVCdWZmZXIgaXMgYmFja2VkIGJ5IGEge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfSBvZiBhdCBsZWFzdCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5LiBJZiB0aGVcbiAgICAgKiAgY3VycmVudCBjYXBhY2l0eSBpcyBleGNlZWRlZCwgaXQgd2lsbCBiZSBkb3VibGVkLiBJZiBkb3VibGUgdGhlIGN1cnJlbnQgY2FwYWNpdHkgaXMgbGVzcyB0aGFuIHRoZSByZXF1aXJlZCBjYXBhY2l0eSxcbiAgICAgKiAgdGhlIHJlcXVpcmVkIGNhcGFjaXR5IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSBSZXF1aXJlZCBjYXBhY2l0eVxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoY3VycmVudCA8IGNhcGFjaXR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKChjdXJyZW50ICo9IDIpID4gY2FwYWNpdHkgPyBjdXJyZW50IDogY2FwYWNpdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgQnl0ZSB2YWx1ZSB0byBmaWxsIHdpdGguIElmIGdpdmVuIGFzIGEgc3RyaW5nLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLiBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICogQGV4YW1wbGUgYHNvbWVCeXRlQnVmZmVyLmNsZWFyKCkuZmlsbCgwKWAgZmlsbHMgdGhlIGVudGlyZSBiYWNraW5nIGJ1ZmZlciB3aXRoIHplcm9lc1xuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgYmVnaW4gPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW4gPj0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gZmlsbFxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHRoaXMudmlld1tiZWdpbisrXSA9IHZhbHVlO1xuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ID0gYmVnaW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhpcyBCeXRlQnVmZmVyIHJlYWR5IGZvciBhIG5ldyBzZXF1ZW5jZSBvZiB3cml0ZSBvciByZWxhdGl2ZSByZWFkIG9wZXJhdGlvbnMuIFNldHMgYGxpbWl0ID0gb2Zmc2V0YCBhbmRcbiAgICAgKiAgYG9mZnNldCA9IDBgLiBNYWtlIHN1cmUgYWx3YXlzIHRvIGZsaXAgYSBCeXRlQnVmZmVyIHdoZW4gYWxsIHJlbGF0aXZlIHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9ucyBhcmUgY29tcGxldGUuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbWl0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyBhbiBvZmZzZXQgb24gdGhpcyBCeXRlQnVmZmVyIHRvIGJlIHVzZWQgbGF0ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIG1hcmsuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYnl0ZSBvcmRlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBgdHJ1ZWAgZm9yIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgYGZhbHNlYCBmb3IgYmlnIGVuZGlhblxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpdHRsZUVuZGlhbjogTm90IGEgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzICh0bykgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGJpZyBlbmRpYW5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5MRSA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gISFsaXR0bGVFbmRpYW4gOiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzICh0bykgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJpZ0VuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGxpdHRsZSBlbmRpYW5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5CRSA9IGZ1bmN0aW9uKGJpZ0VuZGlhbikge1xuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBiaWdFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gIWJpZ0VuZGlhbiA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHNvbWUgZGF0YSB0byB0aGlzIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGVcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnxzdHJpbmd8IUFycmF5QnVmZmVyfSBzb3VyY2UgRGF0YSB0byBwcmVwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXQgd2lsbCBiZVxuICAgICAqICBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcHJlcGVuZGVkIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4pYCByZXN1bHRzIGluIGA8MDQgMDUgMDEgMDIgMDM+LCAwNCAwNXxgXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4sIDIpYCByZXN1bHRzIGluIGAwNDwwNSAwMiAwMz4sIDA0IDA1fGBcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihzb3VyY2UsIGVuY29kaW5nLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxuICAgICAgICAgICAgc291cmNlID0gQnl0ZUJ1ZmZlci53cmFwKHNvdXJjZSwgZW5jb2RpbmcpO1xuICAgICAgICB2YXIgbGVuID0gc291cmNlLmxpbWl0IC0gc291cmNlLm9mZnNldDtcbiAgICAgICAgaWYgKGxlbiA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBwcmVwZW5kXG4gICAgICAgIHZhciBkaWZmID0gbGVuIC0gb2Zmc2V0O1xuICAgICAgICBpZiAoZGlmZiA+IDApIHsgLy8gTm90IGVub3VnaCBzcGFjZSBiZWZvcmUgb2Zmc2V0LCBzbyByZXNpemUgKyBtb3ZlXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBkaWZmKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIHZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShvZmZzZXQsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gZGlmZjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCArPSBkaWZmO1xuICAgICAgICAgICAgdGhpcy5saW1pdCArPSBkaWZmO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0IC0gbGVuKTtcbiBcbiAgICAgICAgc291cmNlLm9mZnNldCA9IHNvdXJjZS5saW1pdDtcbiAgICAgICAgaWYgKHJlbGF0aXZlKVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFByZXBlbmRzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhbm90aGVyIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGVcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiAgcHJlcGVuZGVkIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQGV4cG9zZVxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNwcmVwZW5kXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xuICAgICAgICB0YXJnZXQucHJlcGVuZCh0aGlzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByaW50cyBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk9fSBvdXQgT3V0cHV0IGZ1bmN0aW9uIHRvIGNhbGwsIGRlZmF1bHRzIHRvIGNvbnNvbGUubG9nXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJpbnREZWJ1ZyA9IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICBpZiAodHlwZW9mIG91dCAhPT0gJ2Z1bmN0aW9uJykgb3V0ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICAgICAgb3V0KFxuICAgICAgICAgICAgdGhpcy50b1N0cmluZygpK1wiXFxuXCIrXG4gICAgICAgICAgICBcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIitcbiAgICAgICAgICAgIHRoaXMudG9EZWJ1ZygvKiBjb2x1bW5zICovIHRydWUpXG4gICAgICAgICk7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIHJlYWRhYmxlIGJ5dGVzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LCBzbyB0aGlzIHJldHVybnMgYGxpbWl0IC0gb2Zmc2V0YC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZW1haW5pbmcgcmVhZGFibGUgYnl0ZXMuIE1heSBiZSBuZWdhdGl2ZSBpZiBgb2Zmc2V0ID4gbGltaXRgLlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlbWFpbmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCAtIHRoaXMub2Zmc2V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoaXMgQnl0ZUJ1ZmZlcidzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uIElmIGFuIG9mZnNldCBoYXMgYmVlbiBtYXJrZWQgdGhyb3VnaCB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrfVxuICAgICAqICBiZWZvcmUsIGBvZmZzZXRgIHdpbGwgYmUgc2V0IHRvIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0sIHdoaWNoIHdpbGwgdGhlbiBiZSBkaXNjYXJkZWQuIElmIG5vIG9mZnNldCBoYXMgYmVlblxuICAgICAqICBtYXJrZWQsIHNldHMgYG9mZnNldCA9IDBgLlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5tYXJrZWRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEgYnVmZmVyIG9mIGF0IGxlYXN0IHRoZSBnaXZlbiBjYXBhY2l0eS4gV2lsbCBkbyBub3RoaW5nIGlmIGFscmVhZHkgdGhhdFxuICAgICAqICBsYXJnZSBvciBsYXJnZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IENhcGFjaXR5IHJlcXVpcmVkXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgY2FwYWNpdHlgIGlzIG5vdCBhIG51bWJlclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBjYXBhY2l0eSA8IDBgXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhcGFjaXR5ICE9PSAnbnVtYmVyJyB8fCBjYXBhY2l0eSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogXCIrY2FwYWNpdHkrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIGNhcGFjaXR5IHw9IDA7XG4gICAgICAgICAgICBpZiAoY2FwYWNpdHkgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2NhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA8IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIHZpZXcuc2V0KHRoaXMudmlldyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBzdGFydCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byByZXZlcnNlXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcy52aWV3LnN1YmFycmF5KGJlZ2luLCBlbmQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTa2lwcyB0aGUgbmV4dCBgbGVuZ3RoYCBieXRlcy4gVGhpcyB3aWxsIGp1c3QgYWR2YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuIE1heSBhbHNvIGJlIG5lZ2F0aXZlIHRvIG1vdmUgdGhlIG9mZnNldCBiYWNrLlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrbGVuZ3RoK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBsZW5ndGggfD0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyBsZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IDAgPD0gXCIrdGhpcy5vZmZzZXQrXCIgKyBcIitsZW5ndGgrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogU2xpY2VzIHRoaXMgQnl0ZUJ1ZmZlciBieSBjcmVhdGluZyBhIGNsb25lZCBpbnN0YW5jZSB3aXRoIGBvZmZzZXQgPSBiZWdpbmAgYW5kIGBsaW1pdCA9IGVuZGAuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmUgb2YgdGhpcyBCeXRlQnVmZmVyIHdpdGggc2xpY2luZyBhcHBsaWVkLCBiYWNrZWQgYnkgdGhlIHNhbWUge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgYmIub2Zmc2V0ID0gYmVnaW47XG4gICAgICAgIGJiLmxpbWl0ID0gZW5kO1xuICAgICAgICByZXR1cm4gYmI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYmFja2luZyBidWZmZXIgdGhhdCBjb250YWlucyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZUNvcHkgSWYgYHRydWVgIHJldHVybnMgYSBjb3B5LCBvdGhlcndpc2UgcmV0dXJucyBhIHZpZXcgcmVmZXJlbmNpbmcgdGhlIHNhbWUgbWVtb3J5IGlmXG4gICAgICogIHBvc3NpYmxlLiBEZWZhdWx0cyB0byBgZmFsc2VgXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKGZvcmNlQ29weSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBsaW1pdCA9IHRoaXMubGltaXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpbWl0OiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGxpbWl0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGxpbWl0IHx8IGxpbWl0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitvZmZzZXQrXCIgPD0gXCIrbGltaXQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogSXQncyBub3QgcG9zc2libGUgdG8gaGF2ZSBhbm90aGVyIEFycmF5QnVmZmVyIHJlZmVyZW5jZSB0aGUgc2FtZSBtZW1vcnkgYXMgdGhlIGJhY2tpbmcgYnVmZmVyLiBUaGlzIGlzXG4gICAgICAgIC8vIHBvc3NpYmxlIHdpdGggVWludDhBcnJheSNzdWJhcnJheSBvbmx5LCBidXQgd2UgaGF2ZSB0byByZXR1cm4gYW4gQXJyYXlCdWZmZXIgYnkgY29udHJhY3QuIFNvOlxuICAgICAgICBpZiAoIWZvcmNlQ29weSAmJiBvZmZzZXQgPT09IDAgJiYgbGltaXQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxpbWl0KVxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsaW1pdCAtIG9mZnNldCk7XG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKS5zdWJhcnJheShvZmZzZXQsIGxpbWl0KSwgMCk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmF3IGJ1ZmZlciBjb21wYWN0ZWQgdG8gY29udGFpbiB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN0b0J1ZmZlcn0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VDb3B5IElmIGB0cnVlYCByZXR1cm5zIGEgY29weSwgb3RoZXJ3aXNlIHJldHVybnMgYSB2aWV3IHJlZmVyZW5jaW5nIHRoZSBzYW1lIG1lbW9yeS5cbiAgICAgKiAgRGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAqIEByZXR1cm5zIHshQXJyYXlCdWZmZXJ9IENvbnRlbnRzIGFzIGFuIEFycmF5QnVmZmVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CdWZmZXI7XG4gXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIE91dHB1dCBlbmNvZGluZy4gUmV0dXJucyBhbiBpbmZvcm1hdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgb21pdHRlZCBidXQgYWxzbyBhbGxvd3NcbiAgICAgKiAgZGlyZWN0IGNvbnZlcnNpb24gdG8gXCJ1dGY4XCIsIFwiaGV4XCIsIFwiYmFzZTY0XCIgYW5kIFwiYmluYXJ5XCIgZW5jb2RpbmcuIFwiZGVidWdcIiByZXR1cm5zIGEgaGV4IHJlcHJlc2VudGF0aW9uIHdpdGhcbiAgICAgKiAgaGlnaGxpZ2h0ZWQgb2Zmc2V0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgZW5jb2RpbmdgIGlzIGludmFsaWRcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIFwiQnl0ZUJ1ZmZlckFCKG9mZnNldD1cIit0aGlzLm9mZnNldCtcIixtYXJrZWRPZmZzZXQ9XCIrdGhpcy5tYXJrZWRPZmZzZXQrXCIsbGltaXQ9XCIrdGhpcy5saW1pdCtcIixjYXBhY2l0eT1cIit0aGlzLmNhcGFjaXR5KCkrXCIpXCI7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIixcbiAgICAgICAgICAgIGJlZ2luID0gZW5jb2RpbmcsXG4gICAgICAgICAgICBlbmQgPSBiZWdpbjtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1VURjgoYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CYXNlNjQoYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CaW5hcnkoYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RlYnVnKCk7XG4gICAgICAgICAgICBjYXNlIFwiY29sdW1uc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sdW1ucygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuIFxuICAgIC8vIGx4aXYtZW1iZWRkYWJsZVxuIFxuICAgIC8qKlxuICAgICAqIGx4aXYtZW1iZWRkYWJsZSAoYykgMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAgICAgKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2x4aXYgZm9yIGRldGFpbHNcbiAgICAgKi9cbiAgICB2YXIgbHhpdiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGx4aXYgbmFtZXNwYWNlLlxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCo+fVxuICAgICAgICAgKiBAZXhwb3J0cyBseGl2XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbHhpdiA9IHt9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcmFjdGVyIGNvZGVzIGZvciBvdXRwdXQuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGFvdXQgPSBbXG4gICAgICAgICAgICA2NSwgNjYsIDY3LCA2OCwgNjksIDcwLCA3MSwgNzIsIDczLCA3NCwgNzUsIDc2LCA3NywgNzgsIDc5LCA4MCxcbiAgICAgICAgICAgIDgxLCA4MiwgODMsIDg0LCA4NSwgODYsIDg3LCA4OCwgODksIDkwLCA5NywgOTgsIDk5LCAxMDAsIDEwMSwgMTAyLFxuICAgICAgICAgICAgMTAzLCAxMDQsIDEwNSwgMTA2LCAxMDcsIDEwOCwgMTA5LCAxMTAsIDExMSwgMTEyLCAxMTMsIDExNCwgMTE1LCAxMTYsIDExNywgMTE4LFxuICAgICAgICAgICAgMTE5LCAxMjAsIDEyMSwgMTIyLCA0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDMsIDQ3XG4gICAgICAgIF07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFyYWN0ZXIgY29kZXMgZm9yIGlucHV0LlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBhaW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWFvdXQubGVuZ3RoOyBpPGs7ICsraSlcbiAgICAgICAgICAgIGFpblthb3V0W2ldXSA9IGk7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIGJ5dGVzIHRvIGJhc2U2NCBjaGFyIGNvZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZlxuICAgICAgICAgKiAgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENoYXJhY3RlcnMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBlbmNvZGVkIGNoYXJcbiAgICAgICAgICogIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBseGl2LmVuY29kZSA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XG4gICAgICAgICAgICB2YXIgYiwgdDtcbiAgICAgICAgICAgIHdoaWxlICgoYiA9IHNyYygpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRzdChhb3V0WyhiPj4yKSYweDNmXSk7XG4gICAgICAgICAgICAgICAgdCA9IChiJjB4Myk8PDQ7XG4gICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgfD0gKGI+PjQpJjB4ZjtcbiAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj40KSYweGYpKSYweDNmXSk7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAoYiYweGYpPDwyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGIgPSBzcmMoKSkgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFsodHwoKGI+PjYpJjB4MykpJjB4M2ZdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W2ImMHgzZl0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdCg2MSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W3QmMHgzZl0pLFxuICAgICAgICAgICAgICAgICAgICBkc3QoNjEpLFxuICAgICAgICAgICAgICAgICAgICBkc3QoNjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBiYXNlNjQgY2hhciBjb2RlcyB0byBieXRlcy5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBpbnZhbGlkXG4gICAgICAgICAqL1xuICAgICAgICBseGl2LmRlY29kZSA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XG4gICAgICAgICAgICB2YXIgYywgdDEsIHQyO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbChjKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBjb2RlOiBcIitjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDEgPT09ICd1bmRlZmluZWQnKSBmYWlsKGMpO1xuICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MiA9PT0gJ3VuZGVmaW5lZCcpIGZhaWwoYyk7XG4gICAgICAgICAgICAgICAgICAgIGRzdCgodDE8PDIpPj4+MHwodDImMHgzMCk+PjQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KCgodDImMHhmKTw8NCk+Pj4wfCh0MSYweDNjKT4+Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQyID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoKHQxJjB4Myk8PDYpPj4+MHx0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBpZiBhIHN0cmluZyBpcyB2YWxpZCBiYXNlNjQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICAgICAgICovXG4gICAgICAgIGx4aXYudGVzdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cik7XG4gICAgICAgIH07XG4gXG4gICAgICAgIHJldHVybiBseGl2O1xuICAgIH0oKTtcbiBcbiAgICAvLyBlbmNvZGluZ3MvYmFzZTY0XG4gXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYGJlZ2luYCBvciBgZW5kYCBpcyBvdXQgb2YgYm91bmRzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CYXNlNjQgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgYmVnaW4gPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgZW5kID0gdGhpcy5saW1pdDtcbiAgICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7IGVuZCA9IGVuZCB8IDA7XG4gICAgICAgIGlmIChiZWdpbiA8IDAgfHwgZW5kID4gdGhpcy5jYXBhY2l0eSB8fCBiZWdpbiA+IGVuZClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xuICAgICAgICB2YXIgc2Q7IGx4aXYuZW5jb2RlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJlZ2luIDwgZW5kID8gdGhpcy52aWV3W2JlZ2luKytdIDogbnVsbDtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCkpO1xuICAgICAgICByZXR1cm4gc2QoKTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoc3RyLmxlbmd0aC80KjMsIGxpdHRsZUVuZGlhbiksXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgbHhpdi5kZWNvZGUoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XG4gICAgICAgIH0pO1xuICAgICAgICBiYi5saW1pdCA9IGk7XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBiaW5hcnkgc3RyaW5nIHRvIGJhc2U2NCBsaWtlIGB3aW5kb3cuYnRvYWAgZG9lcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEJpbmFyeSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYnRvYVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmJ0b2EgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShzdHIpLnRvQmFzZTY0KCk7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGJpbmFyeSBsaWtlIGB3aW5kb3cuYXRvYmAgZG9lcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYjY0IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSBzdHJpbmdcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYXRvYlxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmF0b2IgPSBmdW5jdGlvbihiNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NChiNjQpLnRvQmluYXJ5KCk7XG4gICAgfTtcbiBcbiAgICAvLyBlbmNvZGluZ3MvYmluYXJ5XG4gXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmluYXJ5IGVuY29kZWQgc3RyaW5nXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQmluYXJ5ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGltaXQ7XG4gICAgICAgIGJlZ2luIHw9IDA7IGVuZCB8PSAwO1xuICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA+IHRoaXMuY2FwYWNpdHkoKSB8fCBiZWdpbiA+IGVuZClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgY2hhcnMgPSBbXSxcbiAgICAgICAgICAgIHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xuICAgICAgICAgICAgY2hhcnMucHVzaCh0aGlzLnZpZXdbYmVnaW4rK10pO1xuICAgICAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA+PSAxMDI0KVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNoYXJzKSksXG4gICAgICAgICAgICAgICAgY2hhcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJykgKyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZywgdGhhdCBpcyB1c2luZyBvbmx5IGNoYXJhY3RlcnMgMHgwMC0weEZGIGFzIGJ5dGVzLCB0byBhIEJ5dGVCdWZmZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBrID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGNoYXJDb2RlLFxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihrLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB3aGlsZSAoaTxrKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID4gMHhmZilcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiaWxsZWdhbCBjaGFyIGNvZGU6IFwiK2NoYXJDb2RlKTtcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGNoYXJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGJiLmxpbWl0ID0gaztcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG4gXG4gICAgLy8gZW5jb2RpbmdzL2RlYnVnXG4gXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcgd2l0aCBtYXJrZWQgb2Zmc2V0cy4gT2Zmc2V0IHN5bWJvbHMgYXJlOlxuICAgICAqICogYDxgIDogb2Zmc2V0LFxuICAgICAqICogYCdgIDogbWFya2VkT2Zmc2V0LFxuICAgICAqICogYD5gIDogbGltaXQsXG4gICAgICogKiBgfGAgOiBvZmZzZXQgYW5kIGxpbWl0LFxuICAgICAqICogYFtgIDogb2Zmc2V0IGFuZCBtYXJrZWRPZmZzZXQsXG4gICAgICogKiBgXWAgOiBtYXJrZWRPZmZzZXQgYW5kIGxpbWl0LFxuICAgICAqICogYCFgIDogb2Zmc2V0LCBtYXJrZWRPZmZzZXQgYW5kIGxpbWl0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29sdW1ucyBJZiBgdHJ1ZWAgcmV0dXJucyB0d28gY29sdW1ucyBoZXggKyBhc2NpaSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IUFycmF5LjxzdHJpbmc+fSBEZWJ1ZyBzdHJpbmcgb3IgYXJyYXkgb2YgbGluZXMgaWYgYGFzQXJyYXkgPSB0cnVlYFxuICAgICAqIEBleHBvc2VcbiAgICAgKiBAZXhhbXBsZSBgPjAwJzAxIDAyPDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYGxpbWl0PTAsIG1hcmtlZE9mZnNldD0xLCBvZmZzZXQ9M2BcbiAgICAgKiBAZXhhbXBsZSBgMDBbMDEgMDIgMDM+YCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYG9mZnNldD1tYXJrZWRPZmZzZXQ9MSwgbGltaXQ9NGBcbiAgICAgKiBAZXhhbXBsZSBgMDB8MDEgMDIgMDNgIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PWxpbWl0PTEsIG1hcmtlZE9mZnNldD0tMWBcbiAgICAgKiBAZXhhbXBsZSBgfGAgY29udGFpbnMgemVybyBieXRlcyB3aXRoIGBvZmZzZXQ9bGltaXQ9MCwgbWFya2VkT2Zmc2V0PS0xYFxuICAgICAqL1xuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9EZWJ1ZyA9IGZ1bmN0aW9uKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIGsgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGhleCA9IFwiXCIsXG4gICAgICAgICAgICBhc2MgPSBcIlwiLFxuICAgICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKGk8aykge1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMudmlld1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYiA8IDB4MTApIGhleCArPSBcIjBcIitiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaGV4ICs9IGIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpXG4gICAgICAgICAgICAgICAgICAgIGFzYyArPSBiID4gMzIgJiYgYiA8IDEyNyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoYikgOiAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBpICUgMTYgPT09IDAgJiYgaSAhPT0gaykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMykgaGV4ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaGV4K2FzYytcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICBoZXggPSBhc2MgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzLm9mZnNldCAmJiBpID09PSB0aGlzLmxpbWl0KVxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiIVwiIDogXCJ8XCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSB0aGlzLm9mZnNldClcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIltcIiA6IFwiPFwiO1xuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gdGhpcy5saW1pdClcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIl1cIiA6IFwiPlwiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiJ1wiIDogKGNvbHVtbnMgfHwgKGkgIT09IDAgJiYgaSAhPT0gaykgPyBcIiBcIiA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW5zICYmIGhleCAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMyoxNiszKVxuICAgICAgICAgICAgICAgIGhleCArPSBcIiBcIjtcbiAgICAgICAgICAgIG91dCArPSBoZXggKyBhc2MgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5zID8gb3V0IDogaGV4O1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzIHRvIGEgQnl0ZUJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIERlYnVnIHN0cmluZyB0byBkZWNvZGUgKG5vdCBiZSBnZW5lcmF0ZWQgd2l0aCBgY29sdW1ucyA9IHRydWVgKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3RvRGVidWdcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmZyb21EZWJ1ZyA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICAgICAgICB2YXIgayA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKCgoaysxKS8zKXwwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgY2gsIGIsXG4gICAgICAgICAgICBycyA9IGZhbHNlLCAvLyBSZXF1aXJlIHN5bWJvbCBuZXh0XG4gICAgICAgICAgICBobyA9IGZhbHNlLCBobSA9IGZhbHNlLCBobCA9IGZhbHNlLCAvLyBBbHJlYWR5IGhhcyBvZmZzZXQgKGhvKSwgbWFya2VkT2Zmc2V0IChobSksIGxpbWl0IChobCk/XG4gICAgICAgICAgICBmYWlsID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpPGspIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2ggPSBzdHIuY2hhckF0KGkrKykpIHtcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtIHx8IGhsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gaGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLm1hcmtlZE9mZnNldCA9IGJiLmxpbWl0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYmIubGltaXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobCB8fCBobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGwgPSBobSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBobCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYiA9IHBhcnNlSW50KGNoK3N0ci5jaGFyQXQoaSsrKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZhaWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2kpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICghaG8gfHwgIWhsKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBNaXNzaW5nIG9mZnNldCBvciBsaW1pdFwiKTtcbiAgICAgICAgICAgIGlmIChqPGJiLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIraitcIiA8IFwiK2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuIFxuICAgIC8vIGVuY29kaW5ncy9oZXhcbiBcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgYmVnaW4gPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBiZWdpbjtcbiAgICAgICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmxpbWl0IDogZW5kO1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pLFxuICAgICAgICAgICAgYjtcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W2JlZ2luKytdO1xuICAgICAgICAgICAgaWYgKGIgPCAweDEwKVxuICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiMFwiLCBiLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBlbHNlIG91dC5wdXNoKGIudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmZyb21IZXggPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoKGsgLyAyKSB8IDAsIGxpdHRsZUVuZGlhbiksXG4gICAgICAgICAgICBiO1xuICAgICAgICBmb3IgKHZhciBpPTAsIGo9MDsgaTxrOyBpKz0yKSB7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpKzIpLCAxNik7XG4gICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KVxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1oZXggY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgICAgIGJiLnZpZXdbaisrXSA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgYmIubGltaXQgPSBqO1xuICAgICAgICByZXR1cm4gYmI7XG4gICAgfTtcbiBcbiAgICAvLyB1dGZ4LWVtYmVkZGFibGVcbiBcbiAgICAvKipcbiAgICAgKiB1dGZ4LWVtYmVkZGFibGUgKGMpIDIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gICAgICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy91dGZ4IGZvciBkZXRhaWxzXG4gICAgICovXG4gICAgdmFyIHV0ZnggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1dGZ4IG5hbWVzcGFjZS5cbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdXRmeCA9IHt9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogTWF4aW11bSB2YWxpZCBjb2RlIHBvaW50LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICovXG4gICAgICAgIHV0ZnguTUFYX0NPREVQT0lOVCA9IDB4MTBGRkZGO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjggYnl0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlXG4gICAgICAgICAqL1xuICAgICAgICB1dGZ4LmVuY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xuICAgICAgICAgICAgdmFyIGNwID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBjcCA9IHNyYyxcbiAgICAgICAgICAgICAgICBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNwIDwgMHg4MClcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwJjB4N0YpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNwIDwgMHg4MDApXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDFGKXwweEMwKSxcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCA8IDB4MTAwMDApXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgwRil8MHhFMCksXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSxcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xOCkmMHgwNyl8MHhGMCksXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgzRil8MHg4MCksXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSxcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIFVURjggYnl0ZXMgdG8gVVRGOCBjb2RlIHBvaW50cy5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcbiAgICAgICAgICogIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDb2RlIHBvaW50cyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGRlY29kZWQgY29kZSBwb2ludC5cbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxhc3Qgc2VxdWVuY2UgaXMgdHJ1bmNhdGVkLiBIYXMgYW4gYXJyYXkgcHJvcGVydHkgYGJ5dGVzYCBob2xkaW5nIHRoZVxuICAgICAgICAgKiAgcmVtYWluaW5nIGJ5dGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcbiAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkLCBmYWlsID0gZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgICAgIGIgPSBiLnNsaWNlKDAsIGIuaW5kZXhPZihudWxsKSk7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKGIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIlRydW5jYXRlZEVycm9yXCI7XG4gICAgICAgICAgICAgICAgZXJyWydieXRlcyddID0gYjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKChhID0gc3JjKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhJjB4ODApID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBkc3QoYSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhFMCkgPT09IDB4QzApXG4gICAgICAgICAgICAgICAgICAgICgoYiA9IHNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYl0pLFxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MUYpPDw2KSB8IChiJjB4M0YpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEYwKSA9PT0gMHhFMClcbiAgICAgICAgICAgICAgICAgICAgKChiPXNyYygpKSA9PT0gbnVsbCB8fCAoYz1zcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGIsIGNdKSxcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDBGKTw8MTIpIHwgKChiJjB4M0YpPDw2KSB8IChjJjB4M0YpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEY4KSA9PT0gMHhGMClcbiAgICAgICAgICAgICAgICAgICAgKChiPXNyYygpKSA9PT0gbnVsbCB8fCAoYz1zcmMoKSkgPT09IG51bGwgfHwgKGQ9c3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiLCBjICxkXSksXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgwNyk8PDE4KSB8ICgoYiYweDNGKTw8MTIpIHwgKChjJjB4M0YpPDw2KSB8IChkJjB4M0YpKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0aW5nIGJ5dGU6IFwiK2EpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgVVRGMTYgY2hhcmFjdGVycyB0byBVVEY4IGNvZGUgcG9pbnRzLlxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENvZGUgcG9pbnRzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNvZGVcbiAgICAgICAgICogIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdXRmeC5VVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XG4gICAgICAgICAgICB2YXIgYzEsIGMyID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjMSA9IGMyICE9PSBudWxsID8gYzIgOiBzcmMoKSkgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjMSA+PSAweEQ4MDAgJiYgYzEgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYzIgPSBzcmMoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjMiA+PSAweERDMDAgJiYgYzIgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KChjMS0weEQ4MDApKjB4NDAwK2MyLTB4REMwMCsweDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMiA9IG51bGw7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRzdChjMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYzIgIT09IG51bGwpIGRzdChjMik7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjE2IGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBjb2RlIHBvaW50IGlzIG91dCBvZiByYW5nZVxuICAgICAgICAgKi9cbiAgICAgICAgdXRmeC5VVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIGNwID0gc3JjLCBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNwIDw9IDB4RkZGRilcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNwIC09IDB4MTAwMDAsXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3A+PjEwKSsweEQ4MDApLFxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJTB4NDAwKSsweERDMDApO1xuICAgICAgICAgICAgICAgIGNwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGFuZCBlbmNvZGVzIFVURjE2IGNoYXJhY3RlcnMgdG8gVVRGOCBieXRlcy5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgXG4gICAgICAgICAqICBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XG4gICAgICAgICAgICB1dGZ4LlVURjE2dG9VVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcbiAgICAgICAgICAgICAgICB1dGZ4LmVuY29kZVVURjgoY3AsIGRzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW5kIGNvbnZlcnRzIFVURjggYnl0ZXMgdG8gVVRGMTYgY2hhcmFjdGVycy5cbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcbiAgICAgICAgICogIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxhc3Qgc2VxdWVuY2UgaXMgdHJ1bmNhdGVkLiBIYXMgYW4gYXJyYXkgcHJvcGVydHkgYGJ5dGVzYCBob2xkaW5nIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XG4gICAgICAgICAgICAgICAgdXRmeC5VVEY4dG9VVEYxNihjcCwgZHN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gVVRGOCBjb2RlIHBvaW50LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3AgVVRGOCBjb2RlIHBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXG4gICAgICAgICAqL1xuICAgICAgICB1dGZ4LmNhbGN1bGF0ZUNvZGVQb2ludCA9IGZ1bmN0aW9uKGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBVVEY4IGNvZGUgcG9pbnRzLlxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCl9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludCByZXNwZWN0aXZlbHlcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0LlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWRcbiAgICAgICAgICovXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGOCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICAgICAgdmFyIGNwLCBsPTA7XG4gICAgICAgICAgICB3aGlsZSAoKGNwID0gc3JjKCkpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGwgKz0gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGNvZGUgcG9pbnRzIHJlc3BlY3RpdmVseSBVVEY4IGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIFVURjE2IGNoYXIgY29kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKX0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXG4gICAgICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IFRoZSBudW1iZXIgb2YgVVRGOCBjb2RlIHBvaW50cyBhdCBpbmRleCAwIGFuZCB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWQgYXQgaW5kZXggMS5cbiAgICAgICAgICovXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjggPSBmdW5jdGlvbihzcmMpIHtcbiAgICAgICAgICAgIHZhciBuPTAsIGw9MDtcbiAgICAgICAgICAgIHV0ZnguVVRGMTZ0b1VURjgoc3JjLCBmdW5jdGlvbihjcCkge1xuICAgICAgICAgICAgICAgICsrbjsgbCArPSAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtuLGxdO1xuICAgICAgICB9O1xuIFxuICAgICAgICByZXR1cm4gdXRmeDtcbiAgICB9KCk7XG4gXG4gICAgLy8gZW5jb2RpbmdzL3V0ZjhcbiBcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIGFuIFVURjggZW5jb2RlZFxuICAgICAqICBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvVVRGOCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Q7IHRyeSB7XG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWdpbiA8IGVuZCA/IHRoaXMudmlld1tiZWdpbisrXSA6IG51bGw7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChiZWdpbiAhPT0gZW5kKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYmVnaW4rXCIgIT0gXCIrZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2QoKTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBCeXRlQnVmZmVyLmZyb21VVEY4ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgICAgIGlmICghbm9Bc3NlcnQpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIodXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdHJ1ZSlbMV0sIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XG4gICAgICAgIH0pO1xuICAgICAgICBiYi5saW1pdCA9IGk7XG4gICAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuIFxuICAgIHJldHVybiBCeXRlQnVmZmVyO1xufSk7XG4iLCIvLyBFcnJvckNvZGUuanNcbnZhciBFcnJvckNvZGUgPSB7fVxuXG5FcnJvckNvZGUuQUNDT1VOVF9SRVBFQVQgPSAxXG5FcnJvckNvZGUuREJTRVJWSUNFX0VSUk9SID0gOTlcbkVycm9yQ29kZS5OT19BQ0NPVU5UID0gMTAxXG5FcnJvckNvZGUuUEFTU1dPUkRfRVJST1IgPSAxMDJcbkVycm9yQ29kZS5IQVNfT05MSU5FID0gMTAzXG5FcnJvckNvZGUuTk9fVVNFUl9JRCA9IDEwNVxuRXJyb3JDb2RlLk5PVF9PTkxJTkUgPSAxMDZcbkVycm9yQ29kZS5BQ0NPVU5UX1NFQUwgPSAxMDdcblxuRXJyb3JDb2RlLlJPT01fTk9UX0ZPVU5EID0gMjAxXG5FcnJvckNvZGUuUk9PTV9GVUxMID0gMjAyXG5cbkVycm9yQ29kZS5HT0xEX05PVF9FTk9VR0ggPSAzMDFcbkVycm9yQ29kZS5CQU5LRVJfTk9fQkVUID0gNDAxXG5FcnJvckNvZGUuTk9UX0JBTktFUiA9IDQwMlxuRXJyb3JDb2RlLk5PVF9JTl9RVUVVRSA9IDQwM1xuRXJyb3JDb2RlLlVSX0JBTktFUiA9IDQwNFxuRXJyb3JDb2RlLkhBU19JTl9RVUVVRSA9IDQwNVxuRXJyb3JDb2RlLlRVSUJJTkdfUk9PTUNMT1NFID0gNDA2XG5cbi8vIG1haGpvbmdcbkVycm9yQ29kZS5NQUhKT05HX1JPT01fRlVMTCA9IDUwMVxuRXJyb3JDb2RlLk1BSEpPTkdfUExBWUVSX05PVF9GT1VORCA9IDUwMlxuRXJyb3JDb2RlLk1BSEpPTkdfTUpfTk9UX0ZPVU5EID0gNTAzXG5FcnJvckNvZGUuTUFISk9OR19FUlJPUl9DT01NQU5EID0gNTA0XG5cbi8vIERCXG5FcnJvckNvZGUuREJfUExBWUVSX05PVF9GT1VORCA9IDcwMVxuLy8gR01cbkVycm9yQ29kZS5QRVJNSVNTSU9OX0RFTklFRCA9IDkwMVxuRXJyb3JDb2RlLkxPR1RZUEVfRVJST1IgPSA5MDJcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yQ29kZTsiLCJjYy5DbGFzcyh7XG5cdGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblx0c3RhdGljczoge1xuXHRcdGlwIDogXCIxOTQuMTY4LjAuMjI1XCIsXG5cdFx0Ly8gaXAgOiBcIjExOS4yOS4xNzkuMTI2XCIsXG5cdFx0cG9ydCA6IDgwMDEsXG5cdFx0dmVyc2lvbiA6IFwiMS4wLjAuMVwiLFxuXHR9LFxuXHRcbn0pOyIsIi8qXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cbiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBsb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2xvbmcuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeSgpO1xuICAgIC8qIEdsb2JhbCAqLyBlbHNlXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJMb25nXCJdID0gZmFjdG9yeSgpO1xuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gICAgICogQGV4cG9ydHMgTG9uZ1xuICAgICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuICAgIC8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuICAgIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuICAgIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuICAgIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuICAgIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbiAgICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4gICAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgIC8vXG4gICAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4gICAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cblxuICAgIC8qKlxuICAgICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nLmlzTG9uZyA9IGlzTG9uZztcblxuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBJTlRfQ0FDSEUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBVSU5UX0NBQ0hFID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICAgICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZSlcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XG4gICAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcbiAgICAgICAgfVxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuXG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFpFUk87XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh2YWwgLyogaXMgY29tcGF0aWJsZSAqLyBpbnN0YW5jZW9mIExvbmcpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwpO1xuICAgICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHZhbC51bnNpZ25lZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xuXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxuICAgIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBaRVJPID0gZnJvbUludCgwKTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25lZCB6ZXJvLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZy5aRVJPID0gWkVSTztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVW5zaWduZWQgemVyby5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25lZCBvbmUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nLk9ORSA9IE9ORTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVbnNpZ25lZCBvbmUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nLlVPTkUgPSBVT05FO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XG5cbiAgICAvKipcbiAgICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHhGRkZGRkZGRnwwLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgICAgICAgICAgcmVtID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcbiAgICAgICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcbiAgICAgICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcbiAgICAgICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xuICAgICAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxuICAgICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG5cbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcblxuICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XG5cbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhGRkZGO1xuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweEZGRkY7XG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XG4gICAgICAgIGM0OCAmPSAweEZGRkY7XG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XG4gICAgICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxuICAgICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG5cbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcblxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAgICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuXG4gICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG5cbiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XG4gICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcblxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweEZGRkY7XG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhGRkZGO1xuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweEZGRkY7XG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhGRkZGO1xuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAgICAgKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgICAgICAgICAgcmVzID0gWkVSTztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxuICAgICAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxuICAgICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBVWkVSTztcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVPTkU7XG4gICAgICAgICAgICByZXMgPSBVWkVSTztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcbiAgICAgICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cbiAgICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcblxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgbnVtQml0cyAmPSA2MztcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gICAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExvbmc7XG59KTtcbiIsInZhciBwYWNrZXQgPSByZXF1aXJlKCBcIkxwYWNrYWdlXCIgKVxudmFyIG1zZ2NvZGUgPSByZXF1aXJlKCAnTXNnY29kZScgKVxudmFyIEVycm9yQ29kZSA9IHJlcXVpcmUoIFwiZXJyb3Jjb2RlXCIgKVxudmFyIFR1aUJpbmdDb25maWcgPSByZXF1aXJlKFwiVHVpQmluZ0NvbmZpZ1wiKVxuXG52YXIgb25Mb2dpbiA9IGZ1bmN0aW9uKCBwYWNrICl7XG4gICAgdmFyIHJlc3VsdCA9IHBhY2sucmVzdWx0O1xuICAgIGlmICggcmVzdWx0ID09IDAgKSB7XG4gICAgICAgIHZhciBvYmogPSB7aWQ6cGFjay5pZCwgbmFtZTpwYWNrLm5hbWUsIGdvbGQ6cGFjay5nb2xkLCBnbTpwYWNrLmdtbGV2ZWx9XG4gICAgICAgIHZhciBwbGF5ZXIgPSByZXF1aXJlKCdQbGF5ZXInKVxuICAgICAgICB2YXIgcFBsYXllciA9IG5ldyBwbGF5ZXIoKTtcbiAgICAgICAgcFBsYXllci5sb2dpbihvYmopXG4gICAgfWVsc2UgaWYoIHJlc3VsdCA9PSBFcnJvckNvZGUuQUNDT1VOVF9TRUFMICl7XG4gICAgICAgIHZhciB0aW1lc3RhbXAzID0gcGFjay5pZDtcbiAgICAgICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBuZXdEYXRlLnNldFRpbWUodGltZXN0YW1wMyAqIDEwMDApO1xuICAgICAgICB2YXIgbXNnID0gbXNnY29kZVsgcmVzdWx0IF0gKyBcIiBcIiArIG5ld0RhdGUudG9Mb2NhbGVTdHJpbmcoKSArIG1zZ2NvZGUuRU5EX0NPTE9SICttc2djb2RlLkVORF9TSVpFO1xuICAgICAgICBjYy5sbC5ub3RpY2UuYWRkTXNnICggMiwgbXNnLCBudWxsKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgIH1cbiAgICBjYy5sbC5sb2FkaW5nLnJlbW92ZUxvYWRpbmcoKTtcbn1cblxudmFyIG9uUmVnaXN0ZXIgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdCA7XG4gICAgaWYgKCByZXN1bHQgIT0gMCApe1xuICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKHJlc3VsdCk7XG4gICAgfVxufVxuXG52YXIgb25FbnRlclJvb20gPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdDtcbiAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgY2MubGwuc1NjZW5lTWdyLm9uQ2hhbmdlU2NlbmUoXCJ0dWliaW5ndmlld1wiKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgIH1cbn1cblxudmFyIG9uQmVCYW5rZXIgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdDtcbiAgICBpZiAocmVzdWx0ICE9IDAgKXtcbiAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgIH1cbn1cblxudmFyIG9uVHVpYmluZ1VuYmFua2VyID0gZnVuY3Rpb24oIHBhY2sgKXtcbiAgICB2YXIgcmVzdWx0ID0gcGFjay5yZXN1bHQ7XG4gICAgaWYgKHJlc3VsdCAhPSAwICl7XG4gICAgICAgIGNjLmxsLm1zZ2JveC5hZGRNc2cocmVzdWx0KTtcbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyXCIpO1xuICAgICAgICBpZiggbm9kZSApe1xuICAgICAgICAgICAgdmFyIHZpZXdsb2dpYyA9IG5vZGUuZ2V0Q29tcG9uZW50KFwiT25HYW1lVmlld0xvYWRcIik7XG4gICAgICAgICAgICB2aWV3bG9naWMuc2hvd1VuQmFua2VyVGlwcygpOyBcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIG9uVHVpYmluZ0xlYXZlUXVldWUgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdDtcbiAgICBpZiAocmVzdWx0ICE9IDAgKXtcbiAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgIH1cbn1cblxudmFyIG9uVHVpQmluZ1F1ZXVlQ2hhbmdlID0gZnVuY3Rpb24oIHBhY2sgKSB7XG4gICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyXCIpO1xuICAgIGlmKCBub2RlICl7XG4gICAgICAgIHZhciBnYW1lbG9naWMgPSBub2RlLmdldENvbXBvbmVudChcIkdhbWVMb2dpY1wiKTtcbiAgICAgICAgdmFyIGJhbmtlciA9IHsgXG4gICAgICAgICAgICBiYW5rZXJpZDogcGFjay5iYW5rZXJpZCwgIFxuICAgICAgICAgICAgYmFua2VybmFtZSA6IHBhY2suYmFua2VybmFtZSxcbiAgICAgICAgfVxuICAgICAgICBnYW1lbG9naWMub25RdWV1ZUNoYW5nZWQoYmFua2VyLCBwYWNrLnF1ZXVlKTtcbiAgICB9XG59XG5cbnZhciBvblR1aUJpbmdHYW1lU3RhdGUgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciBzdGF0ZSA9IHBhY2suc3RhdGVcbiAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvR2FtZUJnTGF5ZXJcIik7XG4gICAgaWYoIG5vZGUgKXtcbiAgICAgICAgdmFyIGdhbWVsb2dpYyA9IG5vZGUuZ2V0Q29tcG9uZW50KCBcIkdhbWVMb2dpY1wiICk7XG4gICAgICAgIGdhbWVsb2dpYy5vbkdhbWVTdGF0ZUNoYW5nZSggc3RhdGUgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlID09IFR1aUJpbmdDb25maWcuU3RhdGUuUmVhZHkpIHtcbiAgICAgICAgY2MubGwubm90aWNlLnJlbW92ZU1zZyg5OTgpO1xuICAgIH1cbn1cblxudmFyIG9uR29sZENoYW5nZSA9IGZ1bmN0aW9uKCBwYWNrICl7XG4gICAgdmFyIGdvbGQgPSBwYWNrLmdvbGQ7XG4gICAgY2MubGwucE1nci5tYWluX3JvbGUub25Hb2xkQ2hhbmdlZCggZ29sZCApO1xufVxuXG52YXIgb25UdWlCaW5nQmV0ID0gZnVuY3Rpb24oIHBhY2sgKSB7XG4gICAgdmFyIHJlc3VsdCA9IHBhY2sucmVzdWx0O1xuICAgIHZhciBpZCA9IHBhY2suaWQ7XG4gICAgdmFyIHBvcyA9IHBhY2sucG9zO1xuICAgIHZhciBnb2xkID0gcGFjay5nb2xkO1xuICAgIGlmIChyZXN1bHQgPT0gMCl7XG4gICAgICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9HYW1lQmdMYXllclwiKTtcbiAgICAgICAgaWYoIG5vZGUgKXtcbiAgICAgICAgICAgIHZhciBnYW1lbG9naWMgPSBub2RlLmdldENvbXBvbmVudCggXCJHYW1lTG9naWNcIiApO1xuICAgICAgICAgICAgZ2FtZWxvZ2ljLm9uUGxheWVyQmV0KCBpZCwgcG9zLCBnb2xkIClcbiAgICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgICBjYy5sbC5tc2dib3guYWRkTXNnKHJlc3VsdCk7XG4gICAgfVxufVxuXG52YXIgb25LZWVwQmFua2VyID0gZnVuY3Rpb24oIHBhY2sgKSB7XG4gICAgLy8gbGV0IGJlZ2luY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgdmFyIHAgPSBuZXcgcGFja2V0KCBcIlJlcUtlZXBCYW5rZXJcIiApO1xuICAgIC8vICAgICBwLmxwYWNrLmlza2VlcCA9IDA7XG4gICAgLy8gICAgIHAubHBhY2suZ29sZCA9IDIwMDAwMDtcbiAgICAvLyAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgLy8gfVxuICAgIC8vIGxldCBlbmRjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgICAvL+S4i+W6hFxuICAgIC8vICAgICB2YXIgcCA9IG5ldyBwYWNrZXQoIFwiUmVxS2VlcEJhbmtlclwiICk7XG4gICAgLy8gICAgIHAubHBhY2suaXNrZWVwID0gMTtcbiAgICAvLyAgICAgcC5scGFjay5nb2xkID0gMDtcbiAgICAvLyAgICAgY2MubGwubmV0LnNlbmQoIHAucGFjaygpICk7XG4gICAgLy8gfVxuICAgIC8vIGNjLmxsLm5vdGljZS5hZGRNc2coMSxtc2djb2RlLlRVSUJJTkdfS0VFUF9CQU5LRVIsIGJlZ2luY2FsbGJhY2ssIGVuZGNhbGxiYWNrLCA5OTgpO1xuICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9HYW1lQmdMYXllclwiKTtcbiAgICBpZiggbm9kZSApe1xuICAgICAgICB2YXIgZ2FtZXZpZXdsb2FkID0gbm9kZS5nZXRDb21wb25lbnQoIFwiT25HYW1lVmlld0xvYWRcIiApO1xuICAgICAgICBnYW1ldmlld2xvYWQub25TaG93S2VlcEJhbmtlcigpXG4gICAgfVxufVxuXG52YXIgb25CYW5rZXJCZWdpbiA9IGZ1bmN0aW9uKCBwYWNrICkge1xuICAgIGxldCBiZWdpbmNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFUdWlCaW5nQmVnaW5cIiApO1xuICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcbiAgICB9XG4gICAgbGV0IGVuZGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8v5LiL5bqEXG4gICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggXCJSZXFLZWVwQmFua2VyXCIgKTtcbiAgICAgICAgcC5scGFjay5pc2tlZXAgPSAxO1xuICAgICAgICBwLmxwYWNrLmdvbGQgPSAwO1xuICAgICAgICBjYy5sbC5uZXQuc2VuZCggcC5wYWNrKCkgKTtcbiAgICB9XG4gICAgdmFyIHRpbWUgPSBUdWlCaW5nQ29uZmlnLlRpbWUuQmVnaW47XG4gICAgdmFyIHN0ciA9IG1zZ2NvZGUuVFVJQklOR19CQU5LRVJfQkVHSU4gKyBcIjxici8+PGNvbG9yPSNGRjAwMDA+PHNpemUgPSAyNT4wMDowXCIrdGltZStcIjwvY29sb3I+PC9zaXplPlwiO1xuICAgIHZhciBub2RlID0gY2MubGwubm90aWNlLmFkZE1zZygxLHN0ciwgYmVnaW5jYWxsYmFjaywgZW5kY2FsbGJhY2ssIDk5OCk7XG4gICAgdmFyIG1zZ25vZGUgPSBub2RlLmdldENoaWxkQnlOYW1lKFwiTm90aWNlQmdcIikuZ2V0Q2hpbGRCeU5hbWUoXCJOb3RpY2VMYWJlbFwiKTtcbiAgICB2YXIgbXNnbGFiZWwgPSBtc2dub2RlLmdldENvbXBvbmVudChjYy5SaWNoVGV4dCk7XG4gICAgXG4gICAgdmFyIGludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICB0aW1lLS07XG4gICAgICAgIGlmIChjYy5pc1ZhbGlkKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gbXNnY29kZS5UVUlCSU5HX0JBTktFUl9CRUdJTiArIFwiPGJyLz48Y29sb3I9I0ZGMDAwMD48c2l6ZSA9IDI1PjAwOjBcIit0aW1lK1wiPC9jb2xvcj48L3NpemU+XCI7XG4gICAgICAgICAgICBtc2dsYWJlbC5zdHJpbmcgPSBzdHI7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJRCk7IH0sIHRpbWUgKiAxMDAwKTtcbn1cblxudmFyIG9uVHVpQmluZ0JldEdvbGQgPSBmdW5jdGlvbiggcGFjayApIHtcbiAgICB2YXIgZ29sZGxpc3QgPSBwYWNrLmdvbGQ7XG4gICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL0dhbWVCZ0xheWVyXCIpO1xuICAgIGlmKCBub2RlICl7XG4gICAgICAgIHZhciBnYW1lbG9naWMgPSBub2RlLmdldENvbXBvbmVudCggXCJHYW1lTG9naWNcIiApO1xuICAgICAgICAvLyBnYW1lbG9naWMub25Hb2xkQWN0aW9uKCBnb2xkIClcbiAgICAgICAgZ2FtZWxvZ2ljLm9uQmV0R29sZENvdW50KCBnb2xkbGlzdCApO1xuICAgIH1cbn1cblxudmFyIG9uRGVhbE1hamlhbmcgPSBmdW5jdGlvbiggcGFjayApIHtcbiAgICB2YXIgbWFqaWFuZ3MgPSBwYWNrLm1hamlhbmdzXG4gICAgdmFyIGRpY2UxID0gcGFjay5kaWNlMVxuICAgIHZhciBkaWNlMiA9IHBhY2suZGljZTJcbiAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvR2FtZUJnTGF5ZXJcIik7XG4gICAgaWYoIG5vZGUgKXtcbiAgICAgICAgdmFyIGdhbWVsb2dpYyA9IG5vZGUuZ2V0Q29tcG9uZW50KCBcIkdhbWVMb2dpY1wiICk7XG4gICAgICAgIC8vIGdhbWVsb2dpYy5vbkdvbGRBY3Rpb24oIGdvbGQgKVxuICAgICAgICBnYW1lbG9naWMub25PcGVuTWFqaWFuZyggbWFqaWFuZ3MsIGRpY2UxLCBkaWNlMiApO1xuICAgIH1cbn1cblxudmFyIG9uQ2xvc2VDbGllbnQgPSBmdW5jdGlvbiggcGFjayApIHtcbiAgICB2YXIgdHlwZSA9IHBhY2sudHlwZTtcbiAgICB2YXIgbXNnID0gXCJ1bmtub3cgZXJyb3JcIjtcbiAgICBpZih0eXBlID09IDEpe1xuICAgICAgICBtc2cgPSBtc2djb2RlLk5FVFdPUktfT1RIRVJfTE9HSU47XG4gICAgfWVsc2UgaWYoIHR5cGUgPT0gMiApe1xuICAgICAgICBtc2cgPSBtc2djb2RlLk5FVFdPUktfUkVMT0dJTjtcbiAgICB9XG4gICAgdmFyIG9rY2FsbGJhY2sgPSBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICBjYy5sbC5zU2NlbmVNZ3Iub25DaGFuZ2VTY2VuZShcImxvZ2ludmlld1wiKTtcbiAgICB9XG4gICAgY2MubGwubm90aWNlLmFkZE1zZyAoIDIsIG1zZywgb2tjYWxsYmFjayk7XG59XG5cbnZhciBvblR1aWJpbmdCYW5rZXJJbmZvID0gZnVuY3Rpb24oIHBhY2sgKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbmFtZSA6IHBhY2submFtZSxcbiAgICAgICAgaWQgOiBwYWNrLmlkLFxuICAgICAgICBnb2xkIDogcGFjay5nb2xkLFxuICAgICAgICB0aW1lcyA6IHBhY2sudGltZXMsXG4gICAgfTtcbiAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvR2FtZUJnTGF5ZXJcIik7XG4gICAgaWYoIG5vZGUgKXtcbiAgICAgICAgdmFyIGdhbWVsb2dpYyA9IG5vZGUuZ2V0Q29tcG9uZW50KCBcIkdhbWVMb2dpY1wiICk7XG4gICAgICAgIGdhbWVsb2dpYy5vbkJhbmtlckluZm8oIG9iaiApO1xuICAgIH1cbn1cblxudmFyIG9uUmVzS2VlcEJhbmtlciA9IGZ1bmN0aW9uKCBwYWNrICkge1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdDtcbiAgICBpZiAocmVzdWx0ICE9IDAgKXtcbiAgICAgICAgY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgIH1cbn1cblxudmFyIG9uVG9UdWlCaW5nUmVzdWx0ID0gZnVuY3Rpb24oIHBhY2sgKSB7XG4gICAgdmFyIHdpbmxpc3QgPSBwYWNrLmlzd2luZXI7XG4gICAgdmFyIGdvbGRsaXN0ID0gcGFjay5wb3Nnb2xkO1xuICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9HYW1lQmdMYXllclwiKTtcbiAgICBpZiggbm9kZSApe1xuICAgICAgICB2YXIgZ2FtZWxvZ2ljID0gbm9kZS5nZXRDb21wb25lbnQoIFwiR2FtZUxvZ2ljXCIgKTtcbiAgICAgICAgZ2FtZWxvZ2ljLm9uU2VuZFJld2FyZCggd2lubGlzdCwgZ29sZGxpc3QgKTtcbiAgICB9XG59XG5cbnZhciBvblR1aWJpbmdBbGxQbGF5ZXIgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciBsaXN0ID0gcGFjay5saXN0O1xuICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9HYW1lQmdMYXllclwiKTtcbiAgICBpZiggbm9kZSApe1xuICAgICAgICB2YXIgZ2FtZWxvZ2ljID0gbm9kZS5nZXRDb21wb25lbnQoIFwiR2FtZUxvZ2ljXCIgKTtcbiAgICAgICAgZ2FtZWxvZ2ljLm9uU2hvd0FsbFBsYXllciggbGlzdCApO1xuICAgIH1cbn1cblxudmFyIG9uQWRkR29sZCA9IGZ1bmN0aW9uKCBwYWNrICl7XG4gICAgdmFyIHJlc3VsdCA9IHBhY2sucmVzdWx0O1xuICAgIGlmIChyZXN1bHQgPT0gMCkge1xuICAgICAgICBjYy5sbC5ub3RpY2UuYWRkTXNnKDIsIG1zZ2NvZGUuR01fUEFZTUVOVF9PSywgZnVuY3Rpb24oKXt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYy5sbC5ub3RpY2UuYWRkTXNnKDIsIHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIGNjLmxsLmxvYWRpbmcucmVtb3ZlTG9hZGluZygpO1xufVxuXG52YXIgb25DaGVja05hbWUgPSBmdW5jdGlvbiggcGFjayApe1xuICAgIHZhciByZXN1bHQgPSBwYWNrLnJlc3VsdDtcbiAgICBpZiAocmVzdWx0ID09IDApe1xuICAgICAgICB2YXIgaW5kZXggPSBwYWNrLmluZGV4O1xuICAgICAgICB2YXIgaWQgPSBwYWNrLmlkO1xuICAgICAgICB2YXIgbmFtZSA9IHBhY2submFtZTtcbiAgICAgICAgdmFyIGV2ZW50ID0gcmVxdWlyZShcIkxMRXZlbnRcIik7XG4gICAgICAgIHZhciBvYmogPSB7aWQgOiBpZCwgbmFtZSA6IG5hbWV9O1xuICAgICAgICBldmVudC5kaXNwYXRjaEV2ZW50KCBpbmRleCwgb2JqIClcbiAgICB9ZWxzZXtcbiAgICAgICAgLy8gY2MubGwubXNnYm94LmFkZE1zZyhyZXN1bHQpO1xuICAgICAgICB2YXIgbm9kZSA9IGNjLmxsLm5vdGljZS5hZGRNc2coIDIsIHJlc3VsdCwgbnVsbCk7XG4gICAgICAgIG5vZGUuc2V0VGltZU91dCggMyApO1xuICAgIH1cbn1cblxudmFyIG9uVG9UcmFkZUdvbGQgPSBmdW5jdGlvbihwYWNrKXtcbiAgICB2YXIgaWQgPSBwYWNrLmZyb21pZDtcbiAgICB2YXIgbmFtZSA9IHBhY2suZnJvbW5hbWU7XG4gICAgdmFyIGdvbGQgPSBwYWNrLmdvbGQ7XG5cbiAgICB2YXIgc3RyID0gbXNnY29kZS5UUkFOU1RGRVJfTk9USUNFXzEgKyBuYW1lICsgbXNnY29kZS5UUkFOU1RGRVJfTk9USUNFXzIgKyBnb2xkICsgbXNnY29kZS5UUkFOU1RGRVJfTk9USUNFXzNcbiAgICBjYy5sbC5ub3RpY2UuYWRkTXNnKCAyLCBzdHIsIG51bGwpO1xufVxuXG52YXIgb25UcmFkZUdvbGQgPSBmdW5jdGlvbihwYWNrKXtcbiAgICB2YXIgcmVzdWx0ID0gcGFjay5yZXN1bHQ7XG4gICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgIHZhciBub2RlID0gY2MubGwubm90aWNlLmFkZE1zZyggMiwgbXNnY29kZS5UUkFOU1RGRVJfQ09NUExFVEUsIG51bGwpO1xuICAgIH1lbHNle1xuICAgICAgICB2YXIgbm9kZSA9IGNjLmxsLm5vdGljZS5hZGRNc2coIDIsIHJlc3VsdCwgbnVsbCk7XG4gICAgfVxufVxuXG52YXIgRnVuY01hcCA9IHtcbiAgICBcIlJlc2xvZ2luXCI6IG9uTG9naW4sXG4gICAgXCJSZXNSZWdpc3RlclwiIDogb25SZWdpc3RlcixcbiAgICBcIlJlc0VudGVyUm9vbVwiIDogb25FbnRlclJvb20sXG4gICAgXCJSZXNCZUJhbmtlclwiIDogb25CZUJhbmtlcixcbiAgICBcIlJlc1R1aUJpbmdRdWV1ZUNoYW5nZVwiIDogb25UdWlCaW5nUXVldWVDaGFuZ2UsXG4gICAgXCJUb1R1aUJpbmdHYW1lU3RhdGVcIiA6IG9uVHVpQmluZ0dhbWVTdGF0ZSxcbiAgICBcIlRvR29sZENoYW5nZVwiIDogb25Hb2xkQ2hhbmdlLFxuICAgIFwiUmVzVHVpQmluZ0JldFwiIDogb25UdWlCaW5nQmV0LFxuICAgIFwiVG9LZWVwQmFua2VyXCIgOiBvbktlZXBCYW5rZXIsXG4gICAgXCJSZXNLZWVwQmFua2VyXCIgOiBvblJlc0tlZXBCYW5rZXIsXG4gICAgXCJUb0JhbmtlckJlZ2luXCIgOiBvbkJhbmtlckJlZ2luLFxuICAgIFwiVG9UdWlCaW5nQmV0R29sZFwiIDogb25UdWlCaW5nQmV0R29sZCxcbiAgICBcIlRvRGVhbE1hamlhbmdcIiA6IG9uRGVhbE1hamlhbmcsXG4gICAgXCJUb0Nsb3NlQ2xpZW50XCIgOiBvbkNsb3NlQ2xpZW50LFxuICAgIFwiVG9UdWliaW5nQmFua2VySW5mb1wiIDogb25UdWliaW5nQmFua2VySW5mbyxcbiAgICBcIlJlc1R1aUJpbmdVbmJhbmtlclwiIDogb25UdWliaW5nVW5iYW5rZXIsXG4gICAgXCJSZXNUdWliaW5nTGVhdmVRdWV1ZVwiIDogb25UdWliaW5nTGVhdmVRdWV1ZSxcbiAgICBcIlRvVHVpQmluZ1Jlc3VsdFwiIDogb25Ub1R1aUJpbmdSZXN1bHQsXG4gICAgXCJSZXNUdWlCaW5nQWxsUGxheWVyXCIgOiBvblR1aWJpbmdBbGxQbGF5ZXIsXG4gICAgXCJSZXNBZGRHb2xkXCIgOiBvbkFkZEdvbGQsXG4gICAgXCJSZXNDaGVja05hbWVcIiA6IG9uQ2hlY2tOYW1lLFxuICAgIFwiVG9UcmVhZGVHb2xkXCIgOiBvblRvVHJhZGVHb2xkLFxuICAgIFwiUmVzVHJhZGVHb2xkXCIgOiBvblRyYWRlR29sZCxcbn1cblxudmFyIG1zZ2Rpc3BhdGNoID0gY2MuQ2xhc3Moe1xuICAgIC8vIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBuYW1lIDogXCJNc2dEaXNwYXRjaFwiLFxuICAgIHN0YXRpY3M6e1xuICAgICAgICBkaXNwYXRjaCA6IGZ1bmN0aW9uKGhlYWQsIGJ1ZmZlcil7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IEZ1bmNNYXBbaGVhZF07XG4gICAgICAgICAgICBpZiAoZnVuYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IHBhY2tldCggaGVhZCApO1xuICAgICAgICAgICAgICAgIHAudW5wYWNrKCBidWZmZXIgKTtcbiAgICAgICAgICAgICAgICBmdW5jKCBwLm1zZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG59KVxubW9kdWxlLmV4cG9ydHMgPSBtc2dkaXNwYXRjaDsiLCIvKlxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbiBcbi8qKlxuICogQGxpY2Vuc2UgcHJvdG9idWYuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuIFxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbXCJhbWRcIl0pXG4gICAgICAgIGRlZmluZShbXCJieXRlYnVmZmVyXCJdLCBmYWN0b3J5KTtcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpLCB0cnVlKTtcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiUHJvdG9CdWZcIl0gPSBmYWN0b3J5KGdsb2JhbFtcImRjb2RlSU9cIl1bXCJCeXRlQnVmZmVyXCJdKTtcbiBcbn0pKHRoaXMsIGZ1bmN0aW9uKEJ5dGVCdWZmZXIsIGlzQ29tbW9uSlMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAvKipcbiAgICAgKiBUaGUgUHJvdG9CdWYgbmFtZXNwYWNlLlxuICAgICAqIEBleHBvcnRzIFByb3RvQnVmXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICB2YXIgUHJvdG9CdWYgPSB7fTtcbiBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKG5ldzogQnl0ZUJ1ZmZlciwgLi4uWypdKX1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuQnl0ZUJ1ZmZlciA9IEJ5dGVCdWZmZXI7XG4gXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6IExvbmcsIC4uLlsqXSl9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLkxvbmcgPSBCeXRlQnVmZmVyLkxvbmcgfHwgbnVsbDtcbiBcbiAgICAvKipcbiAgICAgKiBQcm90b0J1Zi5qcyB2ZXJzaW9uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLlZFUlNJT04gPSBcIjUuMC4xXCI7XG4gXG4gICAgLyoqXG4gICAgICogV2lyZSB0eXBlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUyA9IHt9O1xuIFxuICAgIC8qKlxuICAgICAqIFZhcmludCB3aXJlIHR5cGUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQgPSAwO1xuIFxuICAgIC8qKlxuICAgICAqIEZpeGVkIDY0IGJpdHMgd2lyZSB0eXBlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcbiBcbiAgICAvKipcbiAgICAgKiBMZW5ndGggZGVsaW1pdGVkIHdpcmUgdHlwZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSA9IDI7XG4gXG4gICAgLyoqXG4gICAgICogU3RhcnQgZ3JvdXAgd2lyZSB0eXBlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUCA9IDM7XG4gXG4gICAgLyoqXG4gICAgICogRW5kIGdyb3VwIHdpcmUgdHlwZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcbiBcbiAgICAvKipcbiAgICAgKiBGaXhlZCAzMiBiaXRzIHdpcmUgdHlwZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMiA9IDU7XG4gXG4gICAgLyoqXG4gICAgICogUGFja2FibGUgd2lyZSB0eXBlcy5cbiAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTID0gW1xuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXG4gICAgXTtcbiBcbiAgICAvKipcbiAgICAgKiBUeXBlcy5cbiAgICAgKiBAZGljdFxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcse25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlciwgZGVmYXVsdFZhbHVlOiAqfT59XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLlRZUEVTID0ge1xuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXG4gICAgICAgIFwiaW50MzJcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwidWludDMyXCI6IHtcbiAgICAgICAgICAgIG5hbWU6IFwidWludDMyXCIsXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJzaW50MzJcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgICAgICB9LFxuICAgICAgICBcImludDY0XCI6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiaW50NjRcIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBcInVpbnQ2NFwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcInVpbnQ2NFwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5VWkVSTyA6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBcInNpbnQ2NFwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcInNpbnQ2NFwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9vbFwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcImJvb2xcIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJkb3VibGVcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgICAgICB9LFxuICAgICAgICBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYnl0ZXNcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsIC8vIG92ZXJyaWRkZW4gaW4gdGhlIGNvZGUsIG11c3QgYmUgYSB1bmlxdWUgaW5zdGFuY2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaXhlZDMyXCI6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQzMlwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwic2ZpeGVkMzJcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQzMlwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZml4ZWQ2NFwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcImZpeGVkNjRcIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogIFByb3RvQnVmLkxvbmcgPyBQcm90b0J1Zi5Mb25nLlVaRVJPIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIFwic2ZpeGVkNjRcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQ2NFwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0LFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm90b0J1Zi5Mb25nID8gUHJvdG9CdWYuTG9uZy5aRVJPIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmxvYXRcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiZW51bVwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcImVudW1cIixcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgXCJncm91cFwiOiB7XG4gICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAgICAgIH1cbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIFZhbGlkIG1hcCBrZXkgdHlwZXMuXG4gICAgICogQHR5cGUgeyFBcnJheS48IU9iamVjdC48c3RyaW5nLHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXIsIGRlZmF1bHRWYWx1ZTogKn0+Pn1cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuTUFQX0tFWV9UWVBFUyA9IFtcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXSxcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl0sXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl0sXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdLFxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl0sXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl0sXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdLFxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdLFxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXSxcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdLFxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl0sXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdLFxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdXG4gICAgXTtcbiBcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGZpZWxkIGlkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLklEX01JTiA9IDE7XG4gXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBmaWVsZCBpZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5JRF9NQVggPSAweDFGRkZGRkZGO1xuIFxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIGZpZWxkIG5hbWVzIHdpbGwgYmUgY29udmVydGVkIGZyb20gdW5kZXJzY29yZSBub3RhdGlvbiB0byBjYW1lbCBjYXNlLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqICBNdXN0IGJlIHNldCBwcmlvciB0byBwYXJzaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSBmYWxzZTtcbiBcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlcyBhcmUgcG9wdWxhdGVkIHdpdGggKHNldFgsIHNldF94KSBhY2Nlc3NvcnMgZm9yIGVhY2ggZmllbGQuIFRoaXMgY2FuIGJlIGRpc2FibGVkIGJ5XG4gICAgICogIHNldHRpbmcgdGhpcyB0byBgZmFsc2VgIHByaW9yIHRvIGJ1aWxkaW5nIG1lc3NhZ2VzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5wb3B1bGF0ZUFjY2Vzc29ycyA9IHRydWU7XG4gXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgbWVzc2FnZXMgYXJlIHBvcHVsYXRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzIGlmIGEgZmllbGQgaXMgbm90IHByZXNlbnQgb24gdGhlIHdpcmUuIFRvIGRpc2FibGVcbiAgICAgKiAgdGhpcyBiZWhhdmlvciwgc2V0IHRoaXMgc2V0dGluZyB0byBgZmFsc2VgLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5wb3B1bGF0ZURlZmF1bHRzID0gdHJ1ZTtcbiBcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuVXRpbFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5VdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3RvQnVmIHV0aWxpdGllcy5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuVXRpbFxuICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgVXRpbCA9IHt9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBpZiBydW5uaW5nIGluIG5vZGUgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFV0aWwuSVNfTk9ERSA9ICEhKFxuICAgICAgICAgICAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MrJycgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyAmJiAhcHJvY2Vzc1snYnJvd3NlciddXG4gICAgICAgICk7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE5vIGRlcGVuZGVuY2llcyBwbGVhc2UsIHJlZjogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy94bWxodHRwLmh0bWxcbiAgICAgICAgICAgIHZhciBYTUxIdHRwRmFjdG9yaWVzID0gW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKX0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/WE1MSHR0cFJlcXVlc3R9ICovXG4gICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPFhNTEh0dHBGYWN0b3JpZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIHRyeSB7IHhociA9IFhNTEh0dHBGYWN0b3JpZXNbaV0oKTsgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXhocilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhIHJlc291cmNlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBSZXNvdXJjZSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIHJlc291cmNlJ3MgY29udGVudHMuIElmIG9taXR0ZWQgdGhlIHJlc291cmNlIHdpbGxcbiAgICAgICAgICogICBiZSBmZXRjaGVkIHN5bmNocm9ub3VzbHkuIElmIHRoZSByZXF1ZXN0IGZhaWxlZCwgY29udGVudHMgd2lsbCBiZSBudWxsLlxuICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfHVuZGVmaW5lZH0gUmVzb3VyY2UgY29udGVudHMgaWYgY2FsbGJhY2sgaXMgb21pdHRlZCAobnVsbCBpZiB0aGUgcmVxdWVzdCBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZC5cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVXRpbC5mZXRjaCA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgaWYgKFV0aWwuSVNfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIrZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHhociA9IFV0aWwuWEhSKCk7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhdGgsIGNhbGxiYWNrID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyB4aHIuc2V0UmVxdWVzdEhlYWRlcignVXNlci1BZ2VudCcsICdYTUxIVFRQLzEuMCcpO1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeGhyLm92ZXJyaWRlTWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPSA0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFV0aWwudG9DYW1lbENhc2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXyhbYS16QS1aXSkvZywgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIHJldHVybiBVdGlsO1xuICAgIH0pKCk7XG4gXG4gICAgLyoqXG4gICAgICogTGFuZ3VhZ2UgZXhwcmVzc2lvbnMuXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywhUmVnRXhwPn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuTGFuZyA9IHtcbiBcbiAgICAgICAgLy8gQ2hhcmFjdGVycyBhbHdheXMgZW5kaW5nIGEgc3RhdGVtZW50XG4gICAgICAgIERFTElNOiAvW1xcc1xce1xcfT07OlxcW1xcXSwnXCJcXChcXCk8Pl0vZyxcbiBcbiAgICAgICAgLy8gRmllbGQgcnVsZXNcbiAgICAgICAgUlVMRTogL14oPzpyZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZHxtYXApJC8sXG4gXG4gICAgICAgIC8vIEZpZWxkIHR5cGVzXG4gICAgICAgIFRZUEU6IC9eKD86ZG91YmxlfGZsb2F0fGludDMyfHVpbnQzMnxzaW50MzJ8aW50NjR8dWludDY0fHNpbnQ2NHxmaXhlZDMyfHNmaXhlZDMyfGZpeGVkNjR8c2ZpeGVkNjR8Ym9vbHxzdHJpbmd8Ynl0ZXMpJC8sXG4gXG4gICAgICAgIC8vIE5hbWVzXG4gICAgICAgIE5BTUU6IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvLFxuIFxuICAgICAgICAvLyBUeXBlIGRlZmluaXRpb25zXG4gICAgICAgIFRZUEVERUY6IC9eW2EtekEtWl1bYS16QS1aXzAtOV0qJC8sXG4gXG4gICAgICAgIC8vIFR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBUWVBFUkVGOiAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSskLyxcbiBcbiAgICAgICAgLy8gRnVsbHkgcXVhbGlmaWVkIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBGUVRZUEVSRUY6IC9eKD86XFwuW2EtekEtWl1bYS16QS1aXzAtOV0qKSskLyxcbiBcbiAgICAgICAgLy8gQWxsIG51bWJlcnNcbiAgICAgICAgTlVNQkVSOiAvXi0/KD86WzEtOV1bMC05XSp8MHwwW3hYXVswLTlhLWZBLUZdK3wwWzAtN10rfChbMC05XSooXFwuWzAtOV0qKT8oW0VlXVsrLV0/WzAtOV0rKT8pfGluZnxuYW4pJC8sXG4gXG4gICAgICAgIC8vIERlY2ltYWwgbnVtYmVyc1xuICAgICAgICBOVU1CRVJfREVDOiAvXig/OlsxLTldWzAtOV0qfDApJC8sXG4gXG4gICAgICAgIC8vIEhleGFkZWNpbWFsIG51bWJlcnNcbiAgICAgICAgTlVNQkVSX0hFWDogL14wW3hYXVswLTlhLWZBLUZdKyQvLFxuIFxuICAgICAgICAvLyBPY3RhbCBudW1iZXJzXG4gICAgICAgIE5VTUJFUl9PQ1Q6IC9eMFswLTddKyQvLFxuIFxuICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBudW1iZXJzXG4gICAgICAgIE5VTUJFUl9GTFQ6IC9eKFswLTldKihcXC5bMC05XSopPyhbRWVdWystXT9bMC05XSspP3xpbmZ8bmFuKSQvLFxuIFxuICAgICAgICAvLyBCb29sZWFuc1xuICAgICAgICBCT09MOiAvXig/OnRydWV8ZmFsc2UpJC9pLFxuIFxuICAgICAgICAvLyBJZCBudW1iZXJzXG4gICAgICAgIElEOiAvXig/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddKykkLyxcbiBcbiAgICAgICAgLy8gTmVnYXRpdmUgaWQgbnVtYmVycyAoZW51bSB2YWx1ZXMpXG4gICAgICAgIE5FR0lEOiAvXlxcLT8oPzpbMS05XVswLTldKnwwfDBbeFhdWzAtOWEtZkEtRl0rfDBbMC03XSspJC8sXG4gXG4gICAgICAgIC8vIFdoaXRlc3BhY2VzXG4gICAgICAgIFdISVRFU1BBQ0U6IC9cXHMvLFxuIFxuICAgICAgICAvLyBBbGwgc3RyaW5nc1xuICAgICAgICBTVFJJTkc6IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpfCg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nLFxuIFxuICAgICAgICAvLyBEb3VibGUgcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgU1RSSU5HX0RROiAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKS9nLFxuIFxuICAgICAgICAvLyBTaW5nbGUgcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgU1RSSU5HX1NROiAvKD86JyhbXidcXFxcXSooPzpcXFxcLlteJ1xcXFxdKikqKScpL2dcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90b1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5Eb3RQcm90byA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdGllcyB0byBwYXJzZSAucHJvdG8gZmlsZXMuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvXG4gICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBEb3RQcm90byA9IHt9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUb2tlbml6ZXIuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxuICAgICAgICAgKiBAY2xhc3MgcHJvdG90eXBlIHRva2VuaXplclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gUHJvdG8gdG8gdG9rZW5pemVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgVG9rZW5pemVyID0gZnVuY3Rpb24ocHJvdG8pIHtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU291cmNlIHRvIHBhcnNlLlxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBwcm90bytcIlwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDdXJyZW50IGluZGV4LlxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEN1cnJlbnQgbGluZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubGluZSA9IDE7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRva2VuIHN0YWNrLlxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGVuaW5nIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBzdHJpbmcgcmVhZCwgaWYgYW55LlxuICAgICAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9zdHJpbmdPcGVuID0gbnVsbDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFRva2VuaXplclByb3RvdHlwZSA9IFRva2VuaXplci5wcm90b3R5cGU7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIHN0cmluZyBiZWdpbm5pbmcgYXQgdGhlIGN1cnJlbnQgaW5kZXguXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5fcmVhZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlID0gdGhpcy5fc3RyaW5nT3BlbiA9PT0gJ1wiJ1xuICAgICAgICAgICAgICAgID8gTGFuZy5TVFJJTkdfRFFcbiAgICAgICAgICAgICAgICA6IExhbmcuU1RSSU5HX1NRO1xuICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gdGhpcy5pbmRleCAtIDE7IC8vIEluY2x1ZGUgdGhlIG9wZW4gcXVvdGVcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWModGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVudGVybWluYXRlZCBzdHJpbmdcIik7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuX3N0cmluZ09wZW4pO1xuICAgICAgICAgICAgdGhpcy5fc3RyaW5nT3BlbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBuZXh0IHRva2VuIGFuZCBhZHZhbmNlcyBieSBvbmUuXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJpbmdPcGVuICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3RyaW5nKCk7XG4gXG4gICAgICAgICAgICB2YXIgcmVwZWF0LFxuICAgICAgICAgICAgICAgIHByZXYsXG4gICAgICAgICAgICAgICAgbmV4dDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiBcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCB3aGl0ZSBzcGFjZXNcbiAgICAgICAgICAgICAgICB3aGlsZSAoTGFuZy5XSElURVNQQUNFLnRlc3QobmV4dCA9IHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBjb21tZW50c1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykgeyAvLyBMaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5zb3VyY2UuY2hhckF0KCsrdGhpcy5pbmRleCkgIT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09IHRoaXMuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG5leHQgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpID09PSAnKicpIHsgLyogQmxvY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXYgIT09ICcqJyB8fCBuZXh0ICE9PSAnLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XG4gXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuIFxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB0b2tlblxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBMYW5nLkRFTElNLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgZGVsaW0gPSBMYW5nLkRFTElNLnRlc3QodGhpcy5zb3VyY2UuY2hhckF0KGVuZCsrKSk7XG4gICAgICAgICAgICBpZiAoIWRlbGltKVxuICAgICAgICAgICAgICAgIHdoaWxlKGVuZCA8IHRoaXMuc291cmNlLmxlbmd0aCAmJiAhTGFuZy5ERUxJTS50ZXN0KHRoaXMuc291cmNlLmNoYXJBdChlbmQpKSlcbiAgICAgICAgICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnNvdXJjZS5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCA9IGVuZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdcIicgfHwgdG9rZW4gPT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmluZ09wZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgICogQHJldHVybiB7P3N0cmluZ30gVG9rZW4gb3IgYG51bGxgIG9uIEVPRlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUb2tlbml6ZXJQcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbMF07XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTa2lwcyBhIHNwZWNpZmljIHRva2VuIGFuZCB0aHJvd3MgaWYgaXQgZGlmZmVycy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYWN0dWFsIHRva2VuIGRpZmZlcnNcbiAgICAgICAgICovXG4gICAgICAgIFRva2VuaXplclByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWwgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCAnXCIrYWN0dWFsK1wiJywgJ1wiK2V4cGVjdGVkK1wiJyBleHBlY3RlZFwiKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9taXRzIGFuIG9wdGlvbmFsIHRva2VuLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgb3B0aW9uYWwgdG9rZW5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdG9rZW4gZXhpc3RzXG4gICAgICAgICAqL1xuICAgICAgICBUb2tlbml6ZXJQcm90b3R5cGUub21pdCA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIlRva2VuaXplcihpbmRleC9sZW5ndGgpXCJcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVG9rZW5pemVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUb2tlbml6ZXIgKFwiK3RoaXMuaW5kZXgrXCIvXCIrdGhpcy5zb3VyY2UubGVuZ3RoK1wiIGF0IGxpbmUgXCIrdGhpcy5saW5lK1wiKVwiO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBEb3RQcm90by5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFBhcnNlci5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyXG4gICAgICAgICAqIEBjbGFzcyBwcm90b3R5cGUgcGFyc2VyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUb2tlbml6ZXIuXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplcn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50biA9IG5ldyBUb2tlbml6ZXIoc291cmNlKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciBwYXJzaW5nIHByb3RvMyBvciBub3QuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wcm90bzMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFBhcnNlclByb3RvdHlwZSA9IFBhcnNlci5wcm90b3R5cGU7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgdGhlIHNvdXJjZS5cbiAgICAgICAgICogQHJldHVybnMgeyFPYmplY3R9XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdG9wTGV2ZWwgPSB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiW1JPT1RdXCIsIC8vIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgIFwicGFja2FnZVwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJlbnVtc1wiOiBbXSxcbiAgICAgICAgICAgICAgICBcImltcG9ydHNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwic2VydmljZXNcIjogW11cbiAgICAgICAgICAgICAgICAvLyBcInN5bnRheFwiOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICAgICAgaGVhZCA9IHRydWUsXG4gICAgICAgICAgICAgICAgd2VhaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRva2VuID0gdGhpcy50bi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkIHx8IHRvcExldmVsW1wicGFja2FnZVwiXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bmV4cGVjdGVkICdwYWNrYWdlJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcGFja2FnZSBuYW1lOiBcIiArIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsW1wicGFja2FnZVwiXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5leHBlY3RlZCAnaW1wb3J0J1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJwdWJsaWNcIiB8fCAod2VhayA9IHRva2VuID09PSBcIndlYWtcIikpIC8vIHRva2VuIGlnbm9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9yZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspIC8vIGltcG9ydCBpZ25vcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsW1wiaW1wb3J0c1wiXS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bnRheCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgJ3N5bnRheCdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvcExldmVsW1wic3ludGF4XCJdID0gdGhpcy5fcmVhZFN0cmluZygpKSA9PT0gXCJwcm90bzNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90bzMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UodG9wTGV2ZWwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bSh0b3BMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbih0b3BMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXJ2aWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2UodG9wTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXh0ZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV4dGVuZCh0b3BMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidW5leHBlY3RlZCAnXCIgKyB0b2tlbiArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIlBhcnNlIGVycm9yIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRvcExldmVsW1wibmFtZVwiXTtcbiAgICAgICAgICAgIHJldHVybiB0b3BMZXZlbDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyB0aGUgc3BlY2lmaWVkIHNvdXJjZS5cbiAgICAgICAgICogQHJldHVybnMgeyFPYmplY3R9XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihzb3VyY2UpLnBhcnNlKCk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8vIC0tLS0tIENvbnZlcnNpb24gLS0tLS0tXG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIG51bWVyaWNhbCBzdHJpbmcgdG8gYW4gaWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtYXlCZU5lZ2F0aXZlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWtJZCh2YWx1ZSwgbWF5QmVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gLTEsXG4gICAgICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09ICctJykge1xuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUl9ERUMudGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9IRVgudGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX09DVC50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgOCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGlkIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbHVlKTtcbiAgICAgICAgICAgIGlkID0gKHNpZ24qaWQpfDA7IC8vIEZvcmNlIHRvIDMyYml0XG4gICAgICAgICAgICBpZiAoIW1heUJlTmVnYXRpdmUgJiYgaWQgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBpZCB2YWx1ZTogXCIgKyAoc2lnbiA8IDAgPyAnLScgOiAnJykgKyB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgbnVtZXJpY2FsIHN0cmluZyB0byBhIG51bWJlci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1rTnVtYmVyKHZhbCkge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICAgICAgaWYgKHZhbC5jaGFyQXQoMCkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVJfREVDLnRlc3QodmFsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX09DVC50ZXN0KHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ2luZicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBJbmZpbml0eTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gJ25hbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0ZMVC50ZXN0KHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbnVtYmVyIHZhbHVlOiBcIiArIChzaWduIDwgMCA/ICctJyA6ICcnKSArIHZhbCk7XG4gICAgICAgIH1cbiBcbiAgICAgICAgLy8gLS0tLS0gUmVhZGluZyAtLS0tLS1cbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGEgc3RyaW5nLlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGRlbGltO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGRlbGltID0gdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltICE9PSBcIidcIiAmJiBkZWxpbSAhPT0gJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHN0cmluZyBkZWxpbWl0ZXI6IFwiK2RlbGltKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoZGVsaW0pO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbiA9PT0gJ1wiJyB8fCB0b2tlbiA9PT0gJ1wiJyk7IC8vIG11bHRpIGxpbmU/XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBhIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtYXlCZVR5cGVSZWZcbiAgICAgICAgICogQHJldHVybnMge251bWJlcnxib29sZWFufHN0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcmVhZFZhbHVlID0gZnVuY3Rpb24obWF5QmVUeXBlUmVmKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1wiJyB8fCB0b2tlbiA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiBta051bWJlcih0b2tlbik7XG4gICAgICAgICAgICBpZiAoTGFuZy5CT09MLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiAodG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGlmIChtYXlCZVR5cGVSZWYgJiYgTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB2YWx1ZTogXCIrdG9rZW4pO1xuIFxuICAgICAgICB9O1xuIFxuICAgICAgICAvLyAtLS0tLSBQYXJzaW5nIGNvbnN0cnVjdHMgLS0tLS1cbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIG5hbWVzcGFjZSBvcHRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzTGlzdFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZU9wdGlvbiA9IGZ1bmN0aW9uKHBhcmVudCwgaXNMaXN0KSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKSxcbiAgICAgICAgICAgICAgICBjdXN0b20gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGFsbG93IG9wdGlvbnMgb2YgdGhlIGZvcm0gZ29vZ2xlLnByb3RvYnVmLiogc2luY2UgdGhleSB3aWxsIGp1c3QgZ2V0IGlnbm9yZWQgYW55d2F5c1xuICAgICAgICAgICAgICAgIC8vIGlmICghL2dvb2dsZVxcLnByb3RvYnVmXFwuLy50ZXN0KHRva2VuKSkgLy8gRklYTUU6IFdoeSBzaG91bGQgdGhhdCBub3QgYmUgYSB2YWxpZCB0eXBlcmVmP1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb3B0aW9uIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICAgICAgICBpZiAoY3VzdG9tKSB7IC8vIChteV9tZXRob2Rfb3B0aW9uKS5mb28sIChteV9tZXRob2Rfb3B0aW9uKSwgc29tZV9tZXRob2Rfb3B0aW9uLCAoZm9vLm15X29wdGlvbikuYmFyXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKCcpJyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICcoJytuYW1lKycpJztcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xuICAgICAgICAgICAgICAgIGlmIChMYW5nLkZRVFlQRVJFRi50ZXN0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoJz0nKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNMaXN0KVxuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGFuIG9wdGlvbiBvbiB0aGUgc3BlY2lmaWVkIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWVcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb24ob3B0aW9ucywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnNbbmFtZV0pKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gWyBvcHRpb25zW25hbWVdIF07XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFuIG9wdGlvbiB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09ICd7JykgeyAvLyBQbGFpbiB2YWx1ZVxuICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnRbXCJvcHRpb25zXCJdLCBuYW1lLCB0aGlzLl9yZWFkVmFsdWUodHJ1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gQWdncmVnYXRlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvcHRpb24gbmFtZTogXCIgKyBuYW1lICsgXCIuXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRuLm9taXQoXCI6XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudFtcIm9wdGlvbnNcIl0sIG5hbWUgKyBcIi5cIiArIHRva2VuLCB0aGlzLl9yZWFkVmFsdWUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHNlcnZpY2UgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VTZXJ2aWNlID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBzZXJ2aWNlIG5hbWUgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICAgICAgICB2YXIgc3ZjID0ge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBuYW1lLFxuICAgICAgICAgICAgICAgIFwicnBjXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKHN2Yyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdycGMnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2VSUEMoc3ZjKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBzZXJ2aWNlIHRva2VuOiBcIit0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xuICAgICAgICAgICAgcGFyZW50W1wic2VydmljZXNcIl0ucHVzaChzdmMpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgUlBDIHNlcnZpY2UgZGVmaW5pdGlvbiBvZiB0aGUgZm9ybSBbJ3JwYycsIG5hbWUsIChyZXF1ZXN0KSwgJ3JldHVybnMnLCAocmVzcG9uc2UpXS5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBzdmMgU2VydmljZSBkZWZpbml0aW9uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlU2VydmljZVJQQyA9IGZ1bmN0aW9uKHN2Yykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBcInJwY1wiLFxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcnBjIHNlcnZpY2UgbWV0aG9kIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0ge1xuICAgICAgICAgICAgICAgIFwicmVxdWVzdFwiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2VcIjogbnVsbCxcbiAgICAgICAgICAgICAgICBcInJlcXVlc3Rfc3RyZWFtXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwicmVzcG9uc2Vfc3RyZWFtXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIihcIik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgICAgICAgbWV0aG9kW1wicmVxdWVzdF9zdHJlYW1cIl0gPSB0cnVlO1xuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIHJlcXVlc3QgdHlwZTogXCIrdG9rZW4pO1xuICAgICAgICAgICAgbWV0aG9kW1wicmVxdWVzdFwiXSA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiKVwiKTtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udG9Mb3dlckNhc2UoKSAhPT0gXCJyZXR1cm5zXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHJwYyBzZXJ2aWNlIHJlcXVlc3QgdHlwZSBkZWxpbWl0ZXI6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIihcIik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgICAgICAgbWV0aG9kW1wicmVzcG9uc2Vfc3RyZWFtXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGhvZFtcInJlc3BvbnNlXCJdID0gdG9rZW47XG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCIpXCIpO1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ29wdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgcnBjIHNlcnZpY2UgdG9rZW46IFwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiO1wiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ZjW3R5cGVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBzdmNbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIHN2Y1t0eXBlXVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0PX0gZmxkIEZpZWxkIGRlZmluaXRpb24gaWYgdGhpcyBpcyBhIGdyb3VwXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihwYXJlbnQsIGZsZCkge1xuICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSAhIWZsZCxcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImZpZWxkc1wiOiBbXSxcbiAgICAgICAgICAgICAgICBcImVudW1zXCI6IFtdLFxuICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwic2VydmljZXNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJvbmVvZnNcIjoge31cbiAgICAgICAgICAgICAgICAvLyBcImV4dGVuc2lvbnNcIjogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIFwiKyhpc0dyb3VwID8gXCJncm91cFwiIDogXCJtZXNzYWdlXCIpK1wiIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIG1zZ1tcIm5hbWVcIl0gPSB0b2tlbjtcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcbiAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IG1rSWQodGhpcy50bi5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIG1zZ1tcImlzR3JvdXBcIl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ1snICYmIGZsZClcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9ucyhmbGQpO1xuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09ICd9Jykge1xuICAgICAgICAgICAgICAgIGlmIChMYW5nLlJVTEUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKG1zZywgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9uZW9mXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZU9uZU9mKG1zZyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZW51bVwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0obXNnKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJtZXNzYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtc2cpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcInNlcnZpY2VcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlKG1zZyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZXh0ZW5zaW9uc1wiKVxuICAgICAgICAgICAgICAgICAgICBpZiAobXNnLmhhc093blByb3BlcnR5KFwiZXh0ZW5zaW9uc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IG1zZ1tcImV4dGVuc2lvbnNcIl0uY29uY2F0KHRoaXMuX3BhcnNlRXh0ZW5zaW9uUmFuZ2VzKCkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2dbXCJleHRlbnNpb25zXCJdID0gdGhpcy5fcGFyc2VFeHRlbnNpb25SYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcInJlc2VydmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlSWdub3JlZCgpOyAvLyBUT0RPXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZXh0ZW5kXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXh0ZW5kKG1zZyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZmllbGQgcnVsZTogXCIrdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChtc2csIFwib3B0aW9uYWxcIiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSB0b2tlbjogXCIrdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcbiAgICAgICAgICAgIHBhcmVudFtcIm1lc3NhZ2VzXCJdLnB1c2gobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYW4gaWdub3JlZCBzdGF0ZW1lbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlSWdub3JlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG4ucGVlaygpICE9PSAnOycpXG4gICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBmaWVsZC5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIEZpZWxkIHJ1bGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEZpZWxkIHR5cGUgaWYgYWxyZWFkeSBrbm93biAobmV2ZXIga25vd24gZm9yIG1hcHMpXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBGaWVsZCBkZXNjcmlwdG9yXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBQYXJzZXJQcm90b3R5cGUuX3BhcnNlTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24obXNnLCBydWxlLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoIUxhbmcuUlVMRS50ZXN0KHJ1bGUpKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIHJ1bGU6IFwiK3J1bGUpO1xuICAgICAgICAgICAgdmFyIGZsZCA9IHtcbiAgICAgICAgICAgICAgICBcInJ1bGVcIjogcnVsZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgaWYgKHJ1bGUgPT09IFwibWFwXCIpIHtcbiBcbiAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKCc8Jyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZCB0eXBlOiBcIiArIHRva2VuKTtcbiAgICAgICAgICAgICAgICBmbGRbXCJrZXl0eXBlXCJdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKCcsJyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgbWVzc2FnZSBmaWVsZDogXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcCgnPicpO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBtZXNzYWdlIGZpZWxkIG5hbWU6IFwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI9XCIpO1xuICAgICAgICAgICAgICAgIGZsZFtcImlkXCJdID0gbWtJZCh0aGlzLnRuLm5leHQoKSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09ICdbJylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMoZmxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xuIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiBcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHR5cGUgIT09ICd1bmRlZmluZWQnID8gdHlwZSA6IHRoaXMudG4ubmV4dCgpO1xuIFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImdyb3VwXCIpIHtcbiBcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBIFtsZWdhY3ldIGdyb3VwIHNpbXBseSBjb21iaW5lcyBhIG5lc3RlZCBtZXNzYWdlIHR5cGUgYW5kIGEgZmllbGQgaW50byBhIHNpbmdsZSBkZWNsYXJhdGlvbi4gSW4geW91clxuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlLCB5b3UgY2FuIHRyZWF0IHRoaXMgbWVzc2FnZSBqdXN0IGFzIGlmIGl0IGhhZCBhIFJlc3VsdCB0eXBlIGZpZWxkIGNhbGxlZCByZXN1bHQgKHRoZSBsYXR0ZXIgbmFtZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gbG93ZXItY2FzZSBzbyB0aGF0IGl0IGRvZXMgbm90IGNvbmZsaWN0IHdpdGggdGhlIGZvcm1lcikuXCJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdycCA9IHRoaXMuX3BhcnNlTWVzc2FnZShtc2csIGZsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghL15bQS1aXS8udGVzdChncnBbXCJuYW1lXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdpbGxlZ2FsIGdyb3VwIG5hbWU6ICcrZ3JwW1wibmFtZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIGZsZFtcInR5cGVcIl0gPSBncnBbXCJuYW1lXCJdO1xuICAgICAgICAgICAgICAgICAgICBmbGRbXCJuYW1lXCJdID0gZ3JwW1wibmFtZVwiXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xuIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodHlwZSkgJiYgIUxhbmcuVFlQRVJFRi50ZXN0KHR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG1lc3NhZ2UgZmllbGQgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG1lc3NhZ2UgZmllbGQgbmFtZTogXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgZmxkW1wiaWRcIl0gPSBta0lkKHRoaXMudG4ubmV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIltcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGZsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIjtcIik7XG4gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnW1wiZmllbGRzXCJdLnB1c2goZmxkKTtcbiAgICAgICAgICAgIHJldHVybiBmbGQ7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBtZXNzYWdlIG9uZW9mLlxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VNZXNzYWdlT25lT2YgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9uZW9mIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW4sXG4gICAgICAgICAgICAgICAgZmxkO1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50bi5za2lwKFwie1wiKTtcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkgIT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgZmxkID0gdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCBcIm9wdGlvbmFsXCIsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBmbGRbXCJvbmVvZlwiXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmxkW1wiaWRcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50bi5vbWl0KFwiO1wiKTtcbiAgICAgICAgICAgIG1zZ1tcIm9uZW9mc1wiXVtuYW1lXSA9IGZpZWxkcztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHNldCBvZiBmaWVsZCBvcHRpb24gZGVmaW5pdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZmxkIEZpZWxkIGRlZmluaXRpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VGaWVsZE9wdGlvbnMgPSBmdW5jdGlvbihmbGQpIHtcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIltcIik7XG4gICAgICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ucGVlaygpKSAhPT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihmbGQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhbiBlbnVtLlxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VFbnVtID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICB2YXIgZW5tID0ge1xuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IFtdLFxuICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIGVubVtcIm5hbWVcIl0gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMudG4uc2tpcChcIntcIik7XG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gdGhpcy50bi5uZXh0KCkpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGVubSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG5hbWU6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5za2lwKFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogbWtJZCh0aGlzLnRuLm5leHQoKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIltcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKHsgXCJvcHRpb25zXCI6IHt9IH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbm1bXCJ2YWx1ZXNcIl0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG4ub21pdChcIjtcIik7XG4gICAgICAgICAgICBtc2dbXCJlbnVtc1wiXS5wdXNoKGVubSk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgZXh0ZW5zaW9uIC8gcmVzZXJ2ZWQgcmFuZ2VzLlxuICAgICAgICAgKiBAcmV0dXJucyB7IUFycmF5LjwhQXJyYXkuPG51bWJlcj4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgUGFyc2VyUHJvdG90eXBlLl9wYXJzZUV4dGVuc2lvblJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gUHJvdG9CdWYuSURfTUlOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gUHJvdG9CdWYuSURfTUFYO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1rTnVtYmVyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50bi5wZWVrKCkgIT09IFwidG9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy50bi5vbWl0KFwiLFwiKSk7XG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCI7XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhbiBleHRlbmQgYmxvY2suXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50IFBhcmVudCBvYmplY3RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS5fcGFyc2VFeHRlbmQgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGV4dGVuZCByZWZlcmVuY2U6IFwiK3Rva2VuKTtcbiAgICAgICAgICAgIHZhciBleHQgPSB7XG4gICAgICAgICAgICAgICAgXCJyZWZcIjogdG9rZW4sXG4gICAgICAgICAgICAgICAgXCJmaWVsZHNcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnRuLnNraXAoXCJ7XCIpO1xuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSAhPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQoZXh0LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm90bzMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZmllbGQgcnVsZTogXCIrdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChleHQsIFwib3B0aW9uYWxcIiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgZXh0ZW5kIHRva2VuOiBcIit0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRuLm9taXQoXCI7XCIpO1xuICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLy8gLS0tLS0gR2VuZXJhbCAtLS0tLVxuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBhcnNlci5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIFBhcnNlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUGFyc2VyIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBEb3RQcm90by5QYXJzZXIgPSBQYXJzZXI7XG4gXG4gICAgICAgIHJldHVybiBEb3RQcm90bztcbiBcbiAgICB9KShQcm90b0J1ZiwgUHJvdG9CdWYuTGFuZyk7XG4gXG4gICAgLyoqXG4gICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYuUmVmbGVjdCA9IChmdW5jdGlvbihQcm90b0J1Zikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZXMuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3RcbiAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFJlZmxlY3QgPSB7fTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBSZWZsZWN0IGJhc2UgY2xhc3MuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuVFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcbiAgICAgICAgICogQHBhcmFtIHs/UHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFQgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUpIHtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnVpbGRlciByZWZlcmVuY2UuXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLkJ1aWxkZXJ9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcmVudCBvYmplY3QuXG4gICAgICAgICAgICAgKiBAdHlwZSB7P1Byb3RvQnVmLlJlZmxlY3QuVH1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9iamVjdCBuYW1lIGluIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlQucHJvdG90eXBlXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFRQcm90b3R5cGUgPSBULnByb3RvdHlwZTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGdWxseSBxdWFsaWZpZWQgbmFtZSBhcyBvZiBcIi5QQVRILlRPLlRISVNcIlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUUHJvdG90eXBlLmZxbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChwdHIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHB0ci5uYW1lK1wiLlwiK25hbWU7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFJlZmxlY3Qgb2JqZWN0IChpdHMgZnVsbHkgcXVhbGlmaWVkIG5hbWUpLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlQ2xhc3MgU2V0IHRvIHRydWUgdG8gaW5jbHVkZSB0aGUgY2xhc3MgbmFtZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5jbHVkZUNsYXNzID8gdGhpcy5jbGFzc05hbWUgKyBcIiBcIiA6IFwiXCIpICsgdGhpcy5mcW4oKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyB0aGlzIHR5cGUuXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGlzIHR5cGUgY2Fubm90IGJlIGJ1aWx0IGRpcmVjdGx5XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMudG9TdHJpbmcodHJ1ZSkrXCIgY2Fubm90IGJlIGJ1aWx0IGRpcmVjdGx5XCIpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuVFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0LlQgPSBUO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBOYW1lc3BhY2UuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcbiAgICAgICAgICogQHBhcmFtIHs/UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IHBhcmVudCBOYW1lc3BhY2UgcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE5hbWVzcGFjZSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHBhcmVudCwgbmFtZSk7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTmFtZXNwYWNlXCI7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoaWxkcmVuIGluc2lkZSB0aGUgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN5bnRheCBsZXZlbCAoZS5nLiwgcHJvdG8yIG9yIHByb3RvMykuXG4gICAgICAgICAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXggfHwgXCJwcm90bzJcIjtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZS5wcm90b3R5cGVcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgTmFtZXNwYWNlUHJvdG90eXBlID0gTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXNwYWNlJ3MgY2hpbGRyZW4uXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UPX0gdHlwZSBGaWx0ZXIgdHlwZSAocmV0dXJucyBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIG9ubHkpLiBEZWZhdWx0cyB0byBudWxsIChhbGwgY2hpbGRyZW4pLlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIG5hbWVzcGFjZS5cbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR9IGNoaWxkIENoaWxkXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY2hpbGQgY2Fubm90IGJlIGFkZGVkIChkdXBsaWNhdGUpXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXI7XG4gICAgICAgICAgICBpZiAob3RoZXIgPSB0aGlzLmdldENoaWxkKGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBvdGhlci5uYW1lICE9PSBvdGhlci5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChvdGhlci5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBvdGhlci5uYW1lID0gb3RoZXIub3JpZ2luYWxOYW1lOyAvLyBSZXZlcnQgcHJldmlvdXMgZmlyc3QgKGVmZmVjdGl2ZWx5IGtlZXBzIGJvdGggb3JpZ2luYWxzKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChjaGlsZC5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5uYW1lID0gY2hpbGQub3JpZ2luYWxOYW1lO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgbmFtZSBpbiBuYW1lc3BhY2UgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIGNoaWxkIGJ5IGl0cyBuYW1lIG9yIGlkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPcklkIENoaWxkIG5hbWUgb3IgaWRcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gVGhlIGNoaWxkIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdHlwZW9mIG5hbWVPcklkID09PSAnbnVtYmVyJyA/ICdpZCcgOiAnbmFtZSc7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGk8azsgKytpKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT09IG5hbWVPcklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZXMgYSByZWZsZWN0IG9iamVjdCBpbnNpZGUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48c3RyaW5nPn0gcW4gUXVhbGlmaWVkIG5hbWUgdG8gcmVzb2x2ZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBUaGUgcmVzb2x2ZWQgdHlwZSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHFuLCBleGNsdWRlTm9uTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHR5cGVvZiBxbiA9PT0gJ3N0cmluZycgPyBxbi5zcGxpdChcIi5cIikgOiBxbixcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgaWYgKHBhcnRbaV0gPT09IFwiXCIpIHsgLy8gRnVsbHkgcXVhbGlmaWVkIG5hbWUsIGUuZy4gXCIuTXkuTWVzc2FnZSdcbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHB0ci5nZXRDaGlsZChwYXJ0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCB8fCAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5UKSB8fCAoZXhjbHVkZU5vbk5hbWVzcGFjZSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IGNoaWxkOyBpKys7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IHBhcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAocHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBGb3VuZFxuICAgICAgICAgICAgICAgIC8vIEVsc2Ugc2VhcmNoIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZXNvbHZlKHFuLCBleGNsdWRlTm9uTmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHB0ciAhPSBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBzaG9ydGVzdCBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIGlmIGFueSwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVH0gdCBSZWZsZWN0aW9uIHR5cGVcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNob3J0ZXN0IHF1YWxpZmllZCBuYW1lIG9yLCBpZiB0aGVyZSBpcyBub25lLCB0aGUgZnFuXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5xbiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gW10sIHB0ciA9IHQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcGFydC51bnNoaWZ0KHB0ci5uYW1lKTtcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9PSBudWxsKTtcbiAgICAgICAgICAgIGZvciAodmFyIGxlbj0xOyBsZW4gPD0gcGFydC5sZW5ndGg7IGxlbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHFuID0gcGFydC5zbGljZShwYXJ0Lmxlbmd0aC1sZW4pO1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSB0aGlzLnJlc29sdmUocW4sIHQgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxbi5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LmZxbigpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGRzIHRoZSBuYW1lc3BhY2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLEZ1bmN0aW9ufE9iamVjdD59IFJ1bnRpbWUgbmFtZXNwYWNlXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLyoqIEBkaWN0ICovXG4gICAgICAgICAgICB2YXIgbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9Y2hpbGRyZW4ubGVuZ3RoLCBjaGlsZDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgbnNbY2hpbGQubmFtZV0gPSBjaGlsZC5idWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IHRoaXMuYnVpbGRPcHQoKSB9KTtcbiAgICAgICAgICAgIHJldHVybiBucztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XG4gICAgICAgICAqL1xuICAgICAgICBOYW1lc3BhY2VQcm90b3R5cGUuYnVpbGRPcHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB7fSxcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1rZXlzLmxlbmd0aDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IE9wdGlvbnMgYXJlIG5vdCByZXNvbHZlZCwgeWV0LlxuICAgICAgICAgICAgICAgIC8vIGlmICh2YWwgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgb3B0W2tleV0gPSB2YWwuYnVpbGQoKTtcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHQ7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgb3B0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUmV0dXJucyB0aGUgb3B0aW9uIHZhbHVlIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGFsbCBvcHRpb25zIGFyZSByZXR1cm5lZC5cbiAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5vcHRpb25zW25hbWVdICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3B0aW9uc1tuYW1lXSA6IG51bGw7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdC5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEVsZW1lbnQgaW1wbGVtZW50YXRpb24gdGhhdCBjaGVja3MgYW5kIGNvbnZlcnRzIHZhbHVlcyBmb3IgYVxuICAgICAgICAgKiBwYXJ0aWN1bGFyIGZpZWxkIHR5cGUsIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbiBFbGVtZW50IHJlcHJlc2VudHMgYSBzaW5nbGUgdmFsdWU6IGVpdGhlciB0aGUgdmFsdWUgb2YgYSBzaW5ndWxhciBmaWVsZCxcbiAgICAgICAgICogb3IgYSB2YWx1ZSBjb250YWluZWQgaW4gb25lIGVudHJ5IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwIGZpZWxkLiBUaGlzXG4gICAgICAgICAqIGNsYXNzIGRvZXMgbm90IGltcGxlbWVudCB0aGVzZSBoaWdoZXItbGV2ZWwgY29uY2VwdHM7IGl0IG9ubHkgZW5jYXBzdWxhdGVzXG4gICAgICAgICAqIHRoZSBsb3ctbGV2ZWwgdHlwZWNoZWNraW5nIGFuZCBjb252ZXJzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gdHlwZSBSZXNvbHZlZCBkYXRhIHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH0gcmVzb2x2ZWRUeXBlIFJlc29sdmVkIHR5cGUsIGlmIHJlbGV2YW50XG4gICAgICAgICAqIChlLmcuIHN1Ym1lc3NhZ2UgZmllbGQpLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFwS2V5IElzIHRoaXMgZWxlbWVudCBhIE1hcCBrZXk/IFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICAgICAqIGNvbnZlcnRlZCB0byBzdHJpbmcgZm9ybSBpZiBzby5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bnRheCBTeW50YXggbGV2ZWwgb2YgZGVmaW5pbmcgbWVzc2FnZSB0eXBlLCBlLmcuLFxuICAgICAgICAgKiBwcm90bzIgb3IgcHJvdG8zLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoaXMgZWxlbWVudCAoZm9yIGVycm9yXG4gICAgICAgICAqIG1lc3NhZ2VzKVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgcmVzb2x2ZWRUeXBlLCBpc01hcEtleSwgc3ludGF4LCBuYW1lKSB7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVsZW1lbnQgdHlwZSwgYXMgYSBzdHJpbmcgKGUuZy4sIGludDMyKS5cbiAgICAgICAgICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRWxlbWVudCB0eXBlIHJlZmVyZW5jZSB0byBzdWJtZXNzYWdlIG9yIGVudW0gZGVmaW5pdGlvbiwgaWYgbmVlZGVkLlxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVHxudWxsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IHJlc29sdmVkVHlwZTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRWxlbWVudCBpcyBhIG1hcCBrZXkuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc01hcEtleSA9IGlzTWFwS2V5O1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTeW50YXggbGV2ZWwgb2YgZGVmaW5pbmcgbWVzc2FnZSB0eXBlLCBlLmcuLCBwcm90bzIgb3IgcHJvdG8zLlxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXg7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgdGhpcyBlbGVtZW50IChmb3IgZXJyb3IgbWVzc2FnZXMpXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuIFxuICAgICAgICAgICAgaWYgKGlzTWFwS2V5ICYmIFByb3RvQnVmLk1BUF9LRVlfVFlQRVMuaW5kZXhPZih0eXBlKSA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIG1hcCBrZXkgdHlwZTogXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICB9O1xuIFxuICAgICAgICB2YXIgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogT2J0YWlucyBhIChuZXcpIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gRmllbGQgdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gRGVmYXVsdCB2YWx1ZVxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1rRGVmYXVsdCh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBQcm90b0J1Zi5UWVBFU1t0eXBlXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS5kZWZhdWx0VmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZGVmYXVsdCB2YWx1ZSBmb3IgdHlwZSBcIit0eXBlLm5hbWUrXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKDApO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIGZpZWxkIGluIHByb3RvMy5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19IHRoZSBmaWVsZCB0eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBEZWZhdWx0IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlID0gbWtEZWZhdWx0O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYSBMb25nIGZyb20gYSB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byByZXVzZSBpdCBmcm9tIExvbmctbGlrZSBvYmplY3RzIG9yIHRvIHNpZ25lZCBmb3JcbiAgICAgICAgICogIHN0cmluZ3MgYW5kIG51bWJlcnNcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBMb25nXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWtMb25nKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sb3cgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5oaWdoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudW5zaWduZWQgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5Mb25nKHZhbHVlLmxvdywgdmFsdWUuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAndW5kZWZpbmVkJyA/IHZhbHVlLnVuc2lnbmVkIDogdW5zaWduZWQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5Mb25nLmZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkIHx8IGZhbHNlKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XG4gICAgICAgIH1cbiBcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgfHwgJycpICsgKHRoaXMuaXNNYXBLZXkgPyAnbWFwJyA6ICd2YWx1ZScpICsgJyBlbGVtZW50JztcbiAgICAgICAgfVxuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2V0IGZvciBhbiBlbGVtZW50IG9mIHRoaXMgdHlwZSAoc2luZ3VsYXJcbiAgICAgICAgICogZmllbGQgb3Igb25lIGVsZW1lbnQgb2YgYSByZXBlYXRlZCBmaWVsZCBvciBtYXApLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZlcmlmaWVkLCBtYXliZSBhZGp1c3RlZCwgdmFsdWVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgdmVyaWZpZWQgZm9yIHRoaXMgZWxlbWVudCBzbG90XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUudmVyaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCh2YWwsIG1zZykge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrc2VsZi50b1N0cmluZyh0cnVlKStcIiBvZiB0eXBlIFwiK3NlbGYudHlwZS5uYW1lK1wiOiBcIit2YWwrXCIgKFwiK21zZytcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25lZCAzMmJpdFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XG4gXG4gICAgICAgICAgICAgICAgLy8gVW5zaWduZWQgMzJiaXRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAodmFsdWUgPT09IHZhbHVlICYmIHZhbHVlICUgMSAhPT0gMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IHZhbHVlID4+PiAwIDogdmFsdWU7XG4gXG4gICAgICAgICAgICAgICAgLy8gU2lnbmVkIDY0Yml0XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWtMb25nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDY0Yml0XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXToge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIC8vIEJvb2xcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgYm9vbGVhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuIFxuICAgICAgICAgICAgICAgIC8vIEZsb2F0XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIrdmFsdWU7IC8vIENvbnZlcnQgU3RyaW5nIG9iamVjdCB0byBzdHJpbmdcbiBcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci53cmFwKHZhbHVlLCBcImJhc2U2NFwiKTtcbiBcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzb2x2ZWRUeXBlLmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0ubmFtZSA9PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzW2ldLmlkID09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XG4gXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvMzoganVzdCBtYWtlIHN1cmUgaXQncyBhbiBpbnRlZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gNDI5NDk2NzI5NSB8fCB2YWx1ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGluIHJhbmdlIGZvciB1aW50MzJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvMiByZXF1aXJlcyBlbnVtIHZhbHVlcyB0byBiZSB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodmFsdWUsIFwibm90IGEgdmFsaWQgZW51bSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlzbWF0Y2hlZCB0eXBlOiBDb252ZXJ0IHRvIG9iamVjdCAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy9pc3N1ZXMvMTgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtpXSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBsZXQncyB0cnkgdG8gY29uc3RydWN0IG9uZSBmcm9tIGEga2V5LXZhbHVlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0aGlzLnJlc29sdmVkVHlwZS5jbGF6eikodmFsdWUpOyAvLyBNYXkgdGhyb3cgZm9yIGEgaHVuZHJlZCBvZiByZWFzb25zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVuZGVmaW5lZCB0eXBlIFwiK3RoaXMudHlwZStcIilcIik7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbGVtZW50IG9uIHRoZSB3aXJlLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgRmllbGQgbnVtYmVyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgY2FsY3VsYXRlZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmNhbGN1bGF0ZUxlbmd0aCA9IGZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gMDsgLy8gTm90aGluZyB0byBlbmNvZGVcbiAgICAgICAgICAgIC8vIFRhZyBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW5cbiAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKSA6IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxuICAgICAgICAgICAgICAgICAgICBuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVtYWluaW5nKCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKSArIHZhbHVlLnJlbWFpbmluZygpO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobikgKyBuO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuICsgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgdG8gZW5jb2RlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmtub3duIHR5cGUpXCIpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEZpZWxkIG51bWJlclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBlbmNvZGVkXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbihpZCwgdmFsdWUsIGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gYnVmZmVyOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxuICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxuIFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICAvLyBcIklmIHlvdSB1c2UgaW50MzIgb3IgaW50NjQgYXMgdGhlIHR5cGUgZm9yIGEgbmVnYXRpdmUgbnVtYmVyLCB0aGUgcmVzdWx0aW5nIHZhcmludCBpcyBhbHdheXMgdGVuIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmcg4oCTIGl0IGlzLCBlZmZlY3RpdmVseSwgdHJlYXRlZCBsaWtlIGEgdmVyeSBsYXJnZSB1bnNpZ25lZCBpbnRlZ2VyLlwiIChzZWUgIzEyMilcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCB1bnNpZ25lZCB2YXJpbnRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuIFxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHZhcmludCB6aWctemFnXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzJaaWdaYWcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCB1bnNpZ25lZCAzMmJpdFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCBzaWduZWQgMzJiaXRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgdmFyaW50IGFzLWlzXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0KHZhbHVlKTsgLy8gdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuIFxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHZhcmludCB6aWctemFnXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjRaaWdaYWcodmFsdWUpOyAvLyB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgdW5zaWduZWQgNjRiaXRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVWludDY0KHZhbHVlKTsgLy8gdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuIFxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCA2NGJpdFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlSW50NjQodmFsdWUpOyAvLyB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gXG4gICAgICAgICAgICAgICAgLy8gQm9vbFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScgPyAwIDogISF2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgZmxvYXRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0MzIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0NjQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVtYWluaW5nKCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2T2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS5yZW1haW5pbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUuZW5jb2RlKHZhbHVlLCBiYik7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGJiLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gXG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IGdyb3VwXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZS5lbmNvZGUodmFsdWUsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKChpZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiBcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgdG8gZW5jb2RlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmtub3duIHR5cGUpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZSBvbmUgZWxlbWVudCB2YWx1ZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBUaGUgZmllbGQgd2lyZSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBUaGUgZmllbGQgbnVtYmVyXG4gICAgICAgICAqIEByZXR1cm4geyp9IERlY29kZWQgdmFsdWVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWVsZCBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgd2lyZVR5cGUsIGlkKSB7XG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgIT0gdGhpcy50eXBlLndpcmVUeXBlKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB3aXJlIHR5cGUgZm9yIGVsZW1lbnRcIik7XG4gXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSB8IDA7XG4gXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgdW5zaWduZWQgdmFyaW50XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSA+Pj4gMDtcbiBcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMlppZ1phZygpIHwgMDtcbiBcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCAzMmJpdCB1bnNpZ25lZFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVaW50MzIoKSA+Pj4gMDtcbiBcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDMyKCkgfCAwO1xuIFxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHNpZ25lZCB2YXJpbnRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0KCk7XG4gXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgdW5zaWduZWQgdmFyaW50XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKS50b1Vuc2lnbmVkKCk7XG4gXG4gICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjRaaWdaYWcoKTtcbiBcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCA2NGJpdCB1bnNpZ25lZFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVaW50NjQoKTtcbiBcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCA2NGJpdCBzaWduZWRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDY0KCk7XG4gXG4gICAgICAgICAgICAgICAgLy8gQm9vbCB2YXJpbnRcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xuIFxuICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IGVudW0gdmFsdWUgKHZhcmludClcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBCdWlsZGVyLk1lc3NhZ2Ujc2V0IHdpbGwgYWxyZWFkeSB0aHJvd1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xuIFxuICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRGbG9hdCgpO1xuIFxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IGZsb2F0XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlKCk7XG4gXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWU3RyaW5nKCk7XG4gXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXToge1xuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBuQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLmNsb25lKCk7IC8vIE9mZnNldCBhbHJlYWR5IHNldFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5saW1pdCA9IHZhbHVlLm9mZnNldCtuQnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgZW1iZWRkZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIG5CeXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIC0xLCBpZCk7XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIGRlY29kZSB0eXBlXCIpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIGEgc3RyaW5nIHRvIHRoZSBjYW5vbmljYWwgZWxlbWVudCB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBMZWdhbCBvbmx5IHdoZW4gaXNNYXBLZXkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUudmFsdWVGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInZhbHVlRnJvbVN0cmluZygpIGNhbGxlZCBvbiBub24tbWFwLWtleSBlbGVtZW50XCIpO1xuICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5VmFsdWUocGFyc2VJbnQoc3RyKSk7XG4gXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XG4gICAgICAgICAgICAgICAgICAgICAgLy8gTG9uZy1iYXNlZCBmaWVsZHMgc3VwcG9ydCBjb252ZXJzaW9ucyBmcm9tIHN0cmluZyBhbHJlYWR5LlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVZhbHVlKHN0cik7XG4gXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gXCJ0cnVlXCI7XG4gXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShzdHIpO1xuIFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHZhbHVlIGZyb20gdGhlIGNhbm9uaWNhbCBlbGVtZW50IHR5cGUgdG8gYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHNob3VsZCBiZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZUZyb21TdHJpbmcodmFsdWVUb1N0cmluZyh2YWwpKWAgcmV0dXJuc1xuICAgICAgICAgKiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gYHZlcmlmeVZhbHVlKHZhbClgIGZvciBldmVyeSBsZWdhbCB2YWx1ZSBvZiBgdmFsYFxuICAgICAgICAgKiBhY2NvcmRpbmcgdG8gdGhpcyBlbGVtZW50IHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWF5IGJlIHVzZWQgd2hlbiB0aGUgZWxlbWVudCBtdXN0IGJlIHN0b3JlZCBvciB1c2VkIGFzIGEgc3RyaW5nLFxuICAgICAgICAgKiBlLmcuLCBhcyBhIG1hcCBrZXkgb24gYW4gT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBMZWdhbCBvbmx5IHdoZW4gaXNNYXBLZXkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFwS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ2YWx1ZVRvU3RyaW5nKCkgY2FsbGVkIG9uIG5vbi1tYXAta2V5IGVsZW1lbnRcIik7XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVsZW1lbnRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdC5FbGVtZW50ID0gRWxlbWVudDtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZS5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IHBhcmVudCBQYXJlbnQgbWVzc2FnZSBvciBuYW1lc3BhY2VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWVzc2FnZSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0dyb3VwIGB0cnVlYCBpZiB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXAsIHN5bnRheCkge1xuICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lLCBvcHRpb25zLCBzeW50YXgpO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2VcIjtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXh0ZW5zaW9ucyByYW5nZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJ1bnRpbWUgbWVzc2FnZSBjbGFzcy5cbiAgICAgICAgICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24obmV3OlByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSl9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNHcm91cCA9ICEhaXNHcm91cDtcbiBcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2FjaGVkIGNvbGxlY3Rpb25zIGFyZSB1c2VkIHRvIGVmZmljaWVudGx5IGl0ZXJhdGUgb3ZlciBvciBsb29rIHVwIGZpZWxkcyB3aGVuIGRlY29kaW5nLlxuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzLlxuICAgICAgICAgICAgICogQHR5cGUgez9BcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IGlkLlxuICAgICAgICAgICAgICogQHR5cGUgez9PYmplY3QuPG51bWJlciwhUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkPn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IG5hbWUuXG4gICAgICAgICAgICAgKiBAdHlwZSB7P09iamVjdC48c3RyaW5nLCFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQ+fVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lID0gbnVsbDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIE1lc3NhZ2VQcm90b3R5cGUgPSBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZHMgdGhlIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQsIHdoaWNoIGlzIGEgZnVsbHkgZnVuY3Rpb25hbCBjbGFzcy5cbiAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IE1lc3NhZ2UgY2xhc3NcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocmVidWlsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xheno7XG4gXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJ1bnRpbWUgTWVzc2FnZSBjbGFzcyBpbiBpdHMgb3duIHNjb3BlXG4gICAgICAgICAgICB2YXIgY2xhenogPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFQpIHtcbiBcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gVC5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvbmVvZnMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZik7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBydW50aW1lIE1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXG4gICAgICAgICAgICAgICAgICogQGNsYXNzIEJhcmVib25lIG9mIGFsbCBydW50aW1lIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fHN0cmluZ30gdmFsdWVzIFByZXNldCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFyX2FyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmNhbGwodGhpcyk7XG4gXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPW9uZW9mcy5sZW5ndGg7IGk8azsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvbmVvZnNbaV0ubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzIGFuZCBzZXQgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTAsIGs9ZmllbGRzLmxlbmd0aDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnJlcGVhdGVkID8gW10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZC5tYXAgPyBuZXcgUHJvdG9CdWYuTWFwKGZpZWxkKSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmaWVsZC5yZXF1aXJlZCB8fCBULnN5bnRheCA9PT0gJ3Byb3RvMycpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXMgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgX2Fub3RoZXJfIE1lc3NhZ2UgKi8gKHR5cGVvZiB2YWx1ZXMuZW5jb2RlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlcyBpbnN0YW5jZW9mIE1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgcmVwZWF0ZWQgZmllbGQgKi8gIUFycmF5LmlzQXJyYXkodmFsdWVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhIE1hcCAqLyAhKHZhbHVlcyBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBCeXRlQnVmZmVyICovICFCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih2YWx1ZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgTG9uZyAqLyAhKFByb3RvQnVmLkxvbmcgJiYgdmFsdWVzIGluc3RhbmNlb2YgUHJvdG9CdWYuTG9uZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYXJndW1lbnRzLCBpbiBkZWNsYXJhdGlvbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wLCBrPWFyZ3VtZW50cy5sZW5ndGg7IGk8azsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSA9IGFyZ3VtZW50c1tpXSkgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCB2YWx1ZSk7IC8vIE1heSB0aHJvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAqIEBpbm5lclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlUHJvdG90eXBlID0gTWVzc2FnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5wcm90b3R5cGUpO1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNhZGRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGFkZFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7IC8vIE1heSB0aHJvdyBpZiBpdCdzIGFuIGVudW0gb3IgZW1iZWRkZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5yZXBlYXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSByZXBlYXRlZCBmaWVsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2tleV0gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZH0uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRhZGRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGFkZFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuJGFkZCA9IE1lc3NhZ2VQcm90b3R5cGUuYWRkO1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoKnxib29sZWFuKT19IHZhbHVlIFZhbHVlIHRvIHNldCBpZiBrZXkgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBvbWl0dGVkXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQgLyBwcm9wZXIgdmFsdWUgdHlwZSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5T3JPYmosIHZhbHVlLCBub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5T3JPYmogJiYgdHlwZW9mIGtleU9yT2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9Bc3NlcnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlrZXkgaW4ga2V5T3JPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleU9yT2JqLmhhc093blByb3BlcnR5KGlrZXkpICYmIHR5cGVvZiAodmFsdWUgPSBrZXlPck9ialtpa2V5XSkgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoaWtleSwgdmFsdWUsIG5vQXNzZXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuX2ZpZWxkc0J5TmFtZVtrZXlPck9ial07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXlPck9iaitcIiBpcyBub3QgYSBmaWVsZDogdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5T3JPYmorXCIgaXMgbm90IGEgZmllbGQ6IFwiK2ZpZWxkLnRvU3RyaW5nKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSAodmFsdWUgPSBmaWVsZC52ZXJpZnlWYWx1ZSh2YWx1ZSkpOyAvLyBNYXkgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleU9yT2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQub25lb2YpIHsgLy8gRmllbGQgaXMgcGFydCBvZiBhbiBPbmVPZiAobm90IGEgdmlydHVhbCBPbmVPZiBmaWVsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdOyAvLyBWaXJ0dWFsIGZpZWxkIHJlZmVyZW5jZXMgY3VycmVudGx5IHNldCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCAhPT0gbnVsbCAmJiBjdXJyZW50RmllbGQgIT09IGZpZWxkLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gZmllbGQubmFtZTsgLy8gUG9pbnQgdmlydHVhbCBmaWVsZCBhdCB0aGlzIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC8qIHZhbHVlID09PSBudWxsICYmICovY3VycmVudEZpZWxkID09PSBrZXlPck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gbnVsbDsgLy8gQ2xlYXIgdmlydHVhbCBmaWVsZCAoY3VycmVudCBmaWVsZCBleHBsaWNpdGx5IGNsZWFyZWQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBmb3IgW0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXR9LlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkc2V0XG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IU9iamVjdC48c3RyaW5nLCo+fSBrZXlPck9iaiBTdHJpbmcga2V5IG9yIHBsYWluIG9iamVjdCBob2xkaW5nIG11bHRpcGxlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCp8Ym9vbGVhbik9fSB2YWx1ZSBWYWx1ZSB0byBzZXQgaWYga2V5IGlzIGEgc3RyaW5nLCBvdGhlcndpc2Ugb21pdHRlZFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS4kc2V0ID0gTWVzc2FnZVByb3RvdHlwZS5zZXQ7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZVxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9Bc3NlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRnZXRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZmllbGRcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS4kZ2V0ID0gTWVzc2FnZVByb3RvdHlwZS5nZXQ7XG4gXG4gICAgICAgICAgICAgICAgLy8gR2V0dGVycyBhbmQgc2V0dGVyc1xuIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBzZXR0ZXJzIGZvciBleHRlbnNpb24gZmllbGRzIGFzIHRoZXNlIGFyZSBuYW1lZCBieSB0aGVpciBmcW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gXG4gICAgICAgICAgICAgICAgICAgIGlmIChULmJ1aWxkZXIub3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldC9nZXRbU29tZVZhbHVlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhfW2EtekEtWl0pL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJ18nLCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lID0gTmFtZS5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgTmFtZS5zdWJzdHJpbmcoMSk7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV0gRklYTUU6IERvIHdlIHJlYWxseSBuZWVkIHRoZXNlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX1wiK21hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IGZpZWxkJ3MgdW5ib3VuZCBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHZhbHVlLCBub0Fzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBmaWVsZCdzIHVuYm91bmQgZ2V0dGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcInNldFwiK05hbWUpID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIGFub3RoZXIgZmllbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRbU29tZUZpZWxkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IHRoZSB2YWx1ZSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wic2V0XCIrTmFtZV0gPSBzZXR0ZXI7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFQuZ2V0Q2hpbGQoXCJzZXRfXCIrbmFtZSkgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldF9bc29tZV9maWVsZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZVtcInNldF9cIituYW1lXSA9IHNldHRlcjtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcImdldFwiK05hbWUpID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIGFub3RoZXIgZmllbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRbU29tZUZpZWxkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZVtcImdldFwiK05hbWVdID0gZ2V0dGVyO1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwiZ2V0X1wiK25hbWUpID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIGFub3RoZXIgZmllbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRfW3NvbWVfZmllbGRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wiZ2V0X1wiK25hbWVdID0gZ2V0dGVyO1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICAvLyBFbi0vZGVjb2RpbmdcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkZW5jb2RlXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnl0ZUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIGEgQnl0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XG4gICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlSGV4XG4gICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlQUJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbm9WZXJpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVmVyaWZ5ID0gYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVC5lbmNvZGUodGhpcywgYnVmZmVyLkxFKCksIG5vVmVyaWZ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOZXcgPyBidWZmZXIuZmxpcCgpIDogYnVmZmVyKS5MRShsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHNwZWNpZmllZCBkYXRhIHBheWxvYWQuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj59IGRhdGEgRGF0YSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnl0ZUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIGEgQnl0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uKGRhdGEsIGJ1ZmZlciwgbm9WZXJpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGRhdGEpLmVuY29kZShidWZmZXIsIG5vVmVyaWZ5KTtcbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY2FsY3VsYXRlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHZhcmludDMyIGxlbmd0aC1kZWxpbWl0ZWQgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnl0ZUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIGEgQnl0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5jID0gbmV3IEJ5dGVCdWZmZXIoKS5MRSgpO1xuICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBlbmMsIG5vVmVyaWZ5KS5mbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGVuYy5yZW1haW5pbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoZW5jKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERpcmVjdGx5IGVuY29kZXMgdGhlIG1lc3NhZ2UgdG8gYW4gQXJyYXlCdWZmZXIuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZUFCID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0FycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlQUI7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVOQlxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkLCBub3QgcnVubmluZyB1bmRlciBub2RlLmpzIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcbiAgICAgICAgICAgICAgICAgKiAgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgbm9kZSBCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSgpLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgYXMgYSBub2RlIEJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVOQn0uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQnVmZmVyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ1ZmZlcn1cbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkI7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlNjRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdW5kZXJseWluZyBidWZmZXIgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXJcbiAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0Jhc2U2NCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9CYXNlNjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0fS5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CYXNlNjRcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIGJhc2U2NCBzdHJpbmcgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUudG9CYXNlNjQgPSBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERpcmVjdGx5IGVuY29kZXMgdGhlIG1lc3NhZ2UgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleFxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxuICAgICAgICAgICAgICAgICAqICBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIGhleCBzdHJpbmcgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9IZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvSGV4XG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBoZXggc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvSGV4ID0gTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVIZXg7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3Qgb3IgZmllbGQgdmFsdWUgdG8gYSByYXcgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byBjbG9uZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmluYXJ5QXNCYXNlNjQgV2hldGhlciB0byBpbmNsdWRlIGJpbmFyeSBkYXRhIGFzIGJhc2U2NCBzdHJpbmdzIG9yIGFzIGEgYnVmZmVyIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVD19IHJlc29sdmVkVHlwZSBUaGUgcmVzb2x2ZWQgZmllbGQgdHlwZSBpZiBhIGZpZWxkXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IENsb25lZCBvYmplY3RcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbG9uZVJhdyhvYmosIGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncywgcmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZW51bSB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBuYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkVHlwZSAmJiByZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LkVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFByb3RvQnVmLlJlZmxlY3QuRW51bS5nZXROYW1lKHJlc29sdmVkVHlwZS5vYmplY3QsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcy10aHJvdWdoIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBudWxsLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgQnl0ZUJ1ZmZlcnMgdG8gcmF3IGJ1ZmZlciBvciBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcihvYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeUFzQmFzZTY0ID8gb2JqLnRvQmFzZTY0KCkgOiBvYmoudG9CdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBMb25ncyB0byBwcm9wZXIgb2JqZWN0cyBvciBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nLmlzTG9uZyhvYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdzQXNTdHJpbmdzID8gb2JqLnRvU3RyaW5nKCkgOiBQcm90b0J1Zi5Mb25nLmZyb21WYWx1ZShvYmopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvbmU7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsb25lIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2tdID0gY2xvbmVSYXcodiwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzLCByZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBtYXBzIHRvIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ID0gb2JqLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSBpdC5uZXh0KCk7ICFlLmRvbmU7IGUgPSBpdC5uZXh0KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbb2JqLmtleUVsZW0udmFsdWVUb1N0cmluZyhlLnZhbHVlWzBdKV0gPSBjbG9uZVJhdyhlLnZhbHVlWzFdLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIG9iai52YWx1ZUVsZW0ucmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBvYmouJHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgJiYgKGZpZWxkID0gdHlwZS5nZXRDaGlsZChpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIGZpZWxkLnJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IGNsb25lUmF3KG9ialtpXSwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlJ3MgcmF3IHBheWxvYWQuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gYmluYXJ5QXNCYXNlNjQgV2hldGhlciB0byBpbmNsdWRlIGJpbmFyeSBkYXRhIGFzIGJhc2U2NCBzdHJpbmdzIGluc3RlYWQgb2YgQnVmZmVycywgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSYXcodGhpcywgISFiaW5hcnlBc0Jhc2U2NCwgISFsb25nc0FzU3RyaW5ncywgdGhpcy4kdHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZSB0byBKU09OLlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEpTT04gc3RyaW5nXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVJhdyh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBiaW5hcnktYXMtYmFzZTY0ICovIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxvbmdzLWFzLXN0cmluZ3MgKi8gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBvciBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZVxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFCdWZmZXJ8c3RyaW5nfSBidWZmZXIgQnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyk9fSBsZW5ndGggTWVzc2FnZSBsZW5ndGguIERlZmF1bHRzIHRvIGRlY29kZSBhbGwgdGhlIHJlbWFpbmlnIGRhdGEuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbGVuZ3RoLCBlbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIsIGVuYyA/IGVuYyA6IFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlID0gYnVmZmVyLmxpdHRsZUVuZGlhbjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuTEUoKSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBvciBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFCdWZmZXJ8c3RyaW5nfSBidWZmZXIgQnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlIG9yIGBudWxsYCBpZiBub3QgZW5vdWdoIGJ5dGVzIGFyZSBhdmFpbGFibGUgeWV0XG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIsIGVuYyA/IGVuYyA6IFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5yZW1haW5pbmcoKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZiA9IGJ1ZmZlci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBidWZmZXIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFQuZGVjb2RlKGJ1ZmZlci5zbGljZShidWZmZXIub2Zmc2V0LCBidWZmZXIub2Zmc2V0ICsgbGVuKS5MRSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGU2NFxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZTY0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgaGV4IGVuY29kZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGVIZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2UuZGVjb2RlKHN0ciwgXCJoZXhcIik7XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSlNPTlxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcbiAgICAgICAgICAgICAgICAgKiBtaXNzaW5nLlxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUpTT04gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKEpTT04ucGFyc2Uoc3RyKSk7XG4gICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAvLyBVdGlsaXR5XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIE1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvU3RyaW5nXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCIuRnVsbHkuUXVhbGlmaWVkLk1lc3NhZ2VOYW1lXCJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH07XG4gXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllc1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2Ugb3B0aW9ucy5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuJG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uc1M7IC8vIGNjIG5lZWRzIHRoaXNcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNZXNzYWdlIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRvcHRpb25zXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnM7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS4kdHlwZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgJHR5cGVTO1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZS5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHR5cGVcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlO1xuIFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlLCAnJG9wdGlvbnMnLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZVByb3RvdHlwZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogTWVzc2FnZVtcIiRvcHRpb25zXCJdIH0pLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VQcm90b3R5cGUsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSk7XG4gXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2U7XG4gXG4gICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XG4gXG4gICAgICAgICAgICAvLyBTdGF0aWMgZW51bXMgYW5kIHByb3RvdHlwZWQgc3ViLW1lc3NhZ2VzIC8gY2FjaGVkIGNvbGxlY3Rpb25zXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5TmFtZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZDsgaTxrOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRW51bSB8fCBjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UgfHwgY2hpbGQgaW5zdGFuY2VvZiBTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGF6ei5oYXNPd25Qcm9wZXJ0eShjaGlsZC5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBvdmVycmlkZSBzdGF0aWMgcHJvcGVydHkgJ1wiK2NoaWxkLm5hbWUrXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICBjbGF6eltjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuRmllbGQpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmJ1aWxkKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkcy5wdXNoKGNoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZFtjaGlsZC5pZF0gPSBjaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlOYW1lW2NoaWxkLm5hbWVdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuT25lT2YpICYmICEoY2hpbGQgaW5zdGFuY2VvZiBFeHRlbnNpb24pKSAvLyBOb3QgYnVpbHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlZmxlY3QgY2hpbGQgb2YgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5jaGlsZHJlbltpXS50b1N0cmluZyh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6eiA9IGNsYXp6O1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGNvbnRlbnRzIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIHdyaXRlIHRvXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgZm9yIGFub3RoZXIgcmVhc29uXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24obWVzc2FnZSwgYnVmZmVyLCBub1ZlcmlmeSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkTWlzc2luZyA9IG51bGwsXG4gICAgICAgICAgICAgICAgZmllbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9dGhpcy5fZmllbGRzLmxlbmd0aCwgdmFsOyBpPGs7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2VbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcXVpcmVkICYmIHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRNaXNzaW5nID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmVuY29kZShub1ZlcmlmeSA/IHZhbCA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbCksIGJ1ZmZlciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkTWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZXJyW1wiZW5jb2RlZFwiXSA9IGJ1ZmZlcjsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XG4gICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIGEgcnVudGltZSBtZXNzYWdlJ3MgYnl0ZSBsZW5ndGguXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgZm9yIGFub3RoZXIgcmVhc29uXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbj0wLCBpPTAsIGs9dGhpcy5fZmllbGRzLmxlbmd0aCwgZmllbGQsIHZhbDsgaTxrOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuX2ZpZWxkc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBtZXNzYWdlW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrZmllbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbiArPSBmaWVsZC5jYWxjdWxhdGUodmFsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2tpcHMgYWxsIGRhdGEgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGdyb3VwIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkXG4gICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IGJ1ZiBCeXRlQnVmZmVyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgYSB2YWx1ZSBhcyBiZWVuIHNraXBwZWQsIGBmYWxzZWAgaWYgdGhlIGVuZCBoYXMgYmVlbiByZWFjaGVkXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCB3YXNuJ3QgcG9zc2libGUgdG8gZmluZCB0aGUgZW5kIG9mIHRoZSBncm91cCAoYnVmZmVyIG92ZXJydW4gb3IgZW5kIHRhZyBtaXNtYXRjaClcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBza2lwVGlsbEdyb3VwRW5kKGV4cGVjdGVkSWQsIGJ1Zikge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKSwgLy8gVGhyb3dzIG9uIE9PQlxuICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNyxcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcbiAgICAgICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxuICAgICAgICAgICAgICAgICAgICBkbyB0YWcgPSBidWYucmVhZFVpbnQ4KCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGFnICYgMHg4MCkgPT09IDB4ODApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0OlxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU06XG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKTsgLy8gcmVhZHMgdGhlIHZhcmludFxuICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IHRhZzsgICAgICAgIC8vIHNraXBzIG4gYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XG4gICAgICAgICAgICAgICAgICAgIHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBleHBlY3RlZElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgR1JPVVBFTkQgYWZ0ZXIgdW5rbm93biBncm91cDogXCIraWQrXCIgKFwiK2V4cGVjdGVkSWQrXCIgZXhwZWN0ZWQpXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBpbiB1bmtub3duIGdyb3VwIFwiK2V4cGVjdGVkSWQrXCI6IFwiK3dpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHJlbWFpbmluZyBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGV4cGVjdGVkR3JvdXBFbmRJZCBFeHBlY3RlZCBHUk9VUEVORCBpZCBpZiB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbGVuZ3RoLCBleHBlY3RlZEdyb3VwRW5kSWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAtMTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbXNnID0gbmV3ICh0aGlzLmNsYXp6KSgpLFxuICAgICAgICAgICAgICAgIHRhZywgd2lyZVR5cGUsIGlkLCBmaWVsZDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgc3RhcnQrbGVuZ3RoIHx8IChsZW5ndGggPT09IC0xICYmIGJ1ZmZlci5yZW1haW5pbmcoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGFnID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNztcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSBleHBlY3RlZEdyb3VwRW5kSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgPSB0aGlzLl9maWVsZHNCeUlkW2lkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJtZXNzYWdlcyBjcmVhdGVkIGJ5IHlvdXIgbmV3IGNvZGUgY2FuIGJlIHBhcnNlZCBieSB5b3VyIG9sZCBjb2RlOiBvbGQgYmluYXJpZXMgc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGZpZWxkIHdoZW4gcGFyc2luZy5cIlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmZmVyKSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgdW5rbm93biBmaWVsZCBcIitpZCtcIiBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiI2RlY29kZTogXCIrd2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdLnB1c2goZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5dmFsID0gZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0uc2V0KGtleXZhbFswXSwga2V5dmFsWzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikgeyAvLyBGaWVsZCBpcyBwYXJ0IG9mIGFuIE9uZU9mIChub3QgYSB2aXJ0dWFsIE9uZU9mIGZpZWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWVsZCA9IG1zZ1tmaWVsZC5vbmVvZi5uYW1lXTsgLy8gVmlydHVhbCBmaWVsZCByZWZlcmVuY2VzIGN1cnJlbnRseSBzZXQgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tjdXJyZW50RmllbGRdID0gbnVsbDsgLy8gQ2xlYXIgY3VycmVudGx5IHNldCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm9uZW9mLm5hbWVdID0gZmllbGQubmFtZTsgLy8gUG9pbnQgdmlydHVhbCBmaWVsZCBhdCB0aGlzIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50IGFuZCBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkcyB0aGF0IGFyZSBub3RcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoOyBpPGs7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtc2dbZmllbGQubmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3ludGF4ID09PSBcInByb3RvM1wiKSB7IC8vIFByb3RvMyBzZXRzIGRlZmF1bHQgdmFsdWVzIGJ5IHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiOiBcIiArIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyW1wiZGVjb2RlZFwiXSA9IG1zZzsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFByb3RvQnVmLnBvcHVsYXRlRGVmYXVsdHMgJiYgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgRmllbGQuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBSdWxlLCBvbmUgb2YgcmVxdXJpZWQsIG9wdGlvbmFsLCByZXBlYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IGtleXR5cGUgS2V5IGRhdGEgdHlwZSwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBEYXRhIHR5cGUsIGUuZy4gaW50MzJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mPX0gb25lb2YgRW5jbG9zaW5nIE9uZU9mXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBGaWVsZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIHJ1bGUsIGtleXR5cGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zLCBvbmVvZiwgc3ludGF4KSB7XG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgbmFtZSk7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTWVzc2FnZS5GaWVsZFwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcXVpcmVkIGZsYWcuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT09IFwicmVxdWlyZWRcIjtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCByZXBlYXRlZCBmbGFnLlxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgbWFwIGZsYWcuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBydWxlID09PSBcIm1hcFwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIGtleSB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWZcbiAgICAgICAgICAgICAqIHR5cGUgaWYgcmVzb2x2ZWQuIFZhbGlkIG9ubHkgaWYgdGhpcy5tYXAgPT09IHRydWUsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfXxudWxsfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmtleVR5cGUgPSBrZXl0eXBlIHx8IG51bGw7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgdHlwZS4gVHlwZSByZWZlcmVuY2Ugc3RyaW5nIGlmIHVucmVzb2x2ZWQsIHByb3RvYnVmIHR5cGUgaWZcbiAgICAgICAgICAgICAqIHJlc29sdmVkLiBJbiBhIG1hcCBmaWVsZCwgdGhpcyBpcyB0aGUgdmFsdWUgdHlwZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHR5cGUgcmVmZXJlbmNlIGluc2lkZSB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmlxdWUgbWVzc2FnZSBmaWVsZCBpZC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBvcHRpb25zLlxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cbiAgICAgICAgICAgICAqIEBkaWN0XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNsb3NpbmcgT25lT2YuXG4gICAgICAgICAgICAgKiBAdHlwZSB7P1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vbmVvZiA9IG9uZW9mIHx8IG51bGw7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN5bnRheCBsZXZlbCBvZiB0aGlzIGRlZmluaXRpb24gKGUuZy4sIHByb3RvMykuXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCAncHJvdG8yJztcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3JpZ2luYWwgZmllbGQgbmFtZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOYW1lID0gdGhpcy5uYW1lOyAvLyBVc2VkIHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gbmFtaW5nIGNvbGxpc2lvbnNcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRWxlbWVudCBpbXBsZW1lbnRhdGlvbi4gQ3JlYXRlZCBpbiBidWlsZCgpIGFmdGVyIHR5cGVzIGFyZSByZXNvbHZlZC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5FbGVtZW50fVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBLZXkgZWxlbWVudCBpbXBsZW1lbnRhdGlvbiwgZm9yIG1hcCBmaWVsZHMuIENyZWF0ZWQgaW4gYnVpbGQoKSBhZnRlclxuICAgICAgICAgICAgICogdHlwZXMgYXJlIHJlc29sdmVkLlxuICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLkVsZW1lbnR9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMua2V5RWxlbWVudCA9IG51bGw7XG4gXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZpZWxkIG5hbWVzIHRvIGNhbWVsIGNhc2Ugbm90YXRpb24gaWYgdGhlIG92ZXJyaWRlIGlzIHNldFxuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRlci5vcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBNZXNzYWdlLkV4dGVuc2lvbkZpZWxkKSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBQcm90b0J1Zi5VdGlsLnRvQ2FtZWxDYXNlKHRoaXMubmFtZSk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkLnByb3RvdHlwZVxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBGaWVsZFByb3RvdHlwZSA9IEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGRzIHRoZSBmaWVsZC5cbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBuZXcgRWxlbWVudCh0aGlzLnR5cGUsIHRoaXMucmVzb2x2ZWRUeXBlLCBmYWxzZSwgdGhpcy5zeW50YXgsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXApXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcy5rZXlUeXBlLCB1bmRlZmluZWQsIHRydWUsIHRoaXMuc3ludGF4LCB0aGlzLm5hbWUpO1xuIFxuICAgICAgICAgICAgLy8gSW4gcHJvdG8zLCBmaWVsZHMgZG8gbm90IGhhdmUgZmllbGQgcHJlc2VuY2UsIGFuZCBldmVyeSBmaWVsZCBpcyBzZXQgdG9cbiAgICAgICAgICAgIC8vIGl0cyB0eXBlJ3MgZGVmYXVsdCB2YWx1ZSAoXCJcIiwgMCwgMC4wLCBvciBmYWxzZSkuXG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmICF0aGlzLnJlcGVhdGVkICYmICF0aGlzLm1hcClcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUodGhpcy50eXBlKTtcbiBcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGVmYXVsdCB2YWx1ZXMgYXJlIHByZXNlbnQgd2hlbiBleHBsaWNpdGx5IHNwZWNpZmllZFxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9uc1snZGVmYXVsdCddICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodGhpcy5vcHRpb25zWydkZWZhdWx0J10pO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2V0IGZvciB0aGlzIGZpZWxkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBSZXBlYXRlZCBXaGV0aGVyIHRvIHNraXAgdGhlIHJlcGVhdGVkIHZhbHVlIGNoZWNrIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZlcmlmaWVkLCBtYXliZSBhZGp1c3RlZCwgdmFsdWVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0IGZvciB0aGlzIGZpZWxkXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHNraXBSZXBlYXRlZCkge1xuICAgICAgICAgICAgc2tpcFJlcGVhdGVkID0gc2tpcFJlcGVhdGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCh2YWwsIG1zZykge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrc2VsZi50b1N0cmluZyh0cnVlKStcIiBvZiB0eXBlIFwiK3NlbGYudHlwZS5uYW1lK1wiOiBcIit2YWwrXCIgKFwiK21zZytcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsgLy8gTlVMTCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVkKVxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09ICdwcm90bzMnICYmIHRoaXMudHlwZSAhPT0gUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdKVxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJwcm90bzMgZmllbGQgd2l0aG91dCBmaWVsZCBwcmVzZW5jZSBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBSZXBlYXRlZCB2YWx1ZXMgYXMgYXJyYXlzXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5lbGVtZW50LnZlcmlmeVZhbHVlKHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hcCAmJiAhc2tpcFJlcGVhdGVkKSB7IC8vIE1hcCB2YWx1ZXMgYXMgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhIE1hcCwgYXR0ZW1wdCB0byBjb252ZXJ0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkIFByb3RvQnVmLk1hcCBvciByYXcgb2JqZWN0IGZvciBtYXAgZmllbGRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5NYXAodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGwgbm9uLXJlcGVhdGVkIGZpZWxkcyBleHBlY3Qgbm8gYXJyYXlcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXBlYXRlZCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJubyBhcnJheSBleHBlY3RlZFwiKTtcbiBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmVyaWZ5VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaWVsZCB3aWxsIGhhdmUgYSBwcmVzZW5jZSBvbiB0aGUgd2lyZSBnaXZlbiBpdHNcbiAgICAgICAgICogdmFsdWUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmVyaWZpZWQgZmllbGQgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaWVsZCB3aWxsIGJlIHByZXNlbnQgb24gdGhlIHdpcmVcbiAgICAgICAgICovXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmhhc1dpcmVQcmVzZW5jZSA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zeW50YXggIT09ICdwcm90bzMnKVxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25lb2YgJiYgbWVzc2FnZVt0aGlzLm9uZW9mLm5hbWVdID09PSB0aGlzLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDA7XG4gXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sb3cgIT09IDAgfHwgdmFsdWUuaGlnaCAhPT0gMDtcbiBcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuIFxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAuMDtcbiBcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMDtcbiBcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZW1haW5pbmcoKSA+IDA7XG4gXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcbiBcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIGZpZWxkIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZlcmlmaWVkIGZpZWxkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcbiAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGVuY29kZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgRmllbGRQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGJ1ZmZlciwgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7IC8vIE9wdGlvbmFsIG9taXR0ZWRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwiT25seSByZXBlYXRlZCBmaWVsZHMgb2YgcHJpbWl0aXZlIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsIG9yIDY0LWJpdCB3aXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgJ3BhY2tlZCcuXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIkFsbCBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGZpZWxkIGFyZSBwYWNrZWQgaW50byBhIHNpbmdsZSBrZXktdmFsdWUgcGFpciB3aXRoIHdpcmUgdHlwZSAyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobGVuZ3RoLWRlbGltaXRlZCkuIEVhY2ggZWxlbWVudCBpcyBlbmNvZGVkIHRoZSBzYW1lIHdheSBpdCB3b3VsZCBiZSBub3JtYWxseSwgZXhjZXB0IHdpdGhvdXQgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFnIHByZWNlZGluZyBpdC5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZW5zdXJlQ2FwYWNpdHkoYnVmZmVyLm9mZnNldCArPSAxKTsgLy8gV2UgZG8gbm90IGtub3cgdGhlIGxlbmd0aCB5ZXQsIHNvIGxldCdzIGFzc3VtZSBhIHZhcmludCBvZiBsZW5ndGggMVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldDsgLy8gUmVtZW1iZXIgd2hlcmUgdGhlIGNvbnRlbnRzIGJlZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWVbaV0sIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLm9mZnNldC1zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpbnRMZW4gPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaW50TGVuID4gMSkgeyAvLyBXZSBuZWVkIHRvIG1vdmUgdGhlIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKHN0YXJ0LCBidWZmZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArPSB2YXJpbnRMZW4tMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChjb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihsZW4sIHN0YXJ0LXZhcmludExlbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIklmIHlvdXIgbWVzc2FnZSBkZWZpbml0aW9uIGhhcyByZXBlYXRlZCBlbGVtZW50cyAod2l0aG91dCB0aGUgW3BhY2tlZD10cnVlXSBvcHRpb24pLCB0aGUgZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBoYXMgemVybyBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aXRoIHRoZSBzYW1lIHRhZyBudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSh0aGlzLmlkLCB2YWx1ZVtpXSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgb3V0IGVhY2ggbWFwIGVudHJ5IGFzIGEgc3VibWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2YWwsIGtleSwgbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdWJtZXNzYWdlIChrZXksIHZhbCkgcGFpci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDEsIGtleSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDIsIHZhbCk7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJtZXNzYWdlIHdpdGggd2lyZSB0eXBlIG9mIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGxlbmd0aCk7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIGtleSBhbmQgdmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmVuY29kZVZhbHVlKDEsIGtleSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCgyIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSgyLCB2YWwsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1dpcmVQcmVzZW5jZSh2YWx1ZSwgbWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5lbmNvZGVWYWx1ZSh0aGlzLmlkLCB2YWx1ZSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBmaWVsZCdzIHZhbHVlIG9uIHRoZSBuZXR3b3JrIGxldmVsLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2VcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgRmllbGRQcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBPcHRpb25hbCBvbWl0dGVkXG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBuaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSArPSB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKHRoaXMuaWQsIHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IG5pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgodGhpcy5pZCwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIG1hcCBlbnRyeSBiZWNvbWVzIGEgc3VibWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbih2YWwsIGtleSwgbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdWJtZXNzYWdlIChrZXksIHZhbCkgcGFpci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDEgPDwgMykgfCB0aGlzLmtleVR5cGUud2lyZVR5cGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDEsIGtleSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDIsIHZhbCk7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXaXJlUHJlc2VuY2UodmFsdWUsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKHRoaXMuaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIHRoZSBmaWVsZCB2YWx1ZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgTGVhZGluZyB3aXJlIHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUmVwZWF0ZWQgV2hldGhlciB0byBza2lwIHRoZSByZXBlYXRlZCBjaGVjayBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKiBAcmV0dXJuIHsqfSBEZWNvZGVkIHZhbHVlOiBhcnJheSBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcywgW2tleSwgdmFsdWVdIGZvclxuICAgICAgICAgKiAgICAgICAgICAgICBtYXAgZmllbGRzLCBvciBhbiBpbmRpdmlkdWFsIHZhbHVlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWVsZCBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBGaWVsZFByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbih3aXJlVHlwZSwgYnVmZmVyLCBza2lwUmVwZWF0ZWQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbkJ5dGVzO1xuIFxuICAgICAgICAgICAgLy8gV2UgZXhwZWN0IHdpcmVUeXBlIHRvIG1hdGNoIHRoZSB1bmRlcmx5aW5nIHR5cGUncyB3aXJlVHlwZSB1bmxlc3Mgd2Ugc2VlXG4gICAgICAgICAgICAvLyBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZCwgb3IgdW5sZXNzIHRoaXMgaXMgYSBtYXAgZmllbGQuXG4gICAgICAgICAgICB2YXIgd2lyZVR5cGVPSyA9XG4gICAgICAgICAgICAgICAgKCF0aGlzLm1hcCAmJiB3aXJlVHlwZSA9PSB0aGlzLnR5cGUud2lyZVR5cGUpIHx8XG4gICAgICAgICAgICAgICAgKCFza2lwUmVwZWF0ZWQgJiYgdGhpcy5yZXBlYXRlZCAmJiB0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiZcbiAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPT0gUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMubWFwICYmIHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcbiAgICAgICAgICAgIGlmICghd2lyZVR5cGVPSylcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgd2lyZSB0eXBlIGZvciBmaWVsZCBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit3aXJlVHlwZStcIiAoXCIrdGhpcy50eXBlLndpcmVUeXBlK1wiIGV4cGVjdGVkKVwiKTtcbiBcbiAgICAgICAgICAgIC8vIEhhbmRsZSBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzLlxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNICYmIHRoaXMucmVwZWF0ZWQgJiYgdGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBSZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5vZmZzZXQgKyBuQnl0ZXM7IC8vIExpbWl0XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5vZmZzZXQgPCBuQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmRlY29kZSh0aGlzLnR5cGUud2lyZVR5cGUsIGJ1ZmZlciwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHZhbHVlIG90aGVyd2lzZS4uLlxuICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgLy8gSGFuZGxlIG1hcHMuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFkIG9uZSAoa2V5LCB2YWx1ZSkgc3VibWVzc2FnZSwgYW5kIHJldHVybiBba2V5LCB2YWx1ZV1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLmtleVR5cGUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLnR5cGUpO1xuIFxuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGxlbmd0aFxuICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XG4gXG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgc3ViLWJ1ZmZlciBvZiB0aGlzIGtleS92YWx1ZSBzdWJtZXNzYWdlXG4gICAgICAgICAgICAgICAgdmFyIG1zZ2J1ZiA9IGJ1ZmZlci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG1zZ2J1Zi5saW1pdCA9IG1zZ2J1Zi5vZmZzZXQgKyBuQnl0ZXM7XG4gICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBuQnl0ZXM7XG4gXG4gICAgICAgICAgICAgICAgd2hpbGUgKG1zZ2J1Zi5yZW1haW5pbmcoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG1zZ2J1Zi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB0YWcgPj4+IDM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlFbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgdGFnIGluIG1hcCBmaWVsZCBrZXkvdmFsdWUgc3VibWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgLy8gSGFuZGxlIHNpbmd1bGFyIGFuZCBub24tcGFja2VkIHJlcGVhdGVkIGZpZWxkIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZGVjb2RlKGJ1ZmZlciwgd2lyZVR5cGUsIHRoaXMuaWQpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQgPSBGaWVsZDtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBFeHRlbnNpb25GaWVsZC5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEV4dGVuc2lvbkZpZWxkID0gZnVuY3Rpb24oYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEZpZWxkLmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgLyoga2V5dHlwZSA9ICovIG51bGwsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXh0ZW5zaW9uIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb259XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvLyBFeHRlbmRzIEZpZWxkXG4gICAgICAgIEV4dGVuc2lvbkZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmllbGQucHJvdG90eXBlKTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkID0gRXh0ZW5zaW9uRmllbGQ7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgT25lT2YuXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZlxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVPZiBuYW1lXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBPbmVPZiA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBtZXNzYWdlLCBuYW1lKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jbG9zZWQgZmllbGRzLlxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZD59XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5PbmVPZiA9IE9uZU9mO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgUmVmbGVjdCBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIEVudW0gb3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIChlLmcuLCBwcm90bzMpXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEVudW0gPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xuICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lLCBvcHRpb25zLCBzeW50YXgpO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIkVudW1cIjtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUnVudGltZSBlbnVtIG9iamVjdC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fG51bGx9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyBuYW1lIG9mIGFuIGVudW0gdmFsdWUuXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuRW51bX0gZW5tIFJ1bnRpbWUgZW51bVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgRW51bSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7P3N0cmluZ30gTmFtZSBvciBgbnVsbGAgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgRW51bS5nZXROYW1lID0gZnVuY3Rpb24oZW5tLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbm0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrZXk7IGk8a2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAoZW5tW2tleSA9IGtleXNbaV1dID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5wcm90b3R5cGVcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgRW51bVByb3RvdHlwZSA9IEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyB0aGlzIGVudW0gYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdC48c3RyaW5nLG51bWJlcj59XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEVudW1Qcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmplY3QgJiYgIXJlYnVpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0O1xuICAgICAgICAgICAgdmFyIGVubSA9IG5ldyBQcm90b0J1Zi5CdWlsZGVyLkVudW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLmdldENoaWxkcmVuKEVudW0uVmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXZhbHVlcy5sZW5ndGg7IGk8azsgKytpKVxuICAgICAgICAgICAgICAgIGVubVt2YWx1ZXNbaV1bJ25hbWUnXV0gPSB2YWx1ZXNbaV1bJ2lkJ107XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbm0sICckb3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0aGlzLmJ1aWxkT3B0KCksXG4gICAgICAgICAgICAgICAgICAgIFwiZW51bWVyYWJsZVwiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID0gZW5tO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0LkVudW0gPSBFbnVtO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtIFZhbHVlLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWVcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkVudW19IGVubSBFbnVtIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFZhbHVlID0gZnVuY3Rpb24oYnVpbGRlciwgZW5tLCBuYW1lLCBpZCkge1xuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIGVubSwgbmFtZSk7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bS5WYWx1ZVwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmlxdWUgZW51bSB2YWx1ZSBpZC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLy8gRXh0ZW5kcyBUXG4gICAgICAgIFZhbHVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0LkVudW0uVmFsdWUgPSBWYWx1ZTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV4dGVuc2lvbiAoZmllbGQpLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkV4dGVuc2lvblxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZH0gZmllbGQgRXh0ZW5zaW9uIGZpZWxkXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgRXh0ZW5zaW9uID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lLCBmaWVsZCkge1xuICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHBhcmVudCwgbmFtZSk7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4dGVuZGVkIG1lc3NhZ2UgZmllbGQuXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZH1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvLyBFeHRlbmRzIFRcbiAgICAgICAgRXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9uXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3QuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTZXJ2aWNlLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcm9vdCBSb290XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFNlcnZpY2UgPSBmdW5jdGlvbihidWlsZGVyLCByb290LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCByb290LCBuYW1lLCBvcHRpb25zKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWx0IHJ1bnRpbWUgc2VydmljZSBjbGFzcy5cbiAgICAgICAgICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24obmV3OlByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5wcm90b3R5cGVcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgU2VydmljZVByb3RvdHlwZSA9IFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgc2VydmljZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxuICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWJ1aWxkIFdoZXRoZXIgdG8gcmVidWlsZCBvciBub3RcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFNlcnZpY2UgY2xhc3NcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBTZXJ2aWNlUHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocmVidWlsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xheno7XG4gXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJ1bnRpbWUgU2VydmljZSBjbGFzcyBpbiBpdHMgb3duIHNjb3BlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6eiA9IChmdW5jdGlvbihQcm90b0J1ZiwgVCkge1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBTZXJ2aWNlLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSk9fSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvbiByZWNlaXZpbmcgdGhlIG1ldGhvZCBuYW1lIGFuZCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAqIEBjbGFzcyBCYXJlYm9uZSBvZiBhbGwgcnVudGltZSBzZXJ2aWNlcy5cbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNlcnZpY2UgY2Fubm90IGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJwY0ltcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLmNhbGwodGhpcyk7XG4gXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjcnBjSW1wbFxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpfVxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsIHx8IGZ1bmN0aW9uKG5hbWUsIG1zZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hhdCBhIHVzZXIgaGFzIHRvIGltcGxlbWVudDogQSBmdW5jdGlvbiByZWNlaXZpbmcgdGhlIG1ldGhvZCBuYW1lLCB0aGUgYWN0dWFsIG1lc3NhZ2UgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgKHR5cGUgY2hlY2tlZCkgYW5kIHRoZSBjYWxsYmFjayB0aGF0J3MgZWl0aGVyIHByb3ZpZGVkIHdpdGggdGhlIGVycm9yIGFzIGl0cyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgb3IgbnVsbCBhbmQgdGhlIGFjdHVhbCByZXNwb25zZSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIEVycm9yKFwiTm90IGltcGxlbWVudGVkLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL1Byb3RvQnVmLmpzL3dpa2kvU2VydmljZXNcIikpLCAwKTsgLy8gTXVzdCBiZSBhc3luYyFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIFNlcnZpY2VQcm90b3R5cGUgPSBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZSk7XG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGdpdmVuIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuW01ldGhvZF1cbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfEJ5dGVCdWZmZXJ8QnVmZmVyfHN0cmluZyk9KX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xuICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgICAgICAgICAqL1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBpbnN0YW5jZSdzIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjW01ldGhvZF1cbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfEJ5dGVCdWZmZXJ8QnVmZmVyfHN0cmluZyk9KX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xuICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgICAgICAgICAqL1xuIFxuICAgICAgICAgICAgICAgIHZhciBycGMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2QpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxycGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKG1ldGhvZCkge1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmljZSNNZXRob2QobWVzc2FnZSwgY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlUHJvdG90eXBlW21ldGhvZC5uYW1lXSA9IGZ1bmN0aW9uKHJlcSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZ2l2ZW4gYXMgYSBidWZmZXIsIGRlY29kZSB0aGUgcmVxdWVzdC4gV2lsbCB0aHJvdyBhIFR5cGVFcnJvciBpZiBub3QgYSB2YWxpZCBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6ei5kZWNvZGUoQnl0ZUJ1ZmZlci53cmFwKHJlcSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEgPT09IG51bGwgfHwgdHlwZW9mIHJlcSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgYXJndW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBuZXcgbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY2xhenoocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG1ldGhvZC5mcW4oKSwgcmVxLCBmdW5jdGlvbihlcnIsIHJlcykgeyAvLyBBc3N1bWVzIHRoYXQgdGhpcyBpcyBwcm9wZXJseSBhc3luY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29hbGVzY2UgdG8gZW1wdHkgc3RyaW5nIHdoZW4gc2VydmljZSByZXNwb25zZSBoYXMgZW1wdHkgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmVzID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6LmRlY29kZShyZXMpOyB9IGNhdGNoIChub3RBQnVmZmVyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJJbGxlZ2FsIHJlc3BvbnNlIHR5cGUgcmVjZWl2ZWQgaW4gc2VydmljZSBtZXRob2QgXCIrIFQubmFtZStcIiNcIittZXRob2QubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgZXJyKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcnZpY2UuTWV0aG9kKHJwY0ltcGwsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihycGNJbXBsLCByZXEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNlcnZpY2UocnBjSW1wbClbbWV0aG9kLm5hbWVdKHJlcSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBtZXRob2QuYnVpbGRPcHQoKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVByb3RvdHlwZVttZXRob2QubmFtZV0sIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbbWV0aG9kLm5hbWVdW1wiJG9wdGlvbnNcIl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKHJwY1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXNcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLiRvcHRpb25zXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnNTOyAvLyBjYyBuZWVkcyB0aGlzXG4gXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2VydmljZSBvcHRpb25zLlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSMkb3B0aW9uc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyICRvcHRpb25zO1xuIFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlZmxlY3Rpb24gdHlwZS5cbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuJHR5cGVcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX1cbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyICR0eXBlUztcbiBcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGUuXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlIyR0eXBlXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9XG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciAkdHlwZTtcbiBcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVByb3RvdHlwZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVtcIiRvcHRpb25zXCJdIH0pLFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZSwgXCIkdHlwZVwiLCB7IFwidmFsdWVcIjogVCB9KSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VQcm90b3R5cGUsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSk7XG4gXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlcnZpY2U7XG4gXG4gICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3QuU2VydmljZSA9IFNlcnZpY2U7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBYnN0cmFjdCBzZXJ2aWNlIG1ldGhvZC5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgTWV0aG9kID0gZnVuY3Rpb24oYnVpbGRlciwgc3ZjLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgc3ZjLCBuYW1lKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLk1ldGhvZFwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCAqPn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kLnByb3RvdHlwZVxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBNZXRob2RQcm90b3R5cGUgPSBNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZHMgdGhlIG1ldGhvZCdzICckb3B0aW9ucycgcHJvcGVydHkuXG4gICAgICAgICAqIEBuYW1lIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QjYnVpbGRPcHRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxuICAgICAgICAgKi9cbiAgICAgICAgTWV0aG9kUHJvdG90eXBlLmJ1aWxkT3B0ID0gTmFtZXNwYWNlUHJvdG90eXBlLmJ1aWxkT3B0O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCA9IE1ldGhvZDtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJQQyBzZXJ2aWNlIG1ldGhvZC5cbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVlc3Rfc3RyZWFtIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzcG9uc2Vfc3RyZWFtIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgUlBDTWV0aG9kID0gZnVuY3Rpb24oYnVpbGRlciwgc3ZjLCBuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcmVxdWVzdF9zdHJlYW0sIHJlc3BvbnNlX3N0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICAgICAgTWV0aG9kLmNhbGwodGhpcywgYnVpbGRlciwgc3ZjLCBuYW1lLCBvcHRpb25zKTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLlJQQ01ldGhvZFwiO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXF1ZXN0IG1lc3NhZ2UgbmFtZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE5hbWUgPSByZXF1ZXN0O1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNwb25zZSBtZXNzYWdlIG5hbWUuXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlTmFtZSA9IHJlc3BvbnNlO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZFxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0cmVhbSA9IHJlcXVlc3Rfc3RyZWFtO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlU3RyZWFtID0gcmVzcG9uc2Vfc3RyZWFtO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNvbHZlZCByZXF1ZXN0IG1lc3NhZ2UgdHlwZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIG1lc3NhZ2UgdHlwZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSBudWxsO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvLyBFeHRlbmRzIE1ldGhvZFxuICAgICAgICBSUENNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXRob2QucHJvdG90eXBlKTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3QuU2VydmljZS5SUENNZXRob2QgPSBSUENNZXRob2Q7XG4gXG4gICAgICAgIHJldHVybiBSZWZsZWN0O1xuIFxuICAgIH0pKFByb3RvQnVmKTtcbiBcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5CdWlsZGVyID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBMYW5nLCBSZWZsZWN0KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBCdWlsZGVyLlxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5CdWlsZGVyXG4gICAgICAgICAqIEBjbGFzcyBQcm92aWRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBidWlsZCBwcm90b2NvbCBtZXNzYWdlcy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBCdWlsZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UuXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubnMgPSBuZXcgUmVmbGVjdC5OYW1lc3BhY2UodGhpcywgbnVsbCwgXCJcIik7IC8vIEdsb2JhbCBuYW1lc3BhY2VcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmFtZXNwYWNlIHBvaW50ZXIuXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMubnM7XG4gXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc29sdmVkIGZsYWcuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBidWlsZGluZyByZXN1bHQuXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfE9iamVjdD58bnVsbH1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbXBvcnRlZCBmaWxlcy5cbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maWxlcyA9IHt9O1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbXBvcnQgcm9vdCBvdmVycmlkZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBudWxsO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgKj59XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5wcm90b3R5cGVcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgQnVpbGRlclByb3RvdHlwZSA9IEJ1aWxkZXIucHJvdG90eXBlO1xuIFxuICAgICAgICAvLyAtLS0tLSBEZWZpbml0aW9uIHRlc3RzIC0tLS0tXG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXIuaXNNZXNzYWdlID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICAvLyBNZXNzYWdlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gTWVzc2FnZXMgZG8gbm90IGNvbnRhaW4gdmFsdWVzIChlbnVtKSBvciBycGMgbWV0aG9kcyAoc2VydmljZSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1widmFsdWVzXCJdICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVmW1wicnBjXCJdICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYSBtZXNzYWdlIGZpZWxkLlxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnVpbGRlci5pc01lc3NhZ2VGaWVsZCA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBmaWVsZHMgcmVxdWlyZSBhIHN0cmluZyBydWxlLCBuYW1lIGFuZCB0eXBlIGFuZCBhbiBpZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJydWxlXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInR5cGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJpZFwiXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGFuIGVudW0uXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCdWlsZGVyLmlzRW51bSA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgLy8gRW51bXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIEVudW1zIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUFycmF5LmlzQXJyYXkoZGVmW1widmFsdWVzXCJdKSB8fCBkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhIHNlcnZpY2UuXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCdWlsZGVyLmlzU2VydmljZSA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgLy8gU2VydmljZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lIGFuZCBhbiBycGMgb2JqZWN0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJycGNcIl0gIT09ICdvYmplY3QnIHx8ICFkZWZbXCJycGNcIl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGFuIGV4dGVuZGVkIG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBkZWZcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXIuaXNFeHRlbmQgPSBmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgcnF1aXJlIGEgc3RyaW5nIHJlZlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJyZWZcIl0gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvLyAtLS0tLSBCdWlsZGluZyAtLS0tLVxuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBwb2ludGVyIHRvIHRoZSByb290IG5hbWVzcGFjZS5cbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5ucztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBhIG5hbWVzcGFjZSBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgcGxhY2VzIHRoZSBwb2ludGVyIG9uIGl0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KG5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG5hbWVzcGFjZTogXCIrbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZS5zcGxpdChcIi5cIikuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gdGhpcy5wdHIuZ2V0Q2hpbGQocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKG5zID09PSBudWxsKSAvLyBLZWVwIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG5zID0gbmV3IFJlZmxlY3QuTmFtZXNwYWNlKHRoaXMsIHRoaXMucHRyLCBwYXJ0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBucztcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHRoZSBzcGVjaWZpZWQgZGVmaW5pdGlvbnMgYXQgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPCFPYmplY3Q+fSBkZWZzIE1lc3NhZ2VzLCBlbnVtcyBvciBzZXJ2aWNlcyB0byBjcmVhdGVcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIG1lc3NhZ2UgZGVmaW5pdGlvbiBpcyBpbnZhbGlkXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGVmcykge1xuICAgICAgICAgICAgaWYgKCFkZWZzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGNyZWF0ZVxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZnMpKVxuICAgICAgICAgICAgICAgIGRlZnMgPSBbZGVmc107XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIGRlZnMgPSBkZWZzLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICAvLyBJdCdzIHF1aXRlIGhhcmQgdG8ga2VlcCB0cmFjayBvZiBzY29wZXMgYW5kIG1lbW9yeSBoZXJlLCBzbyBsZXQncyBkbyB0aGlzIGl0ZXJhdGl2ZWx5LlxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW2RlZnNdO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkZWZzID0gc3RhY2sucG9wKCk7XG4gXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZnMpKSAvLyBTdGFjayBhbHdheXMgY29udGFpbnMgZW50aXJlIG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgYSB2YWxpZCBuYW1lc3BhY2U6IFwiK0pTT04uc3RyaW5naWZ5KGRlZnMpKTtcbiBcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzLnNoaWZ0KCk7IC8vIE5hbWVzcGFjZXMgYWx3YXlzIGNvbnRhaW4gYW4gYXJyYXkgb2YgbWVzc2FnZXMsIGVudW1zIGFuZCBzZXJ2aWNlc1xuIFxuICAgICAgICAgICAgICAgICAgICBpZiAoQnVpbGRlci5pc01lc3NhZ2UoZGVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UodGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0sIGRlZltcImlzR3JvdXBcIl0sIGRlZltcInN5bnRheFwiXSk7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgT25lT2ZzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lb2ZzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wib25lb2ZzXCJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRlZltcIm9uZW9mc1wiXSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChvbmVvZnNbbmFtZV0gPSBuZXcgUmVmbGVjdC5NZXNzYWdlLk9uZU9mKHRoaXMsIG9iaiwgbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImZpZWxkc1wiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJmaWVsZHNcIl0uZm9yRWFjaChmdW5jdGlvbihmbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5nZXRDaGlsZChmbGRbXCJpZFwiXXwwKSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG9yIGludmFsaWQgZmllbGQgaWQgaW4gXCIrb2JqLm5hbWUrXCI6IFwiK2ZsZFsnaWQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGRbXCJvcHRpb25zXCJdICYmIHR5cGVvZiBmbGRbXCJvcHRpb25zXCJdICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBmaWVsZCBvcHRpb25zIGluIFwiK29iai5uYW1lK1wiI1wiK2ZsZFtcIm5hbWVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lb2YgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsZFtcIm9uZW9mXCJdID09PSAnc3RyaW5nJyAmJiAhKG9uZW9mID0gb25lb2ZzW2ZsZFtcIm9uZW9mXCJdXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgb25lb2YgaW4gXCIrb2JqLm5hbWUrXCIjXCIrZmxkW1wibmFtZVwiXStcIjogXCIrZmxkW1wib25lb2ZcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGQgPSBuZXcgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKHRoaXMsIG9iaiwgZmxkW1wicnVsZVwiXSwgZmxkW1wia2V5dHlwZVwiXSwgZmxkW1widHlwZVwiXSwgZmxkW1wibmFtZVwiXSwgZmxkW1wiaWRcIl0sIGZsZFtcIm9wdGlvbnNcIl0sIG9uZW9mLCBkZWZbXCJzeW50YXhcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVvZi5maWVsZHMucHVzaChmbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQoZmxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggY2hpbGRyZW4gdG8gc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJPYmogPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJlbnVtc1wiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJlbnVtc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGVubSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChlbm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcIm1lc3NhZ2VzXCJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcIm1lc3NhZ2VzXCJdLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wic2VydmljZXNcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wic2VydmljZXNcIl0uZm9yRWFjaChmdW5jdGlvbihzdmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2goc3ZjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBleHRlbnNpb24gcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZXh0ZW5zaW9uc1wiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXVswXSA9PT0gJ251bWJlcicpIC8vIHByZSA1LjAuMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFsgZGVmW1wiZXh0ZW5zaW9uc1wiXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnMgPSBkZWZbXCJleHRlbnNpb25zXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9uIHRvcCBvZiBjdXJyZW50IG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJPYmoubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZGVmcyk7IC8vIFB1c2ggdGhlIGN1cnJlbnQgbGV2ZWwgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMgPSBzdWJPYmo7IC8vIENvbnRpbnVlIHByb2Nlc3Npbmcgc3ViIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG9iajsgLy8gQW5kIG1vdmUgdGhlIHBvaW50ZXIgdG8gdGhpcyBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcbiBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzRW51bShkZWYpKSB7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5FbnVtKHRoaXMsIHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdLCBkZWZbXCJzeW50YXhcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1widmFsdWVzXCJdLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0LkVudW0uVmFsdWUodGhpcywgb2JqLCB2YWxbXCJuYW1lXCJdLCB2YWxbXCJpZFwiXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xuIFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNTZXJ2aWNlKGRlZikpIHtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LlNlcnZpY2UodGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGVmW1wicnBjXCJdKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXRkID0gZGVmW1wicnBjXCJdW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCh0aGlzLCBvYmosIG5hbWUsIG10ZFtcInJlcXVlc3RcIl0sIG10ZFtcInJlc3BvbnNlXCJdLCAhIW10ZFtcInJlcXVlc3Rfc3RyZWFtXCJdLCAhIW10ZFtcInJlc3BvbnNlX3N0cmVhbVwiXSwgbXRkW1wib3B0aW9uc1wiXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xuIFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNFeHRlbmQoZGVmKSkge1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy5wdHIucmVzb2x2ZShkZWZbXCJyZWZcIl0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcImZpZWxkc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGZsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmdldENoaWxkKGZsZFsnaWQnXXwwKSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmaWVsZCBpZCBpcyBhbGxvd2VkIHRvIGJlIGV4dGVuZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsZFtcImlkXCJdID49IHJhbmdlWzBdICYmIGZsZFtcImlkXCJdIDw9IHJhbmdlWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10rXCIgKG5vdCB3aXRoaW4gdmFsaWQgcmFuZ2VzKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGV4dGVuc2lvbiBmaWVsZCBuYW1lcyB0byBjYW1lbCBjYXNlIG5vdGF0aW9uIGlmIHRoZSBvdmVycmlkZSBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbGRbXCJuYW1lXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBQcm90b0J1Zi5VdGlsLnRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgIzE2MTogRXh0ZW5zaW9ucyB1c2UgdGhlaXIgZnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgdGhlaXIgcnVudGltZSBrZXkgYW5kLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQodGhpcywgb2JqLCBmbGRbXCJydWxlXCJdLCBmbGRbXCJ0eXBlXCJdLCB0aGlzLnB0ci5mcW4oKSsnLicrbmFtZSwgZmxkW1wiaWRcIl0sIGZsZFtcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5hcmUgYWRkZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50IG5hbWVzcGFjZSBhcyBhbiBleHRlbnNpb24gd2hpY2ggaXMgdXNlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZWlyIHR5cGUgbGF0ZXIgb24gKHRoZSBleHRlbnNpb24gYWx3YXlzIGtlZXBzIHRoZSBvcmlnaW5hbCBuYW1lIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbmFtaW5nIGNvbGxpc2lvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBuZXcgUmVmbGVjdC5FeHRlbnNpb24odGhpcywgdGhpcy5wdHIsIGZsZFtcIm5hbWVcIl0sIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZXh0ZW5zaW9uID0gZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghL1xcLj9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdChkZWZbXCJyZWZcIl0pKSAvLyBTaWxlbnRseSBza2lwIGludGVybmFsIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImV4dGVuZGVkIG1lc3NhZ2UgXCIrZGVmW1wicmVmXCJdK1wiIGlzIG5vdCBkZWZpbmVkXCIpO1xuIFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGEgdmFsaWQgZGVmaW5pdGlvbjogXCIrSlNPTi5zdHJpbmdpZnkoZGVmKSk7XG4gXG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJyZWFrIGdvZXMgaGVyZVxuICAgICAgICAgICAgICAgIGRlZnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5wdHIucGFyZW50OyAvLyBOYW1lc3BhY2UgZG9uZSwgY29udGludWUgYXQgcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7IC8vIFJlcXVpcmUgcmUtcmVzb2x2ZVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BhZ2F0ZXMgc3ludGF4IHRvIGFsbCBjaGlsZHJlbi5cbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBwYXJlbnRcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwcm9wYWdhdGVTeW50YXgocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50WydtZXNzYWdlcyddKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50WydtZXNzYWdlcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbXCJzeW50YXhcIl0gPSBwYXJlbnRbXCJzeW50YXhcIl07XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVN5bnRheChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50WydlbnVtcyddKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50WydlbnVtcyddLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbXCJzeW50YXhcIl0gPSBwYXJlbnRbXCJzeW50YXhcIl07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcG9ydHMgYW5vdGhlciBkZWZpbml0aW9uIGludG8gdGhpcyBidWlsZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIFBhcnNlZCBpbXBvcnRcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgSW1wb3J0ZWQgZmlsZSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gb3IgZmlsZSBjYW5ub3QgYmUgaW1wb3J0ZWRcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgQnVpbGRlclByb3RvdHlwZVtcImltcG9ydFwiXSA9IGZ1bmN0aW9uKGpzb24sIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGVsaW0gPSAnLyc7XG4gXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gc2tpcCBkdXBsaWNhdGUgaW1wb3J0c1xuIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpIHtcbiBcbiAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuVXRpbC5JU19OT0RFKVxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUoXCJwYXRoXCIpWydyZXNvbHZlJ10oZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9IHRydWU7XG4gXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gT2JqZWN0IHdpdGggcm9vdCwgZmlsZS5cbiBcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbGVuYW1lLnJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJlcXVpcmUoXCJwYXRoXCIpWydyZXNvbHZlJ10ocm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuaW5kZXhPZihcIlxcXFxcIikgPj0gMCB8fCBmaWxlbmFtZS5maWxlLmluZGV4T2YoXCJcXFxcXCIpID49IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgIHZhciBmbmFtZSA9IHJvb3QgKyBkZWxpbSArIGZpbGVuYW1lLmZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbZm5hbWVdID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXNbZm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgIC8vIEltcG9ydCBpbXBvcnRzXG4gXG4gICAgICAgICAgICBpZiAoanNvblsnaW1wb3J0cyddICYmIGpzb25bJ2ltcG9ydHMnXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydFJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0Um9vdCA9IGZhbHNlO1xuIFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7IC8vIElmIGFuIGltcG9ydCByb290IGlzIHNwZWNpZmllZCwgb3ZlcnJpZGVcbiBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gZmlsZW5hbWVbXCJyb290XCJdOyByZXNldFJvb3QgPSB0cnVlOyAvLyAuLi4gYW5kIHJlc2V0IGFmdGVyd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IHRoaXMuaW1wb3J0Um9vdDtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZVtcImZpbGVcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRSb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xuIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xuIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbXBvcnRSb290KSAvLyBJZiBpbXBvcnQgcm9vdCBpcyBvdmVycmlkZGVuLCB1c2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBPdGhlcndpc2UgY29tcHV0ZSBmcm9tIGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIi9cIikgPj0gMCkgeyAvLyBVbml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIC9maWxlLnByb3RvICovIGltcG9ydFJvb3QgPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMCkgeyAvLyBXaW5kb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcXFxbXlxcXFxdKiQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gbnVsbDtcbiBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8anNvblsnaW1wb3J0cyddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvblsnaW1wb3J0cyddW2ldID09PSAnc3RyaW5nJykgeyAvLyBJbXBvcnQgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRSb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiY2Fubm90IGRldGVybWluZSBpbXBvcnQgcm9vdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRGaWxlbmFtZSA9IGpzb25bJ2ltcG9ydHMnXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRGaWxlbmFtZSA9PT0gXCJnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90b1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBOb3QgbmVlZGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEZpbGVuYW1lID0gaW1wb3J0Um9vdCArIGRlbGltICsgaW1wb3J0RmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tpbXBvcnRGaWxlbmFtZV0gPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEFscmVhZHkgaW1wb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwucHJvdG8kL2kudGVzdChpbXBvcnRGaWxlbmFtZSkgJiYgIVByb3RvQnVmLkRvdFByb3RvKSAgICAgICAvLyBJZiB0aGlzIGlzIGEgbGlnaHQgYnVpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IGltcG9ydEZpbGVuYW1lLnJlcGxhY2UoL1xcLnByb3RvJC8sIFwiLmpzb25cIik7IC8vIGFsd2F5cyBsb2FkIHRoZSBKU09OIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2goaW1wb3J0RmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZmFpbGVkIHRvIGltcG9ydCAnXCIraW1wb3J0RmlsZW5hbWUrXCInIGluICdcIitmaWxlbmFtZStcIic6IGZpbGUgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5qc29uJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpKSAvLyBBbHdheXMgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKEpTT04ucGFyc2UoY29udGVudHMrXCJcIiksIGltcG9ydEZpbGVuYW1lKTsgLy8gTWF5IHRocm93XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIucGFyc2UoY29udGVudHMpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLy8gSW1wb3J0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFwuKFxcdyspJC8udGVzdChmaWxlbmFtZSkpIC8vIFdpdGggZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gdGhlIG5hbWUgcG9ydGlvbiB0byBtYWtlIGl0IHVuaXF1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZS5yZXBsYWNlKC9eKC4rKVxcLihcXHcrKSQvLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7IHJldHVybiAkMStcIl9pbXBvcnRcIitpK1wiLlwiKyQyOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIFdpdGhvdXQgZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gbWFrZSBpdCB1bmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUrXCJfaW1wb3J0XCIraSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNldFJvb3QpIC8vIFJlc2V0IGltcG9ydCByb290IG92ZXJyaWRlIHdoZW4gYWxsIGltcG9ydHMgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgIC8vIEltcG9ydCBzdHJ1Y3R1cmVzXG4gXG4gICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSk7XG4gICAgICAgICAgICBpZiAoanNvblsnc3ludGF4J10pXG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlU3ludGF4KGpzb24pO1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLnB0cjtcbiAgICAgICAgICAgIGlmIChqc29uWydvcHRpb25zJ10pXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoanNvblsnb3B0aW9ucyddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlLm9wdGlvbnNba2V5XSA9IGpzb25bJ29wdGlvbnMnXVtrZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGpzb25bJ21lc3NhZ2VzJ10pXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnbWVzc2FnZXMnXSksXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGpzb25bJ2VudW1zJ10pXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZW51bXMnXSksXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGpzb25bJ3NlcnZpY2VzJ10pXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnc2VydmljZXMnXSksXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGpzb25bJ2V4dGVuZHMnXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydleHRlbmRzJ10pO1xuIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGFsbCBuYW1lc3BhY2Ugb2JqZWN0cy5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjYW5ub3QgYmUgcmVzb2x2ZWRcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbGwgcmVmbGVjdGVkIG9iamVjdHNcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5wdHIgPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5wdHIudHlwZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIERvbmUgKGFscmVhZHkgcmVzb2x2ZWQpXG4gXG4gICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkgeyAvLyBSZXNvbHZlIGNoaWxkcmVuXG4gXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBbGwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpIHsgLy8gUmVzb2x2ZSB0eXBlXG4gXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEUudGVzdCh0aGlzLnB0ci50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRoaXMucHRyLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkID8gdGhpcy5wdHIuZXh0ZW5zaW9uLnBhcmVudCA6IHRoaXMucHRyLnBhcmVudCkucmVzb2x2ZSh0aGlzLnB0ci50eXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVucmVzb2x2YWJsZSB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkVHlwZSA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuRW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ci5zeW50YXggPT09ICdwcm90bzMnICYmIHJlcy5zeW50YXggIT09ICdwcm90bzMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwicHJvdG8zIG1lc3NhZ2UgY2Fubm90IHJlZmVyZW5jZSBwcm90bzIgZW51bVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gcmVzLmlzR3JvdXAgPyBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdIDogUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIudHlwZV07XG4gXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIG1hcCBmaWVsZCwgYWxzbyByZXNvbHZlIHRoZSBrZXkgdHlwZS4gVGhlIGtleSB0eXBlIGNhbiBiZSBvbmx5IGEgbnVtZXJpYywgc3RyaW5nLCBvciBib29sIHR5cGVcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiwgbm8gZW51bXMgb3IgbWVzc2FnZXMpLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlc29sdmUgYWdhaW5zdCB0aGUgY3VycmVudCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLm1hcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRoaXMucHRyLmtleVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGtleSB0eXBlIGZvciBtYXAgZmllbGQgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLmtleVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5rZXlUeXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIua2V5VHlwZV07XG4gICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QpIHtcbiBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlcXVlc3ROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci5yZXF1ZXN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkUmVxdWVzdFR5cGUgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlc3BvbnNlTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVzcG9uc2VOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSByZXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIC8vIFNob3VsZCBub3QgaGFwcGVuIGFzIG5vdGhpbmcgZWxzZSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc2VydmljZSB0eXBlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpKTtcbiBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5PbmVPZikgJiYgLy8gTm90IGJ1aWx0XG4gICAgICAgICAgICAgICAgISh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9uKSAmJiAvLyBOb3QgYnVpbHRcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlKSAvLyBCdWlsdCBpbiBlbnVtXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIG9iamVjdCBpbiBuYW1lc3BhY2U6IFwiK3R5cGVvZih0aGlzLnB0cikrXCI6IFwiK3RoaXMucHRyKTtcbiBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZHMgdGhlIHByb3RvY29sLiBUaGlzIHdpbGwgZmlyc3QgdHJ5IHRvIHJlc29sdmUgYWxsIGRlZmluaXRpb25zIGFuZCwgaWYgdGhpcyBoYXMgYmVlbiBzdWNjZXNzZnVsLFxuICAgICAgICAgKiByZXR1cm4gdGhlIGJ1aWx0IHBhY2thZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xBcnJheS48c3RyaW5nPik9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8IU9iamVjdC48c3RyaW5nLCo+fVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSB0eXBlIGNvdWxkIG5vdCBiZSByZXNvbHZlZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUFsbCgpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlLFxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0ID09PSBudWxsKSAvLyAoUmUtKUJ1aWxkXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLm5zLmJ1aWxkKCk7XG4gICAgICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICAgICAgdmFyIHBhcnQgPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgPyBwYXRoLnNwbGl0KFwiLlwiKSA6IHBhdGgsXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yZXN1bHQ7IC8vIEJ1aWxkIG5hbWVzcGFjZSBwb2ludGVyIChubyBoYXNDaGlsZCBldGMuKVxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBhcnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHB0cltwYXJ0W2ldXSlcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyW3BhcnRbaV1dO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogU2ltaWxhciB0byB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlciNidWlsZH0sIGJ1dCBsb29rcyB1cCB0aGUgaW50ZXJuYWwgcmVmbGVjdGlvbiBkZXNjcmlwdG9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggU3BlY2lmaWVzIHdoYXQgdG8gcmV0dXJuLiBJZiBvbWl0dGVkLCB0aGUgZW50aXJlIG5hbWVzcGFjZSB3aWlsIGJlIHJldHVybmVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMgbGlrZSBmaWVsZHMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgICogQHJldHVybnMgez9Qcm90b0J1Zi5SZWZsZWN0LlR9IFJlZmxlY3Rpb24gZGVzY3JpcHRvciBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHBhdGgsIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoID8gdGhpcy5ucy5yZXNvbHZlKHBhdGgsIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIDogdGhpcy5ucztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiQnVpbGRlclwiXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkJ1aWxkZXJcIjtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLy8gLS0tLS0gQmFzZSBjbGFzc2VzIC0tLS0tXG4gICAgICAgIC8vIEV4aXN0IGZvciB0aGUgc29sZSBwdXJwb3NlIG9mIGJlaW5nIGFibGUgdG8gXCIuLi4gaW5zdGFuY2VvZiBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcIiBldGMuXG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBCdWlsZGVyLk1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIuRW51bVxuICAgICAgICAgKi9cbiAgICAgICAgQnVpbGRlci5FbnVtID0gZnVuY3Rpb24oKSB7fTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIEJ1aWxkZXIuU2VydmljZSA9IGZ1bmN0aW9uKCkge307XG4gXG4gICAgICAgIHJldHVybiBCdWlsZGVyO1xuIFxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nLCBQcm90b0J1Zi5SZWZsZWN0KTtcbiBcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuTWFwXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLk1hcCA9IChmdW5jdGlvbihQcm90b0J1ZiwgUmVmbGVjdCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWFwLiBBIE1hcCBpcyBhIGNvbnRhaW5lciB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IG1hcFxuICAgICAgICAgKiBmaWVsZHMgb24gbWVzc2FnZSBvYmplY3RzLiBJdCBjbG9zZWx5IGZvbGxvd3MgdGhlIEVTNiBNYXAgQVBJOyBob3dldmVyLFxuICAgICAgICAgKiBpdCBpcyBkaXN0aW5jdCBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBleHRlcm5hbCBwb2x5ZmlsbHMgb3JcbiAgICAgICAgICogb24gRVM2IGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuTWFwXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuRmllbGR9IGZpZWxkIE1hcCBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gY29udGVudHMgSW5pdGlhbCBjb250ZW50c1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBNYXAgPSBmdW5jdGlvbihmaWVsZCwgY29udGVudHMpIHtcbiAgICAgICAgICAgIGlmICghZmllbGQubWFwKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZmllbGQgaXMgbm90IGEgbWFwXCIpO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZmllbGQgY29ycmVzcG9uZGluZyB0byB0aGlzIG1hcC5cbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbGVtZW50IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8ga2V5IHR5cGUuXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRWxlbWVudH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5rZXlFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC5rZXlUeXBlLCBudWxsLCB0cnVlLCBmaWVsZC5zeW50YXgpO1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbGVtZW50IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8gdmFsdWUgdHlwZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FbGVtZW50fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZhbHVlRWxlbSA9IG5ldyBSZWZsZWN0LkVsZW1lbnQoZmllbGQudHlwZSwgZmllbGQucmVzb2x2ZWRUeXBlLCBmYWxzZSwgZmllbGQuc3ludGF4KTtcbiBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW50ZXJuYWwgbWFwOiBzdG9yZXMgbWFwcGluZyBvZiAoc3RyaW5nIGZvcm0gb2Yga2V5KSAtPiAoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAqIHBhaXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogV2UgcHJvdmlkZSBtYXAgc2VtYW50aWNzIGZvciBhcmJpdHJhcnkga2V5IHR5cGVzLCBidXQgd2UgYnVpbGQgb24gdG9wXG4gICAgICAgICAgICAgKiBvZiBhbiBPYmplY3QsIHdoaWNoIGhhcyBvbmx5IHN0cmluZyBrZXlzLiBJbiBvcmRlciB0byBhdm9pZCB0aGUgbmVlZFxuICAgICAgICAgICAgICogdG8gY29udmVydCBhIHN0cmluZyBrZXkgYmFjayB0byBpdHMgbmF0aXZlIHR5cGUgaW4gbWFueSBzaXR1YXRpb25zLFxuICAgICAgICAgICAgICogd2Ugc3RvcmUgdGhlIG5hdGl2ZSBrZXkgdmFsdWUgYWxvbmdzaWRlIHRoZSB2YWx1ZS4gVGh1cywgd2Ugb25seSBuZWVkXG4gICAgICAgICAgICAgKiBhIG9uZS13YXkgbWFwcGluZyBmcm9tIGEga2V5IHR5cGUgdG8gaXRzIHN0cmluZyBmb3JtIHRoYXQgZ3VhcmFudGVlc1xuICAgICAgICAgICAgICogdW5pcXVlbmVzcyBhbmQgZXF1YWxpdHkgKGkuZS4sIHN0cihLMSkgPT09IHN0cihLMikgaWYgYW5kIG9ubHkgaWYgSzFcbiAgICAgICAgICAgICAqID09PSBLMikuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCB7a2V5OiAqLCB2YWx1ZTogKn0+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xuIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKS5sZW5ndGg7IH1cbiAgICAgICAgICAgIH0pO1xuIFxuICAgICAgICAgICAgLy8gRmlsbCBpbml0aWFsIGNvbnRlbnRzIGZyb20gYSByYXcgb2JqZWN0LlxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb250ZW50cyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUVsZW0udmFsdWVGcm9tU3RyaW5nKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZUVsZW0udmVyaWZ5VmFsdWUoY29udGVudHNba2V5c1tpXV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcFt0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyhrZXkpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleToga2V5LCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuIFxuICAgICAgICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlcjogcmV0dXJuIGFuIGl0ZXJhdG9yIG92ZXIgYW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIgdGhlIGFycmF5XG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBhbiBpdGVyYXRvclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5SXRlcmF0b3IoYXJyKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPCBhcnIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBhcnJbaWR4KytdIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgbWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgTWFwUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIHBhcnRpY3VsYXIga2V5IGZyb20gdGhlIG1hcC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgYW55IGVudHJ5IHdpdGggdGhpcyBrZXkgd2FzIGRlbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBNYXBQcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgIHZhciBoYWRLZXkgPSBrZXlWYWx1ZSBpbiB0aGlzLm1hcDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXlWYWx1ZV07XG4gICAgICAgICAgICByZXR1cm4gaGFkS2V5O1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIFtrZXksIHZhbHVlXSBwYWlycyBpbiB0aGUgbWFwLlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaXRlcmF0b3JcbiAgICAgICAgICovXG4gICAgICAgIE1hcFByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0cktleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaChbKGVudHJ5PXRoaXMubWFwW3N0cktleXNbaV1dKS5rZXksIGVudHJ5LnZhbHVlXSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlJdGVyYXRvcihlbnRyaWVzKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciBrZXlzIGluIHRoZSBtYXAuXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpdGVyYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgTWFwUHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICB2YXIgc3RyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubWFwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyS2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2godGhpcy5tYXBbc3RyS2V5c1tpXV0ua2V5KTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKGtleXMpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHZhbHVlcyBpbiB0aGUgbWFwLlxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH0gVGhlIGl0ZXJhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBNYXBQcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgc3RyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubWFwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyS2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLm1hcFtzdHJLZXlzW2ldXS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlJdGVyYXRvcih2YWx1ZXMpO1xuICAgICAgICB9O1xuIFxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZXMgb3ZlciBlbnRyaWVzIGluIHRoZSBtYXAsIGNhbGxpbmcgYSBmdW5jdGlvbiBvbiBlYWNoLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6KiwgKiwgKiwgKil9IGNiIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB2YWx1ZSwga2V5LCBhbmQgbWFwIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSB0aGlzQXJnIFRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgTWFwUHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYiwgdGhpc0FyZykge1xuICAgICAgICAgICAgdmFyIHN0cktleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGNiLmNhbGwodGhpc0FyZywgKGVudHJ5PXRoaXMubWFwW3N0cktleXNbaV1dKS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBrZXkgaW4gdGhlIG1hcCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWVcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5NYXB9IFRoZSBtYXAgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1hcFByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KTtcbiAgICAgICAgICAgIHZhciB2YWxWYWx1ZSA9IHRoaXMudmFsdWVFbGVtLnZlcmlmeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubWFwW3RoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKGtleVZhbHVlKV0gPVxuICAgICAgICAgICAgICAgIHsga2V5OiBrZXlWYWx1ZSwgdmFsdWU6IHZhbFZhbHVlIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkgaW4gdGhlIG1hcC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7Knx1bmRlZmluZWR9IFRoZSB2YWx1ZSwgb3IgYHVuZGVmaW5lZGAgaWYga2V5IG5vdCBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBNYXBQcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyh0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KSk7XG4gICAgICAgICAgICBpZiAoIShrZXlWYWx1ZSBpbiB0aGlzLm1hcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXlWYWx1ZV0udmFsdWU7XG4gICAgICAgIH07XG4gXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBwcmVzZW50IGluIHRoZSBtYXAuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXlcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUga2V5IGlzIHByZXNlbnRcbiAgICAgICAgICovXG4gICAgICAgIE1hcFByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiAoa2V5VmFsdWUgaW4gdGhpcy5tYXApO1xuICAgICAgICB9O1xuIFxuICAgICAgICByZXR1cm4gTWFwO1xuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5SZWZsZWN0KTtcbiBcbiBcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIC5wcm90byBzdHJpbmcgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIC5wcm90byBmaWxlIGNvbnRlbnRzXG4gICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxuICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLmxvYWRQcm90byA9IGZ1bmN0aW9uKHByb3RvLCBidWlsZGVyLCBmaWxlbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGJ1aWxkZXIsXG4gICAgICAgICAgICBidWlsZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gUHJvdG9CdWYubG9hZEpzb24oUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnBhcnNlKHByb3RvKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xuICAgIH07XG4gXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSAucHJvdG8gc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG99LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byAucHJvdG8gZmlsZSBjb250ZW50c1xuICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nKT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXG4gICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYucHJvdG9Gcm9tU3RyaW5nID0gUHJvdG9CdWYubG9hZFByb3RvOyAvLyBMZWdhY3lcbiBcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8gcHJvdG8gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxuICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxuICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcbiAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cbiAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcbiAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIFByb3RvQnVmLmxvYWRQcm90b0ZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRQcm90byhjb250ZW50cywgYnVpbGRlciwgZmlsZW5hbWUpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcgPyBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdIDogZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSk7XG4gICAgfTtcbiBcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIHByb3RvIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcbiAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXG4gICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5wcm90b0Zyb21GaWxlID0gUHJvdG9CdWYubG9hZFByb3RvRmlsZTsgLy8gTGVnYWN5XG4gXG4gXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBlbXB0eSBCdWlsZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIEJ1aWxkZXIgb3B0aW9ucywgZGVmYXVsdHMgdG8gZ2xvYmFsIG9wdGlvbnMgc2V0IG9uIFByb3RvQnVmXG4gICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYubmV3QnVpbGRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgb3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gPSBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2U7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBvcHRpb25zWydwb3B1bGF0ZUFjY2Vzc29ycyddID0gUHJvdG9CdWYucG9wdWxhdGVBY2Nlc3NvcnM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvdG9CdWYuQnVpbGRlcihvcHRpb25zKTtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgLmpzb24gZGVmaW5pdGlvbiBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cbiAgICAgKiBAcGFyYW0geyEqfHN0cmluZ30ganNvbiBKU09OIGRlZmluaXRpb25cbiAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXG4gICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgUHJvdG9CdWYubG9hZEpzb24gPSBmdW5jdGlvbihqc29uLCBidWlsZGVyLCBmaWxlbmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGJ1aWxkZXIsXG4gICAgICAgICAgICBidWlsZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKCFidWlsZGVyIHx8IHR5cGVvZiBidWlsZGVyICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIGJ1aWxkZXIgPSBQcm90b0J1Zi5uZXdCdWlsZGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgYnVpbGRlcltcImltcG9ydFwiXShqc29uLCBmaWxlbmFtZSk7XG4gICAgICAgIGJ1aWxkZXIucmVzb2x2ZUFsbCgpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9O1xuIFxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgLmpzb24gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3whe3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBqc29uIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcbiAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXG4gICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBQcm90b0J1Zi5sb2FkSnNvbkZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRKc29uKEpTT04ucGFyc2UoY29udGVudHMpLCBidWlsZGVyLCBmaWxlbmFtZSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JyA/IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0gOiBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBjb250ZW50cyA9PT0gbnVsbCA/IG51bGwgOiBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xuICAgIH07XG4gXG4gICAgcmV0dXJuIFByb3RvQnVmO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9